<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【java总结】计算机网络</title>
    <link href="/2020/07/28/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/07/28/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】计算机网络"><a href="#【java总结】计算机网络" class="headerlink" title="【java总结】计算机网络"></a>【java总结】计算机网络</h1><blockquote><p>本内容参考了多位大佬，几十篇博客整理出来的，方便自己的复习，同时有不全面，不正确的内容欢迎补充</p></blockquote><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h3><p>那我们作为一个程序员，难免会去编写一些通信类应用，甚至开发桌面端应用（好像C++更多吧），就算你是一个前端，那么总是要和后台取数据吧，天天post，get，我们也总要学一些计算机网络知识。（详细学习的话强烈推荐谢希仁老师的计算机网络）</p><p>那么什么是计算机网络呢？</p><p>很多书都是这么一句话：计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。</p><p>我们生活中从电脑出发，背后连接着一根网线（如果使用的无线，那么就把他当作一根看不见的线）然后这跟网线连接到家里墙上的一个出口，然后这个出口连接到小区的汇聚交换机上面，然后中间经过其他交换机，路由器，再连接到我们这个城市的中心路由器上面。其他城市的小伙伴同样这样，然后两个城市间架起一座桥梁（我们这里暂时只把他记作光纤），那么，网络就是这样。</p><blockquote><p>从宏观上面来看，就是这么简单</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728203448.png" srcset="/img/loading.gif" alt="image-20200728203448182"></p><p>但是我们继续想，网络可能同时有大量的数据，同时在光纤上面传输，而且还同时有大量的人发送，</p><p>我们怎么才能在光纤上传递文字，图片，甚至音频，接受到你的消息以后，你怎么把他还原，看一看他到第是什么</p><p>于是乎，网络又变得复杂了起来，甚至复杂到一种很难解释的情况。</p><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>（举个例子：一个皇帝又管大家吃饭，又管外出打仗，这时候还要考虑王阿姨家的猫和另一个省的一条狗重名了，王阿姨不乐意了，可是生活就是这样，皇帝于是决定周一处理打仗的事情，周三处理王阿姨的事情，情况有所缓解，于是乎他设立了不同的官员去做不同的事情，就这样，把大事分成小事去做就解决了这个问题）</p><p>这时候，有人提出来，我们把网络分层，每一层只处理本层的事情，处理完再传递给下一层</p><p>于是ISO（国际标准化组织）提出了OSI/RM（开放系统互连参考模型）大家根据单词首字母简单记一下</p><p>这个组织把网络通信分为了七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>但是有趣的是ISO提出来以后没啥产品，于是伴随着Internet火遍大江南北，TCP/IP才成为真正使用的协议</p><p>更有趣的TCP/IP的四层把物理层和数据链路层给合并了，但是物理层这么重要的一层，直接跟物理设备打交道，这也太没面子了</p><p>而且最主要的人类思考起来不太方便，那么我们经常说的是TCP/IP的五层模型</p><p><img src="https://img2.jimu98.cn/blog/20200728212643.png" srcset="/img/loading.gif" alt="image-20200728212643527"></p><blockquote><p>这张图还是要背的，有些时候理解不了的知识，那么就去背。背会了，慢慢就理解了。</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>（举个例子，小A和小B要通讯，小A要给小B发送一幅蒙娜丽莎，但是光纤可不能直接发送画呀，只能发送0，1字符串，于是小A发送了 1100111代表蒙娜丽莎，小B收到了，非要翻译成清明上河图，你说这闹的。。。）</p><p>所以通信双方想要通信，必须建立约定，约定好1100111就是蒙娜丽莎，约定就可以称作协议，因此通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><p>换个例子</p><p>小A和小B要通讯，比作小A给小B寄快递</p><p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p><p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p><p><code>ping</code> 可以说是网络层ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-IP解释"><a href="#TCP-IP解释" class="headerlink" title="TCP/IP解释"></a>TCP/IP解释</h3><p>这个分层相当重要，前面也说过了，TCP/IP才是我们真正实现了的协议（那么我们到底说的是四层呢还是五层呢，在生活中常用五层，但是TCP/IP提出时候就是四层，但是大家不要迷惑，你就站在他们头顶，聊到四层，就往四层想，聊到五层，就往五层想，游刃有余的时候，就能感觉到，他们就是一个东西，emmm，这里我有点说不清楚。。）</p><blockquote><p>另外，TCP/IP是一个协议簇，也就是一个组合，包含了多种协议，但是TCP和IP最具代表性，所以被称为TCP/IP协议。</p></blockquote><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>它们都属于传输层协议,</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p><h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP  三次握手"></a>TCP  三次握手</h5><blockquote><p>这个好多人都吃过亏，感觉好复杂，我觉得码农翻身里面这一段解释的特别简单</p><p>第一次：A跟B说话   B收到了 B知道A发送消息没问题</p><p>第二次：B跟A说话   A收到了  A知道B发送和接收都没问题</p><p>第三次：A跟B说话   B收到了  B知道A发送和接收都没问题</p><p>于是乎，A和B可以正常通讯了</p></blockquote><p>为什么需要三次握手呢？两次不行吗？</p><blockquote><p>在谢希仁的《计算机网络》中是这样说的：”为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。”</p><p>我们先要知道TCP是基于IP协议的（下面有解释），而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。</p><p>比如A和B说话，A跟B说：“在吗，借我一块钱”，B回答他：“给你转到支付宝了”，但是B说的这句话走的一条很漫长的路，走了一分钟。</p><p>但是A说完了，等了好久B都不理他，他以为B就没收到他说的话，他又发了一句话：“在吗，借我一块钱”，这时候B又收到了，他不知道这是A从新发送的，以为又建立了一个新的通话连接，于是这个过程就会浪费很多的资源，而三次握手就相对保险。</p></blockquote><p>简单的理解了，那我们也要看看复杂的情况（我会尽量说的清楚）</p><p>暂时只看绿色部分的三次握手（状态大家可以百度一下TCP11种状态，我感觉直接翻译可能更乱）</p><blockquote><p>1.第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x（也就是随机值）；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</p><p>2.第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</p><p>3.第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</p></blockquote><p><img src="https://image.jellythink.com/jellythinkTCP4.jpg" srcset="/img/loading.gif" alt="alt"></p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><blockquote><p>举个栗子：把客户端比作男孩，服务器比作女孩。通过他们的分手来说明“四次挥手”过程。</p><p>“第一次挥手”：男孩发现女孩变成了自己讨厌的样子，忍无可忍，于是决定分手，随即写了一封信告诉女孩。</p><p>“第二次挥手”：女孩收到信之后，知道了男孩要和自己分手，怒火中烧，心中暗骂：你算什么东西，当初你可不是这个样子的！于是立马给男孩写了一封回信：分手就分手，给我点时间，我要把你的东西整理好，全部还给你！男孩收到女孩的第一封信之后，明白了女孩知道自己要和她分手。随后等待女孩把自己的东西收拾好。</p><p>“第三次挥手”：过了几天，女孩把男孩送的东西都整理好了，于是再次写信给男孩：你的东西我整理好了，快把它们拿走，从此你我恩断义绝！</p><p>“第四次挥手”：男孩收到女孩第二封信之后，知道了女孩收拾好东西了，可以正式分手了，于是再次写信告诉女孩：我知道了，这就去拿回来！（这里有一个重要的概念 <code>TIME-WAIT</code> 阿正哥说这个可以比作冷静期 emmm~）</p><p>这里双方都有各自的坚持。女孩自发出第二封信开始，限定一天内收不到男孩回信，就会再发一封信催促男孩来取东西！</p><p>男孩自发出第二封信开始，限定两天内没有再次收到女孩的信就认为，女孩收到了自己的第二封信；若两天内再次收到女孩的来信，就认为自己的第二封信女孩没收到，需要再写一封信，再等两天…..</p><p>倘若双方信都能正常收到，最少只用四封信就能彻底分手！这就是“四次挥手”。</p></blockquote><blockquote><p>上面的解释应该很清楚解释了为什么是四次挥手</p><p><strong>这里强调一下TIME-WAIT的概念</strong></p><p>因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。</p><p><strong>什么是MSL？</strong></p><p>MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。 关于MSL的大小，RFC<br>793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，<br>以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，并且这个数值是硬编码在内核中的，<br>也就是说除非你重新编译内核，否则没法修改它：</p><p><strong>为什么客户端在TIME-WAIT阶段要等2MSL?</strong></p><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p><p><strong>如果没有time_wait会怎么样？</strong><br> 我们举一个比较简单的例子：假设服务端发送了断开请求的包，（假设没有TIME_WAIT），客户端收到后立马就回复了确认包，连接就关闭了，但是服务器这边其实还有一个数据在路上，到了之后会发现客户端已经关闭了，一脸懵逼的收到了一个RST包，然后也关闭了连接，这样就导致了数据包的丢失。</p></blockquote><h5 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h5><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><blockquote><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方。首先接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>定义流量窗口为接收缓存剩余的空间。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p></blockquote><h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h6><blockquote><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p></blockquote><p>流量控制之滑动窗口机制</p><blockquote><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728230255.png" srcset="/img/loading.gif" alt="image-20200728230255200"></p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上，是不是很随便，大家记住他很随便就可以了</p><h4 id="TCP与UDP区别及应用"><a href="#TCP与UDP区别及应用" class="headerlink" title="TCP与UDP区别及应用"></a>TCP与UDP区别及应用</h4><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">传输效率低</td><td align="left">传输效率高</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口</td><td align="left">无</td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始、拥塞避免、快重传、快恢复</td><td align="left">无</td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场合</td><td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td><td align="left">对效率要求高，对准确性要求低</td></tr></tbody></table><p><img src="https://img2.jimu98.cn/blog/20200728221157.png" srcset="/img/loading.gif" alt="image-20200728221157748"></p><h3 id="IP解释"><a href="#IP解释" class="headerlink" title="IP解释"></a>IP解释</h3><p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”</strong>，它们携带的货物就是像HTTP，FTP这样的协议等。</p><p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p><h3 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h3><blockquote><p>首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，</p><p>如果有，就直接将数据包发送到这个MAC地址；<br>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</p><p>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。</p><p>如果不相同就忽略此数据包；<br>如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；</p><p>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></blockquote><h3 id="常见的路由选择协议，以及它们的区别"><a href="#常见的路由选择协议，以及它们的区别" class="headerlink" title="常见的路由选择协议，以及它们的区别"></a>常见的路由选择协议，以及它们的区别</h3><p><strong>RIP协议</strong>（路由信息协议）：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong>（开放最短路径优先）：底层是迪杰斯特拉算法，它选择路由的度量标准是带宽，延迟。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>明日再更。。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO友链随机排序</title>
    <link href="/2020/07/28/other/HEXO%E5%8F%8B%E9%93%BE%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/28/other/HEXO%E5%8F%8B%E9%93%BE%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><blockquote><p>最近做博客做的很有乐趣，到处找人换友链</p><p>然后我就发现排在前面和排在后面点击效果比较好</p><p>这对排在中间的朋友们极其不公平。</p><p>我就想搞个随机友链</p></blockquote><h1 id="找出目录"><a href="#找出目录" class="headerlink" title="找出目录"></a>找出目录</h1><blockquote><p>首先我们思考一下hexo原理，他是把你的配置文件还有静态资源通过各种类似脚本的方式生成静态页面</p><p>那么就要去找到友链所对应的脚本或者资源</p></blockquote><p>首先打开主题文件夹，友链无非就那几个关键字 link，links，friend，反正看到类似的就可以</p><p>我的是在 <code>layout/links.ejs文件下面</code></p><h2 id="原来的代码"><a href="#原来的代码" class="headerlink" title="原来的代码"></a>原来的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alpha%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><p>看到这几个for循环，感觉亲切了许多是吧。</p><p>theme.links.items应该就是存放友链的数组了</p><blockquote><p>继续思考</p></blockquote><blockquote><p>hexo是生成静态页面的，我们打开看一下生成的public文件夹，很明显，每一条数据都直接固定写成了html</p><p>那说明这里只是拼接html的脚本</p><p>我有两种想法</p><p>通过js操作dom来修改html数据（太过于繁琐，放弃）</p><p>直接在生成前，把数组打乱（so easy，就他了）</p><p>大家看上面的&lt;%  %&gt;了吗  很明显，这里是动态获取数据的地方</p><p>那我们就开始写了</p><p>打乱数组：</p><p>其实我们可以使用js的sort，然后给他一个随机对比</p><p>这样</p><p>function randomsort(a, b) {<br> return Math.random()&gt;.5 ? -1 : 1;<br>}<br>theme.links.items.sort(randomsort);</p><p>//这是一种最简单的方法，但是你可想一下  前面的在前面的概率比较大，后面的在后面的概率比较大，对不对</p><p>（比如先给你加友链的小伙伴，很大的改了可以在前面对不对）</p><p>//当然，我们还是的采用更公平的随机算法：随机洗牌算法</p><p>Array.prototype.shuffle = function() {<br>var input = this;<br>    for (var i = input.length-1; i &gt;=0; i–) {<br>        var randomIndex = Math.floor(Math.random()*(i+1));<br>        var itemAtIndex = input[randomIndex];<br>        input[randomIndex] = input[i];<br>        input[i] = itemAtIndex;<br>    }<br>    return input;<br>}<br>theme.links.items.shuffle();</p></blockquote><h2 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><blockquote><p>好像这个主题友链没带加评论，也没有自我介绍</p><p>那让想要添加我的小伙伴操作起来多么繁琐，找到代码  加上去</p></blockquote><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;本站友情链接顺序随机&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;div class&#x3D;&quot;content-tab-content  &quot; data-tab-index&#x3D;&quot;2&quot;&gt;名称：积木&lt;br&gt;网址：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&lt;&#x2F;a&gt;&lt;br&gt;头像：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&lt;&#x2F;a&gt;&lt;br&gt;描述：积木-互联网的一只小菜鸡。&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;row links&quot;&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;              &lt;div class&#x3D;&quot;comments&quot; id&#x3D;&quot;comments&quot;&gt;                &lt;% var type &#x3D; &#39;_partial&#x2F;comments&#x2F;&#39; + theme.post.comments.type %&gt;                &lt;%- partial(type) %&gt;              &lt;&#x2F;div&gt;</code></pre><blockquote><p>当然这种随机，每次更新文章从新上传的时候，他会随机生成。</p><p>但是有小伙伴需要刷新一次页面生成一次，</p><p>那这种想法很明显，html代码写死了</p><p>所以你要么写js代码，每次动态修改html</p><p>要么直接把友链数据写到js里面渲染</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>随机排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】Object的概念与区别</title>
    <link href="/2020/07/27/xiangmu/Object%E5%88%92%E5%88%86/"/>
    <url>/2020/07/27/xiangmu/Object%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】Object的概念与区别"><a href="#【项目笔记】Object的概念与区别" class="headerlink" title="【项目笔记】Object的概念与区别"></a>【项目笔记】Object的概念与区别</h1><blockquote><p>首先来一张图，简单看一下</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200727194511.png" srcset="/img/loading.gif" alt="image-20200727194312707"></p><blockquote><p>网上这类帖子特别乱，比如有解释VO、DTO区别的，还有什么DO，PO，TO区别的</p><p>有好处也有坏处吧，好处在于准确对比。坏处可能会更加迷糊</p><p>于是我自己把大佬们文章整理一下，如果哪里不对，大家一定要留言告诉我</p></blockquote><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>最常用实体类，基本和数据表一一对应，一个实体一张表。</p><h3 id="POJO（Plain-Ordinary-Java-Object）："><a href="#POJO（Plain-Ordinary-Java-Object）：" class="headerlink" title="POJO（Plain Ordinary Java Object）："></a>POJO（Plain Ordinary Java Object）：</h3><p>表示一个简单的Java对象,实际就是普通JavaBeans,是为了避免和EJB混淆所创造的简称，下面要说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。</p><blockquote><p>有部分人写代码经常用pojo来代替entity，至于哪个更规范，我也不知道，只是现在经常使用entity</p></blockquote><h3 id="PO（Persistent-Object）："><a href="#PO（Persistent-Object）：" class="headerlink" title="PO（Persistent Object）："></a>PO（Persistent Object）：</h3><p>持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><blockquote><p>人话：我们正常写得entity，一个实体就是一个PO</p></blockquote><h3 id="VO（View-Object）："><a href="#VO（View-Object）：" class="headerlink" title="VO（View Object）："></a>VO（View Object）：</h3><p>视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p><blockquote><p>用来承载前端交互数据，比如前端需要的数据来自三个数据库，那么我们就可以封装出一个vo实体，包含这三个表中某些字段。然后返回给前端</p></blockquote><h3 id="DO（Domain-Object）："><a href="#DO（Domain-Object）：" class="headerlink" title="DO（Domain Object）："></a>DO（Domain Object）：</h3><p>领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><blockquote><p>我查了很多的资料，基本别的很详细解释，而这个只有这一句话，甚至很多人都说可能不存在这个概念。我的理解他可能就像java中的抽象这个概念。</p><p>比如  人  可是我们项目中哪里需要传递这么一个抽象的类呢，比如我们可以传递一个po 人的信息，或者传递一个vo，人的行为和他的好基友们。所以这个可能只是停留在概念上面</p></blockquote><h3 id="BO（business-Object）："><a href="#BO（business-Object）：" class="headerlink" title="BO（business Object）："></a>BO（business Object）：</h3><p>业务对象，封装对象、复杂对象 ，里面可能包含多个类；</p><blockquote><p>BO 通常位于业务层，要区别于直接对外提供服务的服务层：</p></blockquote><h3 id="TO（Transfer-Objerct）："><a href="#TO（Transfer-Objerct）：" class="headerlink" title="TO（Transfer Objerct）："></a>TO（Transfer Objerct）：</h3><p>数据传输对象，不同应用程序之间传输的对象</p><blockquote><p>他和DTO作用相似，用于微服务间。</p></blockquote><h3 id="DTO（Data-Transfer-Object）："><a href="#DTO（Data-Transfer-Object）：" class="headerlink" title="DTO（Data Transfer Object）："></a>DTO（Data Transfer Object）：</h3><p>数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</p><blockquote><p>这个主要作用是在微服务与微服务之间相互调用时候传输的数据对象。</p></blockquote><h3 id="DAO（Data-Access-Object）"><a href="#DAO（Data-Access-Object）" class="headerlink" title="DAO（Data Access Object）"></a>DAO（Data Access Object）</h3><p>用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。</p><blockquote><p>用来访问数据库的对象，我们经常写数据库语句进行操作数据库，实际就是编写DAO</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object</tag>
      
      <tag>POJO</tag>
      
      <tag>DTO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 二叉树的最近公共祖先</title>
    <link href="/2020/07/27/jianzhi-offer/68%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/07/27/jianzhi-offer/68%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 1.</span>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 3.</span>        <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 4.</span>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 2. if(left != null and right != null)</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的最近公共祖先</title>
    <link href="/2020/07/27/jianzhi-offer/68%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/07/27/jianzhi-offer/68%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】构建乘积数组</title>
    <link href="/2020/07/27/jianzhi-offer/66.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <url>/2020/07/27/jianzhi-offer/66.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p>示例:</p><p>输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]</p><p>提示：</p><p>所有元素乘积之和不会溢出 32 位整数<br>a.length &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;        <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            tmp *= a[i + <span class="hljs-number">1</span>];            b[i] *= tmp;        &#125;        <span class="hljs-keyword">return</span> b;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把字符串转换成整数</title>
    <link href="/2020/07/27/jianzhi-offer/67.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <url>/2020/07/27/jianzhi-offer/67.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] c = str.trim().toCharArray();        <span class="hljs-keyword">if</span>(c.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>) sign = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] != <span class="hljs-string">'+'</span>) i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; c.length; j++) &#123;            <span class="hljs-keyword">if</span>(c[j] &lt; <span class="hljs-string">'0'</span> || c[j] &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">'7'</span>) <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;            res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">'0'</span>);        &#125;        <span class="hljs-keyword">return</span> sign * res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】不用加减乘除做加法</title>
    <link href="/2020/07/27/jianzhi-offer/65.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <url>/2020/07/27/jianzhi-offer/65.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p>示例:</p><p>输入: a = 1, b = 1<br>输出: 2</p><p>提示：</p><p>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span>            <span class="hljs-keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span>            a ^= b; <span class="hljs-comment">// a = 非进位和</span>            b = c; <span class="hljs-comment">// b = 进位</span>        &#125;        <span class="hljs-keyword">return</span> a;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】求1+2+…+n</title>
    <link href="/2020/07/27/jianzhi-offer/64.%20%E6%B1%821+2+%E2%80%A6+n/"/>
    <url>/2020/07/27/jianzhi-offer/64.%20%E6%B1%821+2+%E2%80%A6+n/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例 1：</p><p>输入: n = 3<br>输出: 6<br>示例 2：</p><p>输入: n = 9<br>输出: 45</p><p>限制：</p><p>1 &lt;= n &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>什么都不让用，那就递归</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    n += sumNums(n - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> n;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】股票的最大利润</title>
    <link href="/2020/07/27/jianzhi-offer/63.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2020/07/27/jianzhi-offer/63.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price : prices) &#123;            cost = Math.min(cost, price);            profit = Math.max(profit, price - cost);        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】圆圈中最后剩下的数字</title>
    <link href="/2020/07/27/jianzhi-offer/62.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/27/jianzhi-offer/62.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><p>输入: n = 5, m = 3<br>输出: 3<br>示例 2：</p><p>输入: n = 10, m = 17<br>输出: 2</p><p>限制：</p><p>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】扑克牌中的顺子</title>
    <link href="/2020/07/27/jianzhi-offer/61.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <url>/2020/07/27/jianzhi-offer/61.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p>示例 1:</p><p>输入: [1,2,3,4,5]<br>输出: True</p><p>示例 2:</p><p>输入: [0,0,1,2,5]<br>输出: True</p><p>限制：</p><p>数组长度为 5 </p><p>数组的数取值为 [0, 13] .</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> joker = <span class="hljs-number">0</span>;        Arrays.sort(nums); <span class="hljs-comment">// 数组排序</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++; <span class="hljs-comment">// 统计大小王数量</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 若有重复，提前返回 false</span>        &#125;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 59 - II. 队列的最大值</title>
    <link href="/2020/07/27/jianzhi-offer/59%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2020/07/27/jianzhi-offer/59%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue;    LinkedList&lt;Integer&gt; max;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        max = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-comment">//LinkedList是双端链表</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> max.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:max.getFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue.add(value);        <span class="hljs-keyword">while</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;max.getLast()&lt;value)&#123;<span class="hljs-comment">//注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。</span>            max.removeLast();        &#125;        max.add(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;queue.peek().equals(max.getFirst()))<span class="hljs-comment">//Integer类型的值的比较不能直接使用==</span>            max.removeFirst();        <span class="hljs-keyword">return</span> queue.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:queue.poll();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment">     * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment">     * int param_1 = obj.max_value();</span><span class="hljs-comment">     * obj.push_back(value);</span><span class="hljs-comment">     * int param_3 = obj.pop_front();</span><span class="hljs-comment">     */</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 I. 滑动窗口的最大值</title>
    <link href="/2020/07/27/jianzhi-offer/59%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2020/07/27/jianzhi-offer/59%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><blockquote><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span> - k; j &lt; nums.length; i++, j++) &#123;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>])                deque.removeFirst(); <span class="hljs-comment">// 删除 deque 中对应的 nums[i-1]</span>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])                deque.removeLast(); <span class="hljs-comment">// 保持 deque 递减</span>            deque.addLast(nums[j]);            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)                res[i] = deque.peekFirst();  <span class="hljs-comment">// 记录窗口最大值</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】左旋转字符串</title>
    <link href="/2020/07/27/jianzhi-offer/58%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/27/jianzhi-offer/58%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：</p><p>1 &lt;= k &lt; s.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】翻转单词顺序</title>
    <link href="/2020/07/25/jianzhi-offer/58%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/07/25/jianzhi-offer/58%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：</p><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span>        <span class="hljs-keyword">int</span> j = s.length() - <span class="hljs-number">1</span>, i = j;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 搜索首个空格</span>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 添加单词</span>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span>    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        String[] strs = s.trim().split(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 删除首尾空格，分割字符串</span>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒序遍历单词列表</span>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">""</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 遇到空单词则跳过</span>            res.append(strs[i] + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 将单词拼接至 StringBuilder</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串，删除尾部空格，并返回</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的连续正数序列</title>
    <link href="/2020/07/25/jianzhi-offer/57%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/25/jianzhi-offer/57%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;= target &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的左边界</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的右边界</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口中数字的和</span>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (i &lt;= target / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (sum &lt; target) &#123;            <span class="hljs-comment">// 右边界向右移动</span>            sum += j;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 记录结果</span>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++) &#123;                arr[k-i] = k;            &#125;            res.add(arr);            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的两个数字</title>
    <link href="/2020/07/25/jianzhi-offer/57.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/25/jianzhi-offer/57.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p><p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">int</span> s = nums[i] + nums[j];            <span class="hljs-keyword">if</span>(s &lt; target) i++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; target) j--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; nums[i], nums[j] &#125;;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】56 - II. 数组中数字出现的次数 II</title>
    <link href="/2020/07/25/jianzhi-offer/56%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/"/>
    <url>/2020/07/25/jianzhi-offer/56%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>示例 1：</p><p>输入：nums = [3,4,3,3]<br>输出：4<br>示例 2：</p><p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">大佬题解</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c : nums) &#123;        b = b ^ c &amp; ~ a;        a = a ^ c &amp; ~ b;    &#125;    <span class="hljs-keyword">return</span> b;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 数组中数字出现的次数</title>
    <link href="/2020/07/25/jianzhi-offer/56%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2020/07/25/jianzhi-offer/56%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：</p><p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p><p>限制：</p><p>2 &lt;= nums.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            x^=s;        &#125;        x&amp;=-x;        <span class="hljs-keyword">int</span> x1=<span class="hljs-number">0</span>,x2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            <span class="hljs-keyword">if</span>((s&amp;x) ==<span class="hljs-number">0</span>) x1^=s;            <span class="hljs-keyword">else</span> x2^=s;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x1,x2&#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】平衡二叉树</title>
    <link href="/2020/07/25/jianzhi-offer/55%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/25/jianzhi-offer/55%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>      1     / \    2   2   / \  3   3 / \4   4</code></pre><p>返回 false 。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dg(root)!=-<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dg</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=dg(root.left);        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right=dg(root.right);        <span class="hljs-keyword">if</span>(right==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> Math.abs(left-right)&lt;<span class="hljs-number">2</span>?Math.max(left,right)+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】55 - I. 二叉树的深度</title>
    <link href="/2020/07/25/jianzhi-offer/55%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <url>/2020/07/25/jianzhi-offer/55%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><p>提示：</p><p>节点总数 &lt;= 10000</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) tmp.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) tmp.add(node.right);            &#125;            queue = tmp;            res++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/2020/07/25/jianzhi-offer/54.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/25/jianzhi-offer/54.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4<br>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p><p>限制：</p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>本文解法基于此性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p><p>根据以上性质，易得二叉搜索树的 <strong>中序遍历倒序</strong> 为 <strong>递减序列</strong> 。</p><p>因此，求 “二叉搜索树第 <em>k</em> 大的节点” 可转化为求 “此树的中序遍历倒序的第 <em>k</em> 个节点”。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res, k;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.k = k;        dfs(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(--k == <span class="hljs-number">0</span>) res = root.val;        dfs(root.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 0～n-1中缺失的数字</title>
    <link href="/2020/07/25/jianzhi-offer/53%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/25/jianzhi-offer/53%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例 1:</p><p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/2020/07/25/jianzhi-offer/53%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/"/>
    <url>/2020/07/25/jianzhi-offer/53%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(nums, target) - helper(nums, target - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] &lt;= tar) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】两个链表的第一个公共节点</title>
    <link href="/2020/07/25/jianzhi-offer/52.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/25/jianzhi-offer/52.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" alt="img"></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="/img/loading.gif" alt="img"></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>方法1，使用双指针</p><p>一个从A开始   结束之后指向B</p><p>一个从B开始 结束之后指向A</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;    <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    ListNode L = headA;    ListNode R = headB;    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-comment">//当一个节点达到一个链表的尾部，则从另一个链表继续，同时count++</span>    <span class="hljs-keyword">while</span> (L != R) &#123;        L = L.next;        R = R.next;        <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span>) &#123;            L = headB;            count ++;        &#125;        <span class="hljs-keyword">if</span> (R == <span class="hljs-keyword">null</span>) &#123;            R = headA;            count++;        &#125;        <span class="hljs-keyword">if</span> (count &gt;<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> L;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2020/07/24/xiangmu/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/24/xiangmu/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】跨域问题"><a href="#【项目笔记】跨域问题" class="headerlink" title="【项目笔记】跨域问题"></a>【项目笔记】跨域问题</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是 浏览器对javascript施加的安全限制。 • 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p><p><img src="https://img2.jimu98.cn/blog/20200724001043.png" srcset="/img/loading.gif" alt="image-20200724001043268"></p><h2 id="跨域流程"><a href="#跨域流程" class="headerlink" title="跨域流程"></a>跨域流程</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">具体点这里</a></p><p>看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>巴拉巴拉，这些不是重点，如果大家想看更多，强烈建议去看阮一峰老师的博客</p><p>那么这里着重说一下，非简单请求。</p><p>非简单请求，在请求前，需要发送<code>预检请求</code></p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><h2 id="跨域解决办法"><a href="#跨域解决办法" class="headerlink" title="跨域解决办法"></a>跨域解决办法</h2><h3 id="1-使用niinx部署为同一域"><a href="#1-使用niinx部署为同一域" class="headerlink" title="1.使用niinx部署为同一域"></a>1.使用niinx部署为同一域</h3><p><img src="https://img2.jimu98.cn/blog/20200724001945.png" srcset="/img/loading.gif" alt="image-20200724001945071"></p><h3 id="2-配置当次请求允许跨域"><a href="#2-配置当次请求允许跨域" class="headerlink" title="2.配置当次请求允许跨域"></a>2.配置当次请求允许跨域</h3><pre><code class="hljs mathematica"><span class="hljs-number">1</span>、添加响应头• Access-<span class="hljs-keyword">Control</span>-Allow-Origin：支持哪些来源的请求跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Methods：支持哪些方法跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含cookie• Access-<span class="hljs-keyword">Control</span>-Expose-Headers：跨域请求暴露的字段• CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到<span class="hljs-number">6</span>个基本字段：Cache-<span class="hljs-keyword">Control</span>、Content-<span class="hljs-keyword">Language</span>、Content-Type、Expires、<span class="hljs-keyword">Last</span>-Modified、Pragma。如果想拿到其他字段，就必须在Access-<span class="hljs-keyword">Control</span>-Expose-Headers里面指定。• Access-<span class="hljs-keyword">Control</span>-<span class="hljs-keyword">Max</span>-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</code></pre><blockquote></blockquote><h3 id="3…"><a href="#3…" class="headerlink" title="3….."></a>3…..</h3><p>办法相当多，合理使用</p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>箭头函数</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三级分类：递归树形结构数据</title>
    <link href="/2020/07/23/xiangmu/%E4%B8%89%E7%BA%A7%E5%88%86%E7%B1%BB%EF%BC%9A%E9%80%92%E5%BD%92%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/07/23/xiangmu/%E4%B8%89%E7%BA%A7%E5%88%86%E7%B1%BB%EF%BC%9A%E9%80%92%E5%BD%92%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】三级分类：递归树形结构数据"><a href="#【项目笔记】三级分类：递归树形结构数据" class="headerlink" title="【项目笔记】三级分类：递归树形结构数据"></a>【项目笔记】三级分类：递归树形结构数据</h1><blockquote><p>注意要熟悉 stream 写法</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1.查出所有分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter((categoryEntity) -&gt;                                                                categoryEntity.getParentCid() == <span class="hljs-number">0</span>                                                               ).map((menu) -&gt; &#123;        menu.setChildren(getChildrens(menu, entities));        <span class="hljs-keyword">return</span> menu;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-comment">//2.组装成父子树形结构</span>    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">//递归查找所有菜单的子菜单</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; &#123;        <span class="hljs-keyword">return</span> categoryEntity.getParentCid().equals(root.getCatId());    &#125;).map(categoryEntity -&gt; &#123;        <span class="hljs-comment">//1.找到子菜单</span>        categoryEntity.setChildren(getChildrens(categoryEntity, all));        <span class="hljs-keyword">return</span> categoryEntity;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-comment">//2.菜单的排序</span>        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-keyword">return</span> children;&#125;<span class="hljs-comment">//for循环拼接</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.查询出所有的分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 2.组装成父子的树形结构</span>    List&lt;CategoryEntity&gt; level1Menus = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 找到所有的一级分类</span>    <span class="hljs-keyword">for</span> (CategoryEntity entity : entities) &#123;        <span class="hljs-keyword">if</span> (entity.getParentCid() == <span class="hljs-number">0</span>) &#123;            level1Menus.add(entity);        &#125;    &#125;    <span class="hljs-keyword">for</span> (CategoryEntity level1Menu : level1Menus) &#123;        level1Menu.setChildren(getChildrens(level1Menu, entities));    &#125;    <span class="hljs-comment">//排序</span>    level1Menus.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * 递归查找所有的下级分类</span><span class="hljs-comment">     * 在这一级别的分类中找下级分类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 当前级别的分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> all  全部分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下一级分类</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (CategoryEntity a : all) &#123;        <span class="hljs-keyword">if</span> (a.getParentCid().equals(root.getCatId())) &#123;            a.setChildren(getChildrens(a, all));            children.add(a);        &#125;    &#125;    children.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> children;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>箭头函数</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】VUE复习</title>
    <link href="/2020/07/23/xiangmu/Vue%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/07/23/xiangmu/Vue%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】VUE复习"><a href="#【项目笔记】VUE复习" class="headerlink" title="【项目笔记】VUE复习"></a>【项目笔记】VUE复习</h1><h2 id="MVVM思想"><a href="#MVVM思想" class="headerlink" title="MVVM思想"></a>MVVM思想</h2><p>MVVM的全名是Model-View-ViewModel，它的基本思路就是这样：</p><p><img src="https://pic3.zhimg.com/80/1d9336019baa5cabdf0e5e30b3effffb_hd.jpg" srcset="/img/loading.gif" alt="image"></p><p>M：即Model，模型，包括数据和一些基本操作</p><p>V：即View，试图，页面渲染结果</p><p>VM：即View-Model，模型与视图间的双向操作</p><p><img src="https://pic4.zhimg.com/80/edd0080fb145315fbc96164c219fee7e_hd.jpg" srcset="/img/loading.gif" alt="image"></p><h2 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h2><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官网链接</a></p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;num&quot;&gt;    &lt;button v-on:click&#x3D;&quot;num++&quot;&gt;点赞&lt;&#x2F;button&gt;    &lt;button v-on:click&#x3D;&quot;cancle&quot;&gt;取消&lt;&#x2F;button&gt;    &lt;h1&gt; &#123;&#123;name&#125;&#125; ,非常帅，有&#123;&#123;num&#125;&#125;个人为他点赞&#123;&#123;hello()&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;1、vue声明式渲染    let vm &#x3D; new Vue(&#123;        el: &quot;#app&quot;,&#x2F;&#x2F;绑定元素        data: &#123;  &#x2F;&#x2F;封装数据            name: &quot;张三&quot;,            num: 1        &#125;,        methods:&#123;  &#x2F;&#x2F;封装方法            cancle()&#123;                this.num -- ;            &#125;,            hello()&#123;                return &quot;1&quot;            &#125;        &#125;    &#125;);    &#x2F;&#x2F;2、双向绑定,模型变化，视图变化。反之亦然。    &#x2F;&#x2F;3、事件处理    &#x2F;&#x2F;v-xx：指令    &#x2F;&#x2F;1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的    &#x2F;&#x2F;2、指令来简化对dom的一些操作。    &#x2F;&#x2F;3、声明方法来做更复杂的操作。methods里面可以封装方法。&lt;&#x2F;script&gt;</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-text-v-html"><a href="#v-text-v-html" class="headerlink" title="v-text=   v-html="></a>v-text=   v-html=</h3><pre><code class="hljs js">&lt;span v-html=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;br/</span>&gt;&lt;span v-text=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">data:&#123;</span><span class="hljs-regexp">    msg:"&lt;h1&gt;Hello&lt;/</span>h1&gt;<span class="hljs-string">",</span><span class="hljs-string">    link:"</span>http:<span class="hljs-comment">//www.baidu.com"</span>&#125;,</code></pre><h3 id="v-bind：-给任意属性绑定值-或者前面加"><a href="#v-bind：-给任意属性绑定值-或者前面加" class="headerlink" title="v-bind： 给任意属性绑定值  或者前面加 :"></a>v-bind： 给任意属性绑定值  或者前面加 :</h3><pre><code class="hljs js">&lt;a :href=<span class="hljs-string">"link"</span>&gt;gogogo&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- class,style  &#123;class名：加上？&#125;--&gt;</span><span class="hljs-regexp">    &lt;span v-bind:class="&#123;active:isActive,'text-danger':hasError&#125;"</span><span class="hljs-regexp">    :style="&#123;color: color1,fontSize: size&#125;"&gt;你好&lt;/</span>span&gt;data:&#123;    link: <span class="hljs-string">"http://www.baidu.com"</span>,isActive:<span class="hljs-literal">true</span>,hasError:<span class="hljs-literal">true</span>,color1:<span class="hljs-string">'red'</span>,size:<span class="hljs-string">'36px'</span>&#125;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model="></a>v-model=</h3><blockquote><p>在未来开发中，使用这个较多</p></blockquote><pre><code class="hljs js">精通的语言：    &lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Java"</span>&gt; java&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"PHP"</span>&gt; PHP&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Python"</span>&gt; Python&lt;br/&gt;选中了 &#123;&#123;language.join(<span class="hljs-string">","</span>)&#125;&#125;data:&#123;    language: []&#125;</code></pre><h3 id="v-on：-绑定事件-或者直接写"><a href="#v-on：-绑定事件-或者直接写" class="headerlink" title="v-on： 绑定事件 或者直接写@"></a>v-on： 绑定事件 或者直接写@</h3><pre><code class="hljs js">&lt;!--事件中直接写js片段--&gt;    &lt;button v-on:click=<span class="hljs-string">"num++"</span>&gt;点赞&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;</span><span class="hljs-regexp">        &lt;button @click="cancle"&gt;取消&lt;/</span>button&gt;&lt;!--  --&gt;        &lt;h1&gt;有&#123;&#123;num&#125;&#125;个赞&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 事件修饰符 --&gt;</span><span class="hljs-regexp">&lt;div style="border: 1px solid red;padding: 20px;" v-on:click.once="hello"&gt;</span><span class="hljs-regexp">                大div</span><span class="hljs-regexp">&lt;div style="border: 1px solid blue;padding: 20px;" @click.stop="hello"&gt;</span><span class="hljs-regexp">    小div &lt;br /</span>&gt;    &lt;a href=<span class="hljs-string">"http://www.baidu.com"</span> @click.prevent.stop=<span class="hljs-string">"hello"</span>&gt;去百度&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 按键修饰符： --&gt;</span><span class="hljs-regexp">        &lt;input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10"&gt;&lt;br /</span>&gt;            提示：&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;script src="../</span>node_modules/vue/dist/vue.js<span class="hljs-string">"&gt;&lt;/script&gt;</span><span class="hljs-string"></span><span class="hljs-string">&lt;script&gt;</span><span class="hljs-string">        new Vue(&#123;</span>        el:"#app",        data:&#123;            num: <span class="hljs-number">1</span>        &#125;,        methods:&#123;            cancle()&#123;                <span class="hljs-keyword">this</span>.num--;            &#125;,            hello()&#123;                alert(<span class="hljs-string">"点击了"</span>)            &#125;        &#125;    &#125;)&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>阻止事件</p><blockquote><p>.stop 阻止事件冒泡到父元素<br>.prevent 阻止默认事件发生<br>.capture 使用事件捕获模式<br>.self 只有元素自身触发事件才 执行。(冒泡或捕获的都不执行 )<br>.once 只执行一-次</p></blockquote><p>按键修饰符</p><blockquote><p>.ctrl  =&gt; //Ctrl键</p><p>.enter =&gt; // enter键 </p><p>.tab =&gt; // tab键 </p><p>.delete (捕获“删除”和“退格”按键) =&gt; // 删除键 </p><p>.esc =&gt; // 取消键 .space =&gt; // 空格键 </p><p>.up =&gt; // 上 </p><p>.down =&gt; // 下 </p><p>.left =&gt; // 左 </p><p>.right =&gt; // 右</p></blockquote><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for="></a>v-for=</h3><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;ul&gt;    &lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(user,index) in users"</span> :key=<span class="hljs-string">"user.name"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"user.gender == '女'"</span>&gt;        &lt;!-- <span class="hljs-number">1</span>、显示user信息：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span> --&gt;            当前索引：&#123;&#123;index&#125;&#125; ==&gt; &#123;&#123;user.name&#125;&#125;  ==&gt;   &#123;&#123;user.gender&#125;&#125; ==&gt;&#123;&#123;user.age&#125;&#125; &lt;br&gt;                &lt;!-- <span class="hljs-number">2</span>、获取数组下标：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(item,index) in items"</span> --&gt;                &lt;!-- <span class="hljs-number">3</span>、遍历对象：                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"value in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key) in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key,index) in object"</span>     --&gt;    对象信息：&lt;span v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(v,k,i) in user"</span>&gt;&#123;&#123;k&#125;&#125;==&#123;&#123;v&#125;&#125;==&#123;&#123;i&#125;&#125;；&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;</span><span class="hljs-regexp">    &lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;ul&gt;</span><span class="hljs-regexp">    &lt;li v-for="(num,index) in nums" :key="index"&gt;&lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp">&lt;script&gt;         </span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            users: [&#123; name: '柳岩', gender: '女', age: 21 &#125;,</span><span class="hljs-regexp">                    &#123; name: '张三', gender: '男', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '范冰冰', gender: '女', age: 24 &#125;,</span><span class="hljs-regexp">                    &#123; name: '刘亦菲', gender: '女', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '古力娜扎', gender: '女', age: 25 &#125;],</span><span class="hljs-regexp">            nums: [1,2,3,4,4]</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">    &#125;)</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><blockquote><p>v-else和v-else-if</p></blockquote><pre><code class="hljs js">&lt;!--     v-<span class="hljs-keyword">if</span>，顾名思义，条件判断。当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被渲染。    v-show，当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被显示。 --&gt;&lt;button v-on:click=<span class="hljs-string">"show = !show"</span>&gt;点我呀&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!-- 1、使用v-if显示 --&gt;</span><span class="hljs-regexp">    &lt;h1 v-if="show"&gt;if=看到我....&lt;/</span>h1&gt;&lt;!-- <span class="hljs-number">2</span>、使用v-show显示 --&gt;    &lt;h1 v-show=<span class="hljs-string">"show"</span>&gt;show=看到我&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/</span>button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-if="random&gt;=0.75"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.75</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>=<span class="hljs-string">"random&gt;=0.5"</span>&gt;    看到我啦？！ &amp;gt;= <span class="hljs-number">0.5</span>&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-else-if="random&gt;=0.2"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.2</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>&gt;    看到我啦？！ &amp;lt; <span class="hljs-number">0.2</span>&lt;<span class="hljs-regexp">/h1&gt;</span></code></pre><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><blockquote><p>计算属性 是指一个可以计算的属性（这不是废话吗<del>~</del>）</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//计算属性可以写到computed里面</span>computed: &#123;    totalPrice() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xyjPrice * <span class="hljs-keyword">this</span>.xyjNum + <span class="hljs-keyword">this</span>.shzPrice * <span class="hljs-keyword">this</span>.shzNum    &#125;&#125;,<span class="hljs-comment">//监听器</span>watch: &#123;    xyjNum(newVal, oldVal) &#123;        <span class="hljs-keyword">if</span> (newVal &gt;= <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">"库存超出限制"</span>;            <span class="hljs-keyword">this</span>.xyjNum = <span class="hljs-number">3</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">""</span>;        &#125;    &#125;&#125;,</code></pre><blockquote><p>过滤器</p></blockquote><pre><code class="hljs js">&#123;&#123;user.gender | genderFilter&#125;&#125; ==&gt; &#123;&#123;user.gender | gFilter&#125;&#125;<span class="hljs-comment">//   `|`  表示管道符</span><span class="hljs-comment">//全局过滤器</span>Vue.filter(<span class="hljs-string">"gFilter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"男~~~"</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"女~~~"</span>;    &#125;&#125;)filters: &#123;    <span class="hljs-comment">//// filters 定义局部过滤器，只可以在当前vue实例中使用</span>    genderFilter(val) &#123;        <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"男"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"女"</span>;        &#125;    &#125;&#125;</code></pre><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。<br>但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</p><p>在vue里面，所有的vue实例都是组件</p></blockquote><p><img src="http://www.uml.org.cn/AJAX/images/201905069.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs js"><span class="hljs-comment">//用的时候就直接这么用</span>&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/1、全局声明注册一个组件</span><span class="hljs-regexp">Vue.component("counter", &#123;</span><span class="hljs-regexp">    template: `&lt;button v-on:click="count++"&gt;我被点击了 &#123;&#123;count&#125;&#125; 次&lt;/</span>button&gt;<span class="hljs-string">`,</span><span class="hljs-string">    data() &#123;</span><span class="hljs-string">        return &#123;</span><span class="hljs-string">            count: 1</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;);</span><span class="hljs-string"></span><span class="hljs-string">//2、局部声明一个组件</span><span class="hljs-string">const buttonCounter = &#123;</span><span class="hljs-string">    template: `</span>&lt;button v-on:click=<span class="hljs-string">"count++"</span>&gt;我被点击了 &#123;&#123;count&#125;&#125; 次~~~&lt;<span class="hljs-regexp">/button&gt;`,</span><span class="hljs-regexp">    data() &#123;</span><span class="hljs-regexp">        return &#123;</span><span class="hljs-regexp">            count: 1</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;;</span></code></pre><h2 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">官网地址</a></p><p><img src="https://cn.vuejs.org/images/lifecycle.png" srcset="/img/loading.gif" alt="Vue 实例生命周期"></p><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;span id=<span class="hljs-string">"num"</span>&gt;&#123;&#123;num&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;button @click="num++"&gt;赞！&lt;/</span>button&gt;&lt;h2&gt;&#123;&#123;name&#125;&#125;，有&#123;&#123;num&#125;&#125;个人点赞&lt;<span class="hljs-regexp">/h2&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            name: "张三",</span><span class="hljs-regexp">            num: 100</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        methods: &#123;</span><span class="hljs-regexp">            show() &#123;</span><span class="hljs-regexp">                return this.name;</span><span class="hljs-regexp">            &#125;,</span><span class="hljs-regexp">            add() &#123;</span><span class="hljs-regexp">                this.num++;</span><span class="hljs-regexp">            &#125;</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeCreate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeCreate=============");</span><span class="hljs-regexp">            console.log("数据模型未加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法未加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板未加载：" + document.getElementById("num"));</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        created: function () &#123;</span><span class="hljs-regexp">            console.log("=========created=============");</span><span class="hljs-regexp">            console.log("数据模型已加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法已加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板已加载：" + document.getElementById("num"));</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeMount() &#123;</span><span class="hljs-regexp">            console.log("=========beforeMount=============");</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        mounted() &#123;</span><span class="hljs-regexp">            console.log("=========mounted=============");</span><span class="hljs-regexp">            console.log("html模板已渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeUpdate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeUpdate=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板未更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        updated() &#123;</span><span class="hljs-regexp">            console.log("=========updated=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板已更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;);</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h2 id="vue模块化开发"><a href="#vue模块化开发" class="headerlink" title="vue模块化开发"></a>vue模块化开发</h2><blockquote><p>1、npm install webpack -g<br>全局安装webpack<br>2、npm install -g @vue/cli-init<br>全局安装vue脚手架<br>3、初始化vue项目;<br>vue init webpack appname:  vue 脚手架使用webpack模板初始化一个 appname项目<br>4、启动vue项目;<br>项目的package.json中有scripts, 代表我们能运行的命令<br>npm start = npm run dev:  启动项目</p></blockquote><pre><code class="hljs 1c"><span class="hljs-comment">//文件目录结构</span><span class="hljs-comment">//build  跟打包相关目录</span><span class="hljs-comment">//config  配置信息，一般配置一些端口之类的，然后区分不同的环境</span><span class="hljs-comment">//node_modules   用npm安装的所有项目依赖</span><span class="hljs-comment">//src  编写代码的文件夹</span><span class="hljs-comment">//assets </span><span class="hljs-comment">//components</span><span class="hljs-comment">//router  路由配置</span><span class="hljs-comment">//main.js  主程序</span><span class="hljs-comment">//static  静态资源文件</span><span class="hljs-comment">//.babelrc  语法转义</span><span class="hljs-comment">//package.json  需要的依赖   类似于maven的pom</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>promist</tag>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/2020/07/23/jianzhi-offer/50.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/2020/07/23/jianzhi-offer/50.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例:</p><p>s = “abaccdeff”<br>返回 “b”</p><p>s = “”<br>返回 “ “</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>//方法1</p><ol><li><p>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt; 1&gt;1 ”。</p></li><li><p>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 11 的字符”，并返回。</p></li></ol><p>//方法2</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//方法1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            <span class="hljs-keyword">if</span>(dic.get(c)) <span class="hljs-keyword">return</span> c;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;           <span class="hljs-keyword">if</span>(d.getValue()) <span class="hljs-keyword">return</span> d.getKey();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】丑数</title>
    <link href="/2020/07/23/jianzhi-offer/49.%20%E4%B8%91%E6%95%B0/"/>
    <url>/2020/07/23/jianzhi-offer/49.%20%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>示例:</p><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>1 是丑数。<br>n 不超过1690。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题目如果循环遍历当然可以，但是更好的做法是动态规划</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最长不含重复字符的子字符串</title>
    <link href="/2020/07/23/jianzhi-offer/48.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/23/jianzhi-offer/48.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：</p><p>s.length &lt;= 40000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;            <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取索引 i</span>            dic.put(s.charAt(j), j); <span class="hljs-comment">// 更新哈希表</span>            tmp = tmp &lt; j - i ? tmp + <span class="hljs-number">1</span> : j - i; <span class="hljs-comment">// dp[j - 1] -&gt; dp[j]</span>            res = Math.max(res, tmp); <span class="hljs-comment">// max(dp[j - 1], dp[j])</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】礼物的最大价值</title>
    <link href="/2020/07/23/jianzhi-offer/47.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2020/07/23/jianzhi-offer/47.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 初始化第一行</span>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) <span class="hljs-comment">// 初始化第一列</span>            grid[i][<span class="hljs-number">0</span>] += grid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)                 grid[i][j] += Math.max(grid[i][j - <span class="hljs-number">1</span>], grid[i - <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数字翻译成字符串</title>
    <link href="/2020/07/23/jianzhi-offer/46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/23/jianzhi-offer/46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p>提示：</p><p>0 &lt;= num &lt; 231</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        String str=String.valueOf(num);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length()];        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = (str.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>);    dp[<span class="hljs-number">1</span>] = n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;str.length();i++)&#123;            n = (str.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(i) - <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span>) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[str.length() - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】ES6复习</title>
    <link href="/2020/07/22/xiangmu/ES6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/07/22/xiangmu/ES6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】ES6复习"><a href="#【项目笔记】ES6复习" class="headerlink" title="【项目笔记】ES6复习"></a>【项目笔记】ES6复习</h1><h2 id="ES6介绍"><a href="#ES6介绍" class="headerlink" title="ES6介绍"></a>ES6介绍</h2><p>ECMAScript6.0是JavaScript语言的下一代标准。。。。。。等等介绍。。</p><h2 id="let语法"><a href="#let语法" class="headerlink" title="let语法"></a>let语法</h2><pre><code class="hljs js"><span class="hljs-comment">//var声明的变量往往会越域</span><span class="hljs-comment">//let声明的变量有严格的局部作用域</span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>    &#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">//b is not defined</span><span class="hljs-comment">//var可以声明多次</span><span class="hljs-comment">//let只能声明一次</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">4</span>  <span class="hljs-comment">//报错</span><span class="hljs-comment">//var 会变量提升</span><span class="hljs-comment">//let 不存在变量提升</span><span class="hljs-built_in">console</span>.log(x)  <span class="hljs-comment">//undefined</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><span class="hljs-built_in">console</span>.log(y)  <span class="hljs-comment">//y is not defined</span><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span><span class="hljs-comment">//因此，以后我们经常使用let生成变量</span><span class="hljs-comment">//同时我们也经常使用const声明常量  声明之后就不可以再改变</span></code></pre><h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">//原来</span><span class="hljs-keyword">let</span> a = arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">let</span> b = arr[<span class="hljs-number">1</span>]<span class="hljs-keyword">let</span> c = arr[<span class="hljs-number">2</span>]<span class="hljs-built_in">console</span>.log(a, b, c)<span class="hljs-comment">//现在</span><span class="hljs-keyword">let</span> [x, y, z] = arr<span class="hljs-built_in">console</span>.log(x, y, z)<span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-comment">//原来</span><span class="hljs-comment">// const name = person.name</span><span class="hljs-comment">// const age = person.age</span><span class="hljs-comment">// const language = person.language</span><span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>:abc, age, language &#125; = person<span class="hljs-built_in">console</span>.log(name, age, language)</code></pre><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> str=<span class="hljs-string">`&lt;div&gt;</span><span class="hljs-string">            &lt;span&gt;hello jimu98&lt;/span&gt;</span><span class="hljs-string">        &lt;/div&gt;`</span><span class="hljs-comment">//以前这些内容需要字符串拼接，现在只需要一个反引号</span></code></pre><h3 id="字符串插入变量和表达式"><a href="#字符串插入变量和表达式" class="headerlink" title="字符串插入变量和表达式"></a>字符串插入变量和表达式</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"这是一个函数"</span>&#125;<span class="hljs-keyword">let</span> info =<span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age+<span class="hljs-number">10</span>&#125;</span>了，我想说<span class="hljs-subst">$&#123;fun()&#125;</span>`</span><span class="hljs-built_in">console</span>.log(info)</code></pre><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code class="hljs js"><span class="hljs-comment">//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    b=b || <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>))<span class="hljs-comment">//现在可以写默认值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a,b=<span class="hljs-number">1</span></span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">20</span>))</code></pre><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><pre><code class="hljs js"><span class="hljs-comment">//不定参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">...values</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(values.length)&#125;fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="hljs js"><span class="hljs-comment">//以前声明一个方法</span><span class="hljs-keyword">var</span> print1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(obj)&#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(obj)print(<span class="hljs-string">"Hello"</span>)<span class="hljs-comment">//多个参数</span><span class="hljs-keyword">var</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + bprint(sum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<span class="hljs-comment">//箭头函数+解构</span><span class="hljs-keyword">var</span> hello2 = <span class="hljs-function">(<span class="hljs-params">&#123; name &#125;</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello,"</span> + name)hello2(person)</code></pre><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><h3 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person))<span class="hljs-comment">//["name", "age", "language"]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(person))<span class="hljs-comment">//["jimu98", 21, Array(3)]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(person)) <span class="hljs-comment">//[Array(2), Array(2), Array(2)]</span><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;<span class="hljs-built_in">Object</span>.assign(target, source1, source2)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(target))<span class="hljs-comment">//["a", "b", "c"]</span></code></pre><h3 id="声明对象的简写"><a href="#声明对象的简写" class="headerlink" title="声明对象的简写"></a>声明对象的简写</h3><pre><code class="hljs js"><span class="hljs-comment">//声明对象简写</span><span class="hljs-keyword">const</span> age = <span class="hljs-number">23</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">"jimu98"</span><span class="hljs-comment">//原来</span><span class="hljs-keyword">const</span> person1 = &#123; <span class="hljs-attr">age</span>: age, <span class="hljs-attr">name</span>: name &#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> person2=&#123;age,name&#125;<span class="hljs-built_in">console</span>.log(person2)</code></pre><h3 id="函数的简写"><a href="#函数的简写" class="headerlink" title="函数的简写"></a>函数的简写</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">"jack"</span>,    <span class="hljs-comment">//原来</span>    eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;,    eat2: <span class="hljs-function"><span class="hljs-params">food</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(person.name + <span class="hljs-string">"在吃"</span> + food),<span class="hljs-comment">//这里不能用this</span>    eat3(food)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;&#125;person.eat(<span class="hljs-string">"香蕉"</span>)person.eat2(<span class="hljs-string">"苹果"</span>)person.eat3(<span class="hljs-string">"梨"</span>)</code></pre><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><pre><code class="hljs js"><span class="hljs-comment">// 1、拷贝对象（深拷贝）</span><span class="hljs-keyword">let</span> p1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> someone = &#123; ...p1 &#125;<span class="hljs-built_in">console</span>.log(someone)  <span class="hljs-comment">//&#123;name: "Amy", age: 15&#125;</span><span class="hljs-comment">// 2、合并对象</span><span class="hljs-keyword">let</span> age1 = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> name1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span> &#125;<span class="hljs-keyword">let</span> p2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"zhangsan"</span>&#125;p2 = &#123; ...age1, ...name1 &#125; <span class="hljs-comment">//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值</span><span class="hljs-built_in">console</span>.log(p2)</code></pre><p>map和reduce方法</p><p>//map()接受一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><pre><code class="hljs js"><span class="hljs-comment">//数组中新增了map和reduce方法。</span><span class="hljs-comment">//map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'20'</span>, <span class="hljs-string">'-5'</span>, <span class="hljs-string">'3'</span>];<span class="hljs-comment">//原来</span>arr = arr.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>&#125;);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//现在</span>arr = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//传入回调函数</span><span class="hljs-keyword">let</span> res = arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"上一次处理后"</span> + a)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"当前正在处理的"</span> + b)    <span class="hljs-keyword">return</span> a + b;&#125;)<span class="hljs-built_in">console</span>.log(res)</code></pre><h2 id="promist"><a href="#promist" class="headerlink" title="promist"></a>promist</h2><blockquote><p>这个是用来处理异步</p><p>在之前我们写ajax中，需要一层层嵌套，通过这个就可以使用then关键字</p><p>最后还可以抽取出来公共代码，使得代码更加优雅</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//1、查出当前用户信息</span><span class="hljs-comment">//2、按照当前用户的id查出他的课程</span><span class="hljs-comment">//3、按照当前课程id查出分数</span><span class="hljs-comment">// $.ajax(&#123;</span><span class="hljs-comment">//     url: "mock/user.json",</span><span class="hljs-comment">//     success(data) &#123;</span><span class="hljs-comment">//         console.log("查询用户：", data);</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//             success(data) &#123;</span><span class="hljs-comment">//                 console.log("查询到课程：", data);</span><span class="hljs-comment">//                 $.ajax(&#123;</span><span class="hljs-comment">//                     url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//                     success(data) &#123;</span><span class="hljs-comment">//                         console.log("查询到分数：", data);</span><span class="hljs-comment">//                     &#125;,</span><span class="hljs-comment">//                     error(error) &#123;</span><span class="hljs-comment">//                         console.log("出现异常了：" + error);</span><span class="hljs-comment">//                     &#125;</span><span class="hljs-comment">//                 &#125;);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error(error) &#123;</span><span class="hljs-comment">//                 console.log("出现异常了：" + error);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;,</span><span class="hljs-comment">//     error(error) &#123;</span><span class="hljs-comment">//         console.log("出现异常了：" + error);</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">//1、Promise可以封装异步操作</span><span class="hljs-comment">// let p = new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//     //1、异步操作</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: "mock/user.json",</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询用户成功:", data)</span><span class="hljs-comment">//             resolve(data);</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//             reject(err);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// p.then((obj) =&gt; &#123;</span><span class="hljs-comment">//     return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;obj.id&#125;.json`,</span><span class="hljs-comment">//             success: function (data) &#123;</span><span class="hljs-comment">//                 console.log("查询用户课程成功:", data)</span><span class="hljs-comment">//                 resolve(data);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error: function (err) &#123;</span><span class="hljs-comment">//                 reject(err)</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">// &#125;).then((data) =&gt; &#123;</span><span class="hljs-comment">//     console.log("上一步的结果", data)</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询课程得分成功:", data)</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, data</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        $.ajax(&#123;            url: url,            data: data,            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;                resolve(data);            &#125;,            error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;                reject(err)            &#125;        &#125;)    &#125;);&#125;<span class="hljs-keyword">get</span>("mock/user.json")    .then((data) =&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"用户查询成功~~~:"</span>, data)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(`mock/user_corse_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data) =&gt; &#123;</span><span class="hljs-string">    console.log("课程查询成功~~~:", data)</span><span class="hljs-string">    return get(`</span>mock/corse_score_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data)=&gt;&#123;</span><span class="hljs-string">    console.log("课程成绩查询成功~~~:", data)</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .catch((err)=&gt;&#123;</span><span class="hljs-string">    console.log("出现异常",err)</span><span class="hljs-string">&#125;);</span></code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>如果我们想在写的代码里面调用其他js，就可以采用模块化的方法</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//export  导出</span>varname =<span class="hljs-string">"jack"</span><span class="hljs-keyword">var</span> age=<span class="hljs-number">21</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-keyword">export</span> &#123;name,age,add&#125;<span class="hljs-comment">//import 导入</span><span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">"./hello.js"</span><span class="hljs-keyword">import</span> &#123;name,age,add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./user.js"</span><span class="hljs-comment">//使用</span><span class="hljs-keyword">let</span> res = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(res)</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>ES6</tag>
      
      <tag>promist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/2020/07/22/jianzhi-offer/45.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/45.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><p>提示:</p><p>0 &lt; nums.length &lt;= 100<br>说明:</p><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)             strs[i] = String.valueOf(nums[i]);        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(String s : strs)            res.append(s);        <span class="hljs-keyword">return</span> res.toString();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/2020/07/22/jianzhi-offer/44.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/22/jianzhi-offer/44.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p>示例 1：</p><p>输入：n = 3<br>输出：3<br>示例 2：</p><p>输入：n = 11<br>输出：0</p><p>限制：</p><p>0 &lt;= n &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0.9</span> *Math.pow(<span class="hljs-number">10</span>,i)*i)&#123;            n -= <span class="hljs-number">0.9</span>*Math.pow(<span class="hljs-number">10</span>,i)*i;            i++;        &#125;        <span class="hljs-keyword">int</span> s=(n-<span class="hljs-number">1</span>)/i+(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        String res=Integer.toString(s);        <span class="hljs-keyword">return</span> res.charAt((n-<span class="hljs-number">1</span>)%i)-<span class="hljs-string">'0'</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】1～n整数中1出现的次数</title>
    <link href="/2020/07/22/jianzhi-offer/43.%201%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/43.%201%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>示例 1：</p><p>输入：n = 12<br>输出：5<br>示例 2：</p><p>输入：n = 13<br>输出：6</p><p>限制：</p><p>1 &lt;= n &lt; 2^31</p><p>题解</p><p>根据当前位 curcur 值的不同，分为以下三种情况：</p><p>当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：high×digit</p><blockquote><p>如下图所示，以 n = 2304为例，求 digit = 10（即十位）的 11 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155713.png" srcset="/img/loading.gif" alt="image-20200723155713725"></p><p>当 cur = 1时： 此位 11 的出现次数由高位 high 和低位 low 决定，计算公式为：high×digit+low+1</p><blockquote><p>如下图所示，以 n = 2314 为例，求 digit = 10digit=10 （即十位）的 1出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155726.png" srcset="/img/loading.gif" alt="image-20200723155726661"></p><p>当 cur = 2, 3, …, 9时： 此位 1 的出现次数只由高位 high决定，计算公式为：(high+1)×digit</p><blockquote><p>如下图所示，以 n = 2324 为例，求 digit = 10（即十位）的 1 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155740.png" srcset="/img/loading.gif" alt="image-20200723155740761"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> digit=<span class="hljs-number">1</span>,res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> high=n/<span class="hljs-number">10</span>,low=<span class="hljs-number">0</span>,cur=n%<span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)res+=high*digit;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">1</span>) res+=high*digit+low+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> res+= (high+<span class="hljs-number">1</span>) * digit;            low+=cur*digit;            cur = high%<span class="hljs-number">10</span>;            high/=<span class="hljs-number">10</span>;            digit*=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】连续子数组的最大和</title>
    <link href="/2020/07/22/jianzhi-offer/42.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2020/07/22/jianzhi-offer/42.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>简单dp</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> [] dp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [nums.length];        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max=dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            dp[i]=Math.max(nums[i],nums[i]+dp[i-<span class="hljs-number">1</span>]);            max=Math.max(max,dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;<span class="hljs-comment">//-----------直接用原来数组-------------</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            nums[i]=Math.max(nums[i],nums[i]+nums[i-<span class="hljs-number">1</span>]);            max=Math.max(max,nums[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数据流中的中位数</title>
    <link href="/2020/07/22/jianzhi-offer/41.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/41.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p><p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：</p><p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p><p>限制：</p><p>最多会对 addNum、findMedia进行 50000 次调用。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>建立一个 <strong>小顶堆</strong> <em>A</em> 和 <strong>大顶堆</strong> <em>B</em> ，各保存列表的一半元素</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    Queue&lt;Integer&gt; A,B;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y-x));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;            A.add(num);            B.add(A.poll());        &#125;<span class="hljs-keyword">else</span>&#123;            B.add(num);            A.add(B.poll());        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.size()!=B.size()?A.peek():(A.peek()+B.peek())/<span class="hljs-number">2.0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>小顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数组中出现次数超过一半的数字</title>
    <link href="/2020/07/21/jianzhi-offer/39.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/21/jianzhi-offer/39.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> x=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;                x=nums[i];                y=<span class="hljs-number">1</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(x!=nums[i])&#123;                y--;            &#125;<span class="hljs-keyword">else</span>                y++;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/2020/07/21/jianzhi-offer/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/07/21/jianzhi-offer/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p>限制：</p><p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题直接排序即可，但是还是多写几次快排吧，毕竟太难记了</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span>        <span class="hljs-keyword">return</span> quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] quickSearch(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span>        <span class="hljs-keyword">int</span> j = partition(nums, lo, hi);        <span class="hljs-keyword">if</span> (j == k) &#123;            <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span>        <span class="hljs-keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k): quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);    &#125;    <span class="hljs-comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">int</span> v = nums[lo];        <span class="hljs-keyword">int</span> i = lo, j = hi + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);            <span class="hljs-keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">int</span> t = nums[j];            nums[j] = nums[i];            nums[i] = t;        &#125;        nums[lo] = nums[j];        nums[j] = v;        <span class="hljs-keyword">return</span> j;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】字符串的排列</title>
    <link href="/2020/07/21/jianzhi-offer/38.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/07/21/jianzhi-offer/38.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Set&lt;String&gt; res = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;&#125;;        <span class="hljs-keyword">boolean</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()];        dfs(s,<span class="hljs-string">""</span>,visited);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s,String letter,<span class="hljs-keyword">boolean</span>[] visited)</span></span>&#123;        <span class="hljs-keyword">if</span>(s.length()==letter.length())&#123;            res.add(letter);            <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//为了退出递归</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">char</span> c=s.charAt(i);            <span class="hljs-keyword">if</span>(visited[i])<span class="hljs-keyword">continue</span>;            visited[i]=<span class="hljs-keyword">true</span>;            dfs(s,letter+c,visited);            visited[i]=<span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】序列化二叉树</title>
    <link href="/2020/07/21/jianzhi-offer/37.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/21/jianzhi-offer/37.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]”</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"[]"</span>;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"["</span>);        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>) &#123;                res.append(node.val + <span class="hljs-string">","</span>);                queue.add(node.left);                queue.add(node.right);            &#125;            <span class="hljs-keyword">else</span> res.append(<span class="hljs-string">"null,"</span>);        &#125;        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);        res.append(<span class="hljs-string">"]"</span>);        <span class="hljs-keyword">return</span> res.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">"[]"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        String[] vals = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">","</span>);        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.left);            &#125;            i++;            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.right);            &#125;            i++;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树与双向链表</title>
    <link href="/2020/07/21/jianzhi-offer/36.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/21/jianzhi-offer/36.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p> <img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" srcset="/img/loading.gif" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>直接使用中序遍历可以按顺序遍历，之后定义一个pre节点用来构造链表。</p><p>pre就是已经构造好的链表，cur是要被构造的，所以 cur.left=pre  pre=cur</p><p>但是pre的right也要指向cur</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Node pre,head;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        dfs(root);        head.left=pre;        pre.right=head;                <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span>;        dfs(cur.left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>)pre.right=cur;        <span class="hljs-keyword">else</span> head=cur;        cur.left=pre;        pre=cur;        dfs(cur.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】复杂链表的复制</title>
    <link href="/2020/07/13/jianzhi-offer/35.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2020/07/13/jianzhi-offer/35.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>示例 1：</p><p><img src="https://img2.jimu98.cn/blog/20200723155648.png" srcset="/img/loading.gif" alt="image-20200723155648550"></p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Node cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));            cur=cur.next;        &#125;        cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.get(cur).next=map.get(cur.next);            map.get(cur).random=map.get(cur.random);            cur=cur.next;        &#125;        <span class="hljs-keyword">return</span> map.get(head);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树中和为某一值的路径</title>
    <link href="/2020/07/13/jianzhi-offer/34.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/07/13/jianzhi-offer/34.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \    / \7    2  5   1</code></pre><p>返回:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><p>提示：</p><p>节点总数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;        recur(root, sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        path.add(root.val);        tar -= root.val;        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            res.add(<span class="hljs-keyword">new</span> LinkedList(path));        recur(root.left, tar);        recur(root.right, tar);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的后序遍历序列</title>
    <link href="/2020/07/13/jianzhi-offer/33.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/13/jianzhi-offer/33.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code> 5/ \</code></pre><p>   2   6<br>  / <br> 1   3<br>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><p>提示：</p><p>数组长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> root = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = postorder.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])            root = stack.pop();            stack.add(postorder[i]);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅲ. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) Collections.reverse(tmp);            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅱ. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p><p>[3,9,20,15,7]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            ans.add(node.val);            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++)            res[i] = ans.get(i);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】栈的压入、弹出序列</title>
    <link href="/2020/07/12/jianzhi-offer/31.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/12/jianzhi-offer/31.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p><p>提示：</p><p>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : pushed) &#123;            stack.push(num); <span class="hljs-comment">// num 入栈</span>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; <span class="hljs-comment">// 循环判断与出栈</span>                stack.pop();                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】包含min函数的栈</title>
    <link href="/2020/07/12/jianzhi-offer/30.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2020/07/12/jianzhi-offer/30.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><p>提示：</p><p>各函数的调用总次数不超过 20000 次</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; A, B;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        A.add(x);        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)            B.add(x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))            B.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> B.peek();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】顺时针打印矩阵</title>
    <link href="/2020/07/12/jianzhi-offer/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/07/12/jianzhi-offer/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>限制：</p><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = matrix.length - <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(r + <span class="hljs-number">1</span>) * (b + <span class="hljs-number">1</span>)];        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="hljs-comment">// left to right.</span>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="hljs-comment">// top to bottom.</span>            <span class="hljs-keyword">if</span>(l &gt; --r) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="hljs-comment">// right to left.</span>            <span class="hljs-keyword">if</span>(t &gt; --b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="hljs-comment">// bottom to top.</span>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】对称的二叉树</title>
    <link href="/2020/07/12/jianzhi-offer/28.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/12/jianzhi-offer/28.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>  1 / \2   2 \   \ 3    3</code></pre><p>示例 1：</p><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : recur(root.left, root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树的镜像</title>
    <link href="/2020/07/12/jianzhi-offer/27.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2020/07/12/jianzhi-offer/27.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>    4   /  \  2    7 / \   / \1   3 6   9</code></pre><p>镜像输出：</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>示例 1：</p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode tmp = root.left;        root.left = mirrorTree(root.right);        root.right = mirrorTree(tmp);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】树的子结构</title>
    <link href="/2020/07/12/jianzhi-offer/26.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2020/07/12/jianzhi-offer/26.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>示例 1：</p><p>输入：A = [1,2,3], B = [3,1]<br>输出：false<br>示例 2：</p><p>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true<br>限制：</p><p>0 &lt;= 节点个数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">return</span> (A != <span class="hljs-keyword">null</span> &amp;&amp; B != <span class="hljs-keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】合并两个排序的链表</title>
    <link href="/2020/07/12/jianzhi-offer/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/12/jianzhi-offer/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p><p>0 &lt;= 链表长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>为了方便，在做链表题的时候一定要给自己加一个伪头节点</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dum = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), cur = dum;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;                cur.next = l1;                l1 = l1.next;            &#125;            <span class="hljs-keyword">else</span> &#123;                cur.next = l2;                l2 = l2.next;            &#125;            cur = cur.next;        &#125;        cur.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> dum.next;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/07/12/jianzhi-offer/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/12/jianzhi-offer/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">null</span>;ListNode cur = head;ListNode tmp = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            tmp=cur.next;            cur.next=pre;            pre=cur;            cur=tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>反转链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】链表中倒数第 k 个节点</title>
    <link href="/2020/07/12/jianzhi-offer/22.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20k%20%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/12/jianzhi-offer/22.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20k%20%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode former = head, latter = head;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)            former = former.next;        <span class="hljs-keyword">while</span>(former != <span class="hljs-keyword">null</span>) &#123;            former = former.next;            latter = latter.next;        &#125;        <span class="hljs-keyword">return</span> latter;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/07/11/jianzhi-offer/21.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/07/11/jianzhi-offer/21.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>示例：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首尾双指针<br>定义头指针 leftleft ，尾指针 rightright .<br>leftleft 一直往右移，直到它指向的值为偶数<br>rightright 一直往左移， 直到它指向的值为奇数<br>交换 nums[left]nums[left] 和 nums[right]nums[right] .<br>重复上述操作，直到 left == rightleft==right .</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>, tmp;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;            tmp = nums[i];            nums[i] = nums[j];            nums[j] = tmp;        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】表示数值的字符串</title>
    <link href="/2020/07/11/jianzhi-offer/20.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/11/jianzhi-offer/20.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://img2.jimu98.cn/blog/20200723155550.png" srcset="/img/loading.gif" alt="image-20200723155550061"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;        Map[] states = &#123;            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">0</span>); put(<span class="hljs-string">'s'</span>, <span class="hljs-number">1</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;, <span class="hljs-comment">// 0.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;,                           <span class="hljs-comment">// 1.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;, <span class="hljs-comment">// 2.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,              <span class="hljs-comment">// 3.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); &#125;&#125;,                                        <span class="hljs-comment">// 4.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'s'</span>, <span class="hljs-number">6</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                           <span class="hljs-comment">// 5.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                                        <span class="hljs-comment">// 6.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,                           <span class="hljs-comment">// 7.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;                                         <span class="hljs-comment">// 8.</span>        &#125;;        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> t;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) t = <span class="hljs-string">'d'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) t = <span class="hljs-string">'s'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'.'</span> || c == <span class="hljs-string">'e'</span> || c == <span class="hljs-string">'E'</span> || c == <span class="hljs-string">' '</span>) t = c;            <span class="hljs-keyword">else</span> t = <span class="hljs-string">'?'</span>;            <span class="hljs-keyword">if</span>(!states[p].containsKey(t)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            p = (<span class="hljs-keyword">int</span>)states[p].get(t);        &#125;        <span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】删除链表的节点</title>
    <link href="/2020/07/11/jianzhi-offer/18.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/11/jianzhi-offer/18.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head.val==val)<span class="hljs-keyword">return</span> head.next;        ListNode p=head;        ListNode q=head;        head=head.next;        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(head.val==val)&#123;                q.next=head.next;                <span class="hljs-keyword">return</span> p;            &#125;            q=head;            head=head.next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】打印从1到最大的n位数</title>
    <link href="/2020/07/11/jianzhi-offer/17.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <url>/2020/07/11/jianzhi-offer/17.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例 1:</p><p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p>说明：</p><p>用返回一个整数列表来代替打印<br>n 为正整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;        <span class="hljs-keyword">int</span> Size=(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Size];        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>)&#123;            result[i]=i+<span class="hljs-number">1</span>;            i++;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数值的整数次方</title>
    <link href="/2020/07/11/jianzhi-offer/16.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2020/07/11/jianzhi-offer/16.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:</p><p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p><p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> b = n;        <span class="hljs-keyword">double</span> res=<span class="hljs-number">1.0</span>;        <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;            x=<span class="hljs-number">1</span>/x;            b=-b;        &#125;        <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)res*=x;            x*=x;            b&gt;&gt;=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二进制中1的个数</title>
    <link href="/2020/07/11/jianzhi-offer/15.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/07/11/jianzhi-offer/15.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例 1：</p><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是逐位判断</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res += n &amp; <span class="hljs-number">1</span>;            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><blockquote><p>下面看其他大佬们的位运算</p></blockquote><p>n&amp;(n-1)即可将最后一位1置为0</p><p><img src="https://img2.jimu98.cn/blog/20200723155527.png" srcset="/img/loading.gif" alt="image-20200723155527400"></p><p>那么循环置为0   就可以将全部的1统计出来了</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res++;            n &amp;= n - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 剪绳子 II</title>
    <link href="/2020/07/11/jianzhi-offer/14-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/"/>
    <url>/2020/07/11/jianzhi-offer/14-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p>提示：</p><p>2 &lt;= n &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>与剪绳子相比，这个需要手写一个快速幂</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) rem = (rem * x) % p;            x = (x * x) % p;        &#125;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】剪绳子</title>
    <link href="/2020/07/11/jianzhi-offer/14-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2020/07/11/jianzhi-offer/14-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>提示：</p><p>2 &lt;= n &lt;= 58</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>先说结论，绳子尽量切割成多个3，至于为什么，我也不会</p><p>但是，比如四   1和3 明显不如 2和2</p><p>最终结论：<br>最优： 33 。把绳子尽可能切为多个长度为 33 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,2 三种情况。<br>次优： 22 。若最后一段绳子长度为 22 ；则保留，不再拆为 1+11+1 。<br>最差： 11 。若最后一段绳子长度为 11 ；则应把一份 3 + 13+1 替换为 2 + 22+2，因为 2 * 2 &gt; 3 * 1 </p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】机器人的运动范围</title>
    <link href="/2020/07/11/jianzhi-offer/13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2020/07/11/jianzhi-offer/13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><p>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：</p><p>输入：m = 3, n = 1, k = 0<br>输出：1<br>提示：</p><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>注意，这里是不能进入行坐标和列坐标的数位之和大于k的格子。  是“数位之和”</p><p>所以不可以简单的循环，因为有些区域数值可以达到，但是走不到</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155448.png" srcset="/img/loading.gif" alt="image-20200723155447989"></p><p>比如这张图</p><p><img src="https://img2.jimu98.cn/blog/20200723155502.png" srcset="/img/loading.gif" alt="image-20200723155502511"></p><pre><code class="hljs java"><span class="hljs-comment">//dfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> m, n, k;    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.m = m; <span class="hljs-keyword">this</span>.n = n; <span class="hljs-keyword">this</span>.k = k;        <span class="hljs-keyword">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> si, <span class="hljs-keyword">int</span> sj)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        visited[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj) + dfs(i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span>);    &#125;&#125;<span class="hljs-comment">//bfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue= <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt;();        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span>[] x = queue.poll();            <span class="hljs-keyword">int</span> i = x[<span class="hljs-number">0</span>], j = x[<span class="hljs-number">1</span>], si = x[<span class="hljs-number">2</span>], sj = x[<span class="hljs-number">3</span>];            <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">continue</span>;            visited[i][j] = <span class="hljs-keyword">true</span>;            res ++;            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj &#125;);            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span> &#125;);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】矩阵中的路径</title>
    <link href="/2020/07/11/jianzhi-offer/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/07/11/jianzhi-offer/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例 1：</p><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false<br>提示：</p><p>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> []dx=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,dy=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] words = word.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;                <span class="hljs-keyword">if</span>(dfs(board,words,i,j,<span class="hljs-number">0</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][]board,<span class="hljs-keyword">char</span> [] word,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> tmp)</span></span>&#123;        <span class="hljs-keyword">if</span>(word[tmp]!=board[i][j])<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(tmp==word.length-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;            <span class="hljs-keyword">int</span> new_x=i+dx[k],new_y=j+dy[k];            <span class="hljs-keyword">if</span>(new_x&lt;<span class="hljs-number">0</span> || new_x&gt;= board.length || new_y&lt;<span class="hljs-number">0</span> || new_y&gt;= board[<span class="hljs-number">0</span>].length)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">char</span> c=board[i][j];            board[i][j]=<span class="hljs-string">'/'</span>;            <span class="hljs-keyword">if</span>(dfs(board,word,new_x,new_y,tmp+<span class="hljs-number">1</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            board[i][j]=c;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】旋转数组的最小数字</title>
    <link href="/2020/07/10/jianzhi-offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/jianzhi-offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j=numbers.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;j) &#123;            <span class="hljs-keyword">int</span> mid=(i+j)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(numbers[mid]&gt;numbers[j])                i=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid]&lt;numbers[j])                j=mid;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> numbers[i];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>旋转数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】青蛙跳台问题</title>
    <link href="/2020/07/10/jianzhi-offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/10/jianzhi-offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：2<br>示例 2：</p><p>输入：n = 7<br>输出：21<br>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>其实这个题目就是斐波那契数列，但是用到了记忆化</p><p>这么一说  不就有点dp的味道了吗，对，没错。其实算法间没那么清晰的界限。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】斐波那契数列一</title>
    <link href="/2020/07/10/jianzhi-offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2020/07/10/jianzhi-offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：1<br>示例 2：</p><p>输入：n = 5<br>输出：5</p><p>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(N-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】用两个栈实现队列</title>
    <link href="/2020/07/10/jianzhi-offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/07/10/jianzhi-offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Deque&lt;Integer&gt; stack1;    Deque&lt;Integer&gt; stack2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();        stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        stack1.push(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果第二个栈为空，就把第一个全部倒进第二个</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;                stack2.push(stack1.pop());            &#125;        &#125;        <span class="hljs-comment">//判断第二个栈是否为空，空就返回-1</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> stack2.pop();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】重建二叉树</title>
    <link href="/2020/07/10/jianzhi-offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/10/jianzhi-offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>递归解法</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map &lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.length;i++)map.put(inorder[i],i);        <span class="hljs-keyword">return</span> dfs(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> pl,<span class="hljs-keyword">int</span> pr,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> il,<span class="hljs-keyword">int</span> ir)</span></span>&#123;        <span class="hljs-keyword">if</span>(pl&gt;pr)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[pl]);        <span class="hljs-keyword">int</span> k=map.get(root.val);        TreeNode left = dfs(preorder,pl+<span class="hljs-number">1</span>,pl+k-il,inorder,il,k-<span class="hljs-number">1</span>);        TreeNode right = dfs(preorder,pl+k-il+<span class="hljs-number">1</span>,pr,inorder,k+<span class="hljs-number">1</span>,ir);        root.left=left;        root.right=right;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】找出数组中重复的数字</title>
    <link href="/2020/07/10/jianzhi-offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/jianzhi-offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;  <span class="hljs-comment">//看题目要求，这一段可以不写</span>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span> || nums[i]&gt;n)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">while</span>(nums[i]!=i)&#123;                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<span class="hljs-keyword">return</span> nums[i];                swap(nums,i,nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp=nums[a];        nums[a]=nums[b];        nums[b]=tmp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】从尾到头打印链表</title>
    <link href="/2020/07/10/jianzhi-offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/10/jianzhi-offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;        List &lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            list.add(head.val);            head=head.next;        &#125;        <span class="hljs-keyword">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [list.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;            res[i]=list.get(res.length-<span class="hljs-number">1</span>-i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】替换空格</title>
    <link href="/2020/07/10/jianzhi-offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2020/07/10/jianzhi-offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = s.length();        <span class="hljs-keyword">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length * <span class="hljs-number">3</span>];        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">char</span> c = s.charAt(i);            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;                array[size++] = <span class="hljs-string">'%'</span>;                array[size++] = <span class="hljs-string">'2'</span>;                array[size++] = <span class="hljs-string">'0'</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                array[size++] = c;            &#125;        &#125;        String newStr = <span class="hljs-keyword">new</span> String(array, <span class="hljs-number">0</span>, size);  <span class="hljs-comment">//记住这种转换方法</span>        <span class="hljs-keyword">return</span> newStr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二维数组中的查找</title>
    <link href="/2020/07/10/jianzhi-offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/07/10/jianzhi-offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数target。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是遍历寻找，或者二分，但是这个题很取巧</p><p>比如我们将要求的数和右上角进行比较</p><p>如果右上角小于target，那么这一行所有的数小于target  也就是i++</p><p>如果右上角大于target，那么这一列所有的数都大于target   也就是j–</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;-<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(matrix[i][j]==target)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)i++;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Gateway微服务网关</title>
    <link href="/2020/07/08/goujian/12.Gateway%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    <url>/2020/07/08/goujian/12.Gateway%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Gateway微服务网关"><a href="#【项目创建流程】Gateway微服务网关" class="headerlink" title="【项目创建流程】Gateway微服务网关"></a>【项目创建流程】Gateway微服务网关</h1><h2 id="网关基本概念"><a href="#网关基本概念" class="headerlink" title="网关基本概念"></a>网关基本概念</h2><h3 id="1、API网关介绍"><a href="#1、API网关介绍" class="headerlink" title="1、API网关介绍"></a>1、API网关介绍</h3><p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><p>（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。</p><p>（2）存在跨域请求，在一定场景下处理相对复杂。</p><p>（3）认证复杂，每个服务都需要独立认证。</p><p>（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</p><p>以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p><h3 id="2、Spring-Cloud-Gateway"><a href="#2、Spring-Cloud-Gateway" class="headerlink" title="2、Spring Cloud Gateway"></a>2、Spring Cloud Gateway</h3><p><strong>Spring cloud gateway</strong>是spring官方基于Spring 5.0和Spring Boot2.0等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。</p><h3 id="3、Spring-Cloud-Gateway-核心概念"><a href="#3、Spring-Cloud-Gateway-核心概念" class="headerlink" title="3、Spring Cloud Gateway 核心概念"></a>3、Spring Cloud Gateway 核心概念</h3><p>下面介绍一下Spring Cloud Gateway中几个重要的概念。</p><p>（1）路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter组成。如果断言路由为真，则说明请求的URL和配置匹配</p><p>（2）断言。Java8中的断言函数。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。</p><p>（3）过滤器。一个标准的Spring webFilter。Spring cloud gateway中的filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。</p><h3 id="4、执行流程"><a href="#4、执行流程" class="headerlink" title="4、执行流程"></a>4、执行流程</h3><p>如下图所示，Spring cloud Gateway发出请求。然后再由Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway web handler。Handler再通过指定的过滤器链将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154454.png" srcset="/img/loading.gif" alt="image-20200723154454083"></p><p><strong>4、特点</strong></p><p>优点：</p><ul><li>性能强劲：是第一代网关Zuul的1.6倍</li><li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li><li>设计优雅，容易扩展</li></ul><p>缺点：</p><ul><li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li><li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li><li>需要Spring Boot 2.0及以上的版本，才支持</li></ul><h2 id="搭建Gateway服务"><a href="#搭建Gateway服务" class="headerlink" title="搭建Gateway服务"></a>搭建Gateway服务</h2><h3 id="创建父模块infrastructure"><a href="#创建父模块infrastructure" class="headerlink" title="创建父模块infrastructure"></a>创建父模块infrastructure</h3><h3 id="创建子模块api-gateway"><a href="#创建子模块api-gateway" class="headerlink" title="创建子模块api_gateway"></a>创建子模块api_gateway</h3><h3 id="配置pom"><a href="#配置pom" class="headerlink" title="配置pom"></a>配置pom</h3><p>在api_gateway的pom中添加如下依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 网关 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h3 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h3><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">9110</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">infrastructure-apigateway</span> <span class="hljs-comment"># 服务名</span></code></pre><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><p>修改日志输出目录名为 apigateway</p><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><blockquote><p>gataway依赖common，课是common引入了mybatisplus操作，所有有数据库操作，因此需要排除数据库操作</p><p>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class} )</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfrastructureApiGatewayApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(InfrastructureApiGatewayApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="启动网关"><a href="#启动网关" class="headerlink" title="启动网关"></a>启动网关</h2><h3 id="配置路由和跨域"><a href="#配置路由和跨域" class="headerlink" title="配置路由和跨域"></a>配置路由和跨域</h3><h4 id="1、路由和断言"><a href="#1、路由和断言" class="headerlink" title="1、路由和断言"></a>1、路由和断言</h4><p>application.yml文件中添加路由配置</p><ul><li>-：表示数组元素，可以配置多个节点</li><li>id：配置的唯一标识，可以和微服务同名，也可以起别的名字，区别于其他 Route。</li><li>uri：路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li><li>predicates：断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li><li>Path：路径形式的断言。当匹配这个路径时，断言条件成立</li><li>/**：一个或多个层次的路径</li></ul><pre><code class="hljs dts"><span class="hljs-meta">#spring:</span><span class="hljs-symbol">  cloud:</span><span class="hljs-symbol">    gateway:</span><span class="hljs-symbol">      routes:</span>      - id: service-edu<span class="hljs-symbol">        uri:</span> http:<span class="hljs-comment">//localhost:8110</span><span class="hljs-symbol">        predicates:</span>        - Path=<span class="hljs-meta-keyword">/user/</span>**</code></pre><h5 id="内置路由断言工厂"><a href="#内置路由断言工厂" class="headerlink" title="内置路由断言工厂"></a>内置路由断言工厂</h5><p>Predicate(断言) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。</p><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><h6 id="1、基于Datetime"><a href="#1、基于Datetime" class="headerlink" title="1、基于Datetime"></a>1、基于Datetime</h6><p>此类型的断言根据时间做判断，主要有三个：</p><ul><li>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期</li><li>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期</li><li>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内</li></ul><pre><code class="hljs angelscript">- After=<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>T23:<span class="hljs-number">59</span>:<span class="hljs-number">59.789</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>[Asia/Shanghai]</code></pre><h6 id="2、基于远程地址"><a href="#2、基于远程地址" class="headerlink" title="2、基于远程地址"></a>2、基于远程地址</h6><p> RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中</p><pre><code class="hljs angelscript">- RemoteAddr=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">24</span></code></pre><h6 id="3、基于Cookie"><a href="#3、基于Cookie" class="headerlink" title="3、基于Cookie"></a>3、基于Cookie</h6><p>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Cookie</span>=chocolate, ch.</code></pre><h6 id="4、基于Header"><a href="#4、基于Header" class="headerlink" title="4、基于Header"></a>4、基于Header</h6><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Header</span>=X-Request-Id, \d+</code></pre><h6 id="5、基于Host"><a href="#5、基于Host" class="headerlink" title="5、基于Host"></a>5、基于Host</h6><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Host</span>=**.testhost.org</code></pre><h6 id="6、基于Method请求方法"><a href="#6、基于Method请求方法" class="headerlink" title="6、基于Method请求方法"></a>6、基于Method请求方法</h6><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。</p><pre><code class="hljs oxygene">- <span class="hljs-function"><span class="hljs-keyword">Method</span>=<span class="hljs-title">GET</span></span></code></pre><h6 id="7、基于Path请求路径"><a href="#7、基于Path请求路径" class="headerlink" title="7、基于Path请求路径"></a>7、基于Path请求路径</h6><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。</p><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/foo/</span>**</span></code></pre><h6 id="8、基于Query请求参数"><a href="#8、基于Query请求参数" class="headerlink" title="8、基于Query请求参数"></a>8、基于Query请求参数</h6><p>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Query</span>=url,baidu</code></pre><h6 id="9、基于路由权重"><a href="#9、基于路由权重" class="headerlink" title="9、基于路由权重"></a>9、基于路由权重</h6><p>WeightRoutePredicateFactory：接收一个[组名,权重]，然后对于同一个组内的路由按照权重转发</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route1</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host1</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group3,</span> <span class="hljs-number">1</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route2</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host2</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=</span> <span class="hljs-string">group3,</span> <span class="hljs-number">9</span></code></pre><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><h6 id="一、过滤器的基本概念"><a href="#一、过滤器的基本概念" class="headerlink" title="一、过滤器的基本概念"></a>一、过滤器的基本概念</h6><p>1、作用</p><p>过滤器就是在请求的传递过程中，对请求和响应做一些修改</p><p>2、生命周期</p><p>客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p><p>pre： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现参数校验、权限校验、流量监控、日志输出、协议转换等；</p><p>post：这种过滤器在路由到达微服务以后执行。这种过滤器可用做响应内容、响应头的修改，日志的输出，流量监控等。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154536.png" srcset="/img/loading.gif" alt="image-20200723154536196"></p><p>3、分类</p><p>局部过滤器 GatewayFilter：作用在某一个路由上</p><p>全局过滤器 GlobalFilter：作用全部路由上</p><h6 id="二、局部过滤器"><a href="#二、局部过滤器" class="headerlink" title="二、局部过滤器"></a>二、局部过滤器</h6><p>1、内置局部过滤器</p><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">service-edu</span>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-edu</span>  <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**,</span> <span class="hljs-string">/*/edu/**</span>  <span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=250</span> <span class="hljs-comment"># 修改返回状态码</span></code></pre><p>测试：</p><p><img src="https:////img2.jimu98.cn/blog/20200723154605.png" srcset="/img/loading.gif" alt="image-20200723154605180"></p><h6 id="三、全局过滤器"><a href="#三、全局过滤器" class="headerlink" title="三、全局过滤器"></a>三、全局过滤器</h6><p>1、内置全局过滤器</p><p><img src="https:////img2.jimu98.cn/blog/20200723154630.png" srcset="/img/loading.gif" alt="image-20200723154630370"></p><p>内置全局过滤器的使用举例：负载均衡过滤器</p><pre><code class="hljs dts"><span class="hljs-symbol">lb:</span><span class="hljs-comment">//service-edu</span></code></pre><p>2、自定义全局过滤器</p><p>定义一个Filter实现 GlobalFilter 和 Ordered接口</p><p><code>自定义转发路径</code></p><pre><code class="hljs yaml"><span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\&#123;segment&#125;</span></code></pre><p>2、测试网关路由转发</p><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><p>请求转发到：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:8110/user/info</a></p><h3 id="通过nacos注册中心"><a href="#通过nacos注册中心" class="headerlink" title="通过nacos注册中心"></a>通过nacos注册中心</h3><h4 id="1、网关中添加依赖"><a href="#1、网关中添加依赖" class="headerlink" title="1、网关中添加依赖"></a>1、网关中添加依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、主类添加注解"><a href="#2、主类添加注解" class="headerlink" title="2、主类添加注解"></a>2、主类添加注解</h4><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableDiscoveryClient</span>  <span class="hljs-comment">//SpringBoot2.0之后可以省略</span></code></pre><h4 id="3、添加nacos配置"><a href="#3、添加nacos配置" class="headerlink" title="3、添加nacos配置"></a>3、添加nacos配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><h4 id="4、添加gateway配置"><a href="#4、添加gateway配置" class="headerlink" title="4、添加gateway配置"></a>4、添加gateway配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span><span class="hljs-comment">#    gateway:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">locator:</span>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># gateway可以发现nacos中的微服务</span></code></pre><h4 id="5、修改uri配置"><a href="#5、修改uri配置" class="headerlink" title="5、修改uri配置"></a>5、修改uri配置</h4><p>将uri的地址修改成注册中心中的微服务地址，网关姜葱nacos中按照名称获取微服务</p><p>lb：表示在集群环境下通过负载均衡的方式调用</p><pre><code class="hljs groovy"><span class="hljs-string">uri:</span> <span class="hljs-string">lb:</span><span class="hljs-comment">//service-edu  #内置负载均衡过滤器</span></code></pre><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><h4 id="7、匹配多个path"><a href="#7、匹配多个path" class="headerlink" title="7、匹配多个path"></a>7、匹配多个path</h4><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span></code></pre><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><h4 id="1、前端配置"><a href="#1、前端配置" class="headerlink" title="1、前端配置"></a>1、前端配置</h4><p>修改guli-admin中 config/dev.env.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">BASE_API: '"http://127.0.0.1:<span class="hljs-number">9110</span>"',</code></pre><h4 id="2、删除后端跨域配置"><a href="#2、删除后端跨域配置" class="headerlink" title="2、删除后端跨域配置"></a>2、删除后端跨域配置</h4><p>此时可以删除微服务中的跨域注解 <em>@CrossOrigin</em></p><p><em>例如 service_edu中 LoginController的跨域注解</em></p><h4 id="3、跨域配置"><a href="#3、跨域配置" class="headerlink" title="3、跨域配置"></a>3、跨域配置</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway.config;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        config.addAllowedMethod(<span class="hljs-string">"*"</span>);        config.addAllowedOrigin(<span class="hljs-string">"*"</span>);        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource(<span class="hljs-keyword">new</span> PathPatternParser());        source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(source);    &#125;&#125;</code></pre><p>注意：去掉后端的所有跨域配置</p><h3 id="完整的路由配置"><a href="#完整的路由配置" class="headerlink" title="完整的路由配置"></a>完整的路由配置</h3><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><pre><code class="hljs haml">routes:-<span class="ruby"> <span class="hljs-symbol">id:</span> service-edu</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-edu</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-cms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-cms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/cms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-oss</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-oss</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/oss</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-sms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-sms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/sms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-trade</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-trade</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/trade</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-ucenter</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-ucenter</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/ucenter</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-vod</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-vod</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/vod</span><span class="hljs-regexp">/**</span></span></code></pre><h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><p>（1）修改guli-site中 utils/request.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">baseURL: 'http://127.0.0.1:<span class="hljs-number">9110</span>',</code></pre><p>（2）所有的api模块中的baseURL可以删除</p><p>（3）guli-admin上传相关表单中action地址的修改</p><p>data中定义：</p><pre><code class="hljs css"><span class="hljs-selector-tag">BASE_API</span>: <span class="hljs-selector-tag">process</span><span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.BASE_API</span></code></pre><p>html中使用：</p><pre><code class="hljs clojure"><span class="hljs-symbol">:action=</span><span class="hljs-string">"BASE_API+'/admin/oss/file/upload?module=avatar'"</span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】集成Redis缓存</title>
    <link href="/2020/07/08/goujian/11.%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%92%8CRedis/"/>
    <url>/2020/07/08/goujian/11.%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%92%8CRedis/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】集成Redis缓存"><a href="#【项目创建流程】集成Redis缓存" class="headerlink" title="【项目创建流程】集成Redis缓存"></a>【项目创建流程】集成Redis缓存</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>由于首页数据变化不是很频繁，而且首页访问量相对较大，所以我们有必要把首页数据缓存到redis中，减少数据库压力和提高访问速度。</p><h3 id="2、RedisTemplate"><a href="#2、RedisTemplate" class="headerlink" title="2、RedisTemplate"></a>2、RedisTemplate</h3><p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是Spring Data Redis中对Jedis api的高度封装。</p><p>Spring Data Redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化功能，支持发布订阅，并对spring cache进行了实现。</p><h2 id="二、引入redis"><a href="#二、引入redis" class="headerlink" title="二、引入redis"></a>二、引入redis</h2><h3 id="1、项目中集成redis"><a href="#1、项目中集成redis" class="headerlink" title="1、项目中集成redis"></a>1、项目中集成redis</h3><p>common父模块中添加redis依赖，Spring Boot 2.0以上默认通过commons-pool2连接池连接redis</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring boot redis缓存引入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- lecttuce 缓存连接池--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加redis连接配置"><a href="#2、添加redis连接配置" class="headerlink" title="2、添加redis连接配置"></a>2、添加redis连接配置</h3><p>service_cms 和 service_edu 的 application.yml 中添加如下配置</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.100</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span> <span class="hljs-comment">#默认为空</span>    <span class="hljs-attr">lettuce:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#最大连接数，负值表示没有限制，默认8</span>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span>    <span class="hljs-comment">#最大阻塞等待时间，负值表示没限制，默认-1</span>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>     <span class="hljs-comment">#最大空闲连接，默认8</span>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>     <span class="hljs-comment">#最小空闲连接，默认0</span></code></pre><h3 id="3、配置Redis"><a href="#3、配置Redis" class="headerlink" title="3、配置Redis"></a>3、配置Redis</h3><p>service-base添加RedisConfig</p><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.atguigu.guli.service.base.config;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 我们自定义一个 RedisTemplate，设置序列化器，这样我们可以很方便的操作实例对象。</span><span class="hljs-comment"> * 否则redis自动使用对象的jdk序列化</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    @Bean    <span class="hljs-keyword">public</span> RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-type">RedisTemplate</span>&lt;&gt;();        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">StringRedisSerializer</span>());<span class="hljs-comment">//key序列化方式</span>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">GenericJackson2JsonRedisSerializer</span>());<span class="hljs-comment">//value序列化</span>        redisTemplate.setConnectionFactory(connectionFactory);                <span class="hljs-keyword">return</span> redisTemplate;    &#125;&#125;</code></pre><h2 id="三、测试redisTemplate"><a href="#三、测试redisTemplate" class="headerlink" title="三、测试redisTemplate"></a>三、测试redisTemplate</h2><h3 id="1、测试redis数据存储"><a href="#1、测试redis数据存储" class="headerlink" title="1、测试redis数据存储"></a>1、测试redis数据存储</h3><p>ApiAdController中添加下面的方法进行测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@PostMapping(<span class="hljs-meta-string">"save-test"</span>)</span><span class="hljs-keyword">public</span> R saveAd(<span class="hljs-meta">@RequestBody</span> Ad ad)&#123;    <span class="hljs-comment">//redisTemplate.opsForValue().set("ad1", ad);</span>    redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(<span class="hljs-string">"index::ad"</span>, ad);    <span class="hljs-keyword">return</span> R.ok();&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"get-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R getAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    Ad ad = (Ad)redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(key);    <span class="hljs-keyword">return</span> R.ok().<span class="hljs-keyword">data</span>(<span class="hljs-string">"ad"</span>, ad);&#125;<span class="hljs-meta">@DeleteMapping(<span class="hljs-meta-string">"remove-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R removeAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    <span class="hljs-built_in">Boolean</span> delete = redisTemplate.delete(key);    System.<span class="hljs-keyword">out</span>.println(delete);<span class="hljs-comment">//是否删除成功</span>    <span class="hljs-built_in">Boolean</span> hasKey = redisTemplate.hasKey(key);    System.<span class="hljs-keyword">out</span>.println(hasKey);<span class="hljs-comment">//key是否存在</span>    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h3 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h3><p>redisTemplate提供了以下几种存储数据的方法</p><pre><code class="hljs gcode">redisTemplate.opsForValue<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作字符串</span>redisTemplate.opsForHash<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作hash</span>redisTemplate.opsForList<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作list</span>redisTemplate.opsForSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作set</span>redisTemplate.opsForZSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作有序set</span></code></pre><h2 id="四、使用缓存注解"><a href="#四、使用缓存注解" class="headerlink" title="四、使用缓存注解"></a>四、使用缓存注解</h2><h3 id="1、修改Redis配置类"><a href="#1、修改Redis配置类" class="headerlink" title="1、修改Redis配置类"></a>1、修改Redis配置类</h3><p>配置类上添加注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableCaching</span></code></pre><p>添加bean配置</p><pre><code class="hljs reasonml">@Beanpublic CacheManager cache<span class="hljs-constructor">Manager(LettuceConnectionFactory <span class="hljs-params">connectionFactory</span>)</span> &#123;        RedisCacheConfiguration config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheConfiguration</span>.</span></span>default<span class="hljs-constructor">CacheConfig()</span>        <span class="hljs-comment">//过期时间600秒</span>        .entry<span class="hljs-constructor">Ttl(Duration.<span class="hljs-params">ofSeconds</span>(600)</span>)         <span class="hljs-comment">// 配置序列化</span>        .serialize<span class="hljs-constructor">KeysWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> StringRedisSerializer()</span>))        .serialize<span class="hljs-constructor">ValuesWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> GenericJackson2JsonRedisSerializer()</span>))        .disable<span class="hljs-constructor">CachingNullValues()</span>;    RedisCacheManager cacheManager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheManager</span>.</span></span>builder(connectionFactory)        .cache<span class="hljs-constructor">Defaults(<span class="hljs-params">config</span>)</span>        .build<span class="hljs-literal">()</span>;    return cacheManager;&#125;</code></pre><h3 id="2、添加缓存注解"><a href="#2、添加缓存注解" class="headerlink" title="2、添加缓存注解"></a>2、添加缓存注解</h3><p>@Cacheable(value = “xxx”, key = “‘xxx’”)：标注在方法上，对方法返回结果进行缓存。下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><p>service_cms：AdServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectByAdTypeId'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Ad&gt; selectByAdTypeId(String adTypeId) &#123;</code></pre><p>service_edu：CourseServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotCourse'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Course&gt; selectHotCourse() &#123;</code></pre><p>service_edu：TeacherServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotTeacher'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Teacher&gt; selectHotTeacher() &#123;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Redis</tag>
      
      <tag>bean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Sentinel介绍和环境搭建</title>
    <link href="/2020/07/08/goujian/10.Sentinel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/07/08/goujian/10.Sentinel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Sentinel介绍和环境搭建"><a href="#【项目创建流程】Sentinel介绍和环境搭建" class="headerlink" title="【项目创建流程】Sentinel介绍和环境搭建"></a>【项目创建流程】Sentinel介绍和环境搭建</h1><h2 id="一、Sentinel介绍"><a href="#一、Sentinel介绍" class="headerlink" title="一、Sentinel介绍"></a>一、Sentinel介绍</h2><h3 id="1、什么是Sentinel"><a href="#1、什么是Sentinel" class="headerlink" title="1、什么是Sentinel"></a>1、什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于服务容错的综合性解决方案。它以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来保护服务的稳定性。</p><h3 id="2、Sentinel-的特征"><a href="#2、Sentinel-的特征" class="headerlink" title="2、Sentinel 的特征"></a>2、Sentinel 的特征</h3><ul><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li>完备的实时监控：Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 SpringCloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。</li><li>完善的扩展点：Sentinel 提供简单易用、完善的扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="3、Sentinel-的组成"><a href="#3、Sentinel-的组成" class="headerlink" title="3、Sentinel 的组成"></a>3、Sentinel 的组成</h3><p>核心库（Java 客户端）：不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo /Spring Cloud 等框架也有较好的支持。</p><p>控制台（Dashboard）：基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="二、Sentinel控制台"><a href="#二、Sentinel控制台" class="headerlink" title="二、Sentinel控制台"></a>二、Sentinel控制台</h2><p>Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。</p><h3 id="1、下载和安装"><a href="#1、下载和安装" class="headerlink" title="1、下载和安装"></a>1、下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></p><p>下载版本：sentinel-dashboard-1.7.0.jar</p><h3 id="2、启动控制台"><a href="#2、启动控制台" class="headerlink" title="2、启动控制台"></a>2、启动控制台</h3><p>控制台本身是一个SpringBoot项目，直接使用jar命令启动项目</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">sentinel-dashboard-1</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.jar</span></code></pre><pre><code class="hljs reasonml">java -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dserver</span>.</span></span>port=<span class="hljs-number">8888</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dcsp</span>.</span></span>sentinel.dashboard.server=localhost:<span class="hljs-number">8080</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dproject</span>.</span></span>name=sentinel-dashboard -jar sentinel-dashboard-<span class="hljs-number">1.7</span>.<span class="hljs-number">0.</span>jar</code></pre><p>访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>用户名密码：sentinel/sentinel</p><h2 id="三、微服务集成Sentinel客户端"><a href="#三、微服务集成Sentinel客户端" class="headerlink" title="三、微服务集成Sentinel客户端"></a>三、微服务集成Sentinel客户端</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Sentinel的pom依赖（实际是在服务消费者端需要依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加测试方法"><a href="#2、添加测试方法" class="headerlink" title="2、添加测试方法"></a>2、添加测试方法</h3><p>TeacherController中添加如下方法用于测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message1"</span>)</span><span class="hljs-keyword">public</span> String message1() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message1"</span>;&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message2"</span>)</span><span class="hljs-keyword">public</span> String message2() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message2"</span>;&#125;</code></pre><h2 id="四、微服务连接控制台"><a href="#四、微服务连接控制台" class="headerlink" title="四、微服务连接控制台"></a>四、微服务连接控制台</h2><h3 id="1、微服务配置"><a href="#1、微服务配置" class="headerlink" title="1、微服务配置"></a>1、微服务配置</h3><p>service_edu微服务yml中添加以下配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span> <span class="hljs-comment">#跟控制台交流的端口，随意指定一个未使用的端口即可</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment"># 指定控制台服务的地址</span></code></pre><h3 id="2、swagger中测试"><a href="#2、swagger中测试" class="headerlink" title="2、swagger中测试"></a>2、swagger中测试</h3><p>测试message1和message2的访问</p><h3 id="3、查看sentinel控制台"><a href="#3、查看sentinel控制台" class="headerlink" title="3、查看sentinel控制台"></a>3、查看sentinel控制台</h3><p><img src="https://img2.jimu98.cn/blog/20200723155019.png" srcset="/img/loading.gif" alt="image-20200723155018963"></p><h3 id="4、控制台运行原理"><a href="#4、控制台运行原理" class="headerlink" title="4、控制台运行原理"></a>4、控制台运行原理</h3><p>Sentinel的控制台是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上，即在微服务中指定控制台的地址（localhost:8080）</p><p>并且还要开启一个跟控制台传递数据的端口（8081），控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。</p><h2 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h2><h3 id="1、引入sentinel的依赖"><a href="#1、引入sentinel的依赖" class="headerlink" title="1、引入sentinel的依赖"></a>1、引入sentinel的依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、开启Sentinel支持"><a href="#2、开启Sentinel支持" class="headerlink" title="2、开启Sentinel支持"></a>2、开启Sentinel支持</h3><p>在service_edu的yml配置文件中开启Feign对Sentinel的支持</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h3 id="3、创建容错类"><a href="#3、创建容错类" class="headerlink" title="3、创建容错类"></a>3、创建容错类</h3><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign.fallback;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OssFileServiceFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">removeFile</span><span class="hljs-params">(String url)</span> </span>&#123;        log.info(<span class="hljs-string">"熔断保护"</span>);        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;&#125;</code></pre><h3 id="4、指定容错类"><a href="#4、指定容错类" class="headerlink" title="4、指定容错类"></a>4、指定容错类</h3><p>为OpenFeign远程调用接口添加fallback属性值没指定容错类</p><pre><code class="hljs less"><span class="hljs-variable">@Service</span><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">"service-oss"</span>, fallback = OssFileServiceFallBack.class)public interface OssFileService &#123;</code></pre><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>停止service_oss微服务，测试删除讲师的功能</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Sentinel</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】注册中心和服务调用和配置中心</title>
    <link href="/2020/07/08/goujian/9.Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/07/08/goujian/9.Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Nacos注册中心和服务调用和配置中心"><a href="#【项目创建流程】Nacos注册中心和服务调用和配置中心" class="headerlink" title="【项目创建流程】Nacos注册中心和服务调用和配置中心"></a>【项目创建流程】Nacos注册中心和服务调用和配置中心</h1><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><h3 id="1、常见注册中心"><a href="#1、常见注册中心" class="headerlink" title="1、常见注册中心"></a>1、常见注册中心</h3><ul><li><p>Eureka：Eureka是Spring Cloud Netflix中的重要组件，主要作用就是做服务注册和发现。2.0遇到性能瓶颈，停止维护，现在已经闭源。</p></li><li><p>Consul：Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。</p></li><li><p>Zookeeper：zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目。</p></li><li><p>Nacos（Spring Cloud Alibaba）</p></li><li><ul><li>Alibaba针对Spring Cloud体系的注册中心</li><li>相对于 Spring Cloud Eureka 来说，Nacos 更强大</li><li>Nacos = Spring Cloud Eureka + Spring Cloud Config + Spring Cloud Bus</li></ul></li></ul><h3 id="2、为什么叫Nacos"><a href="#2、为什么叫Nacos" class="headerlink" title="2、为什么叫Nacos"></a>2、为什么叫Nacos</h3><ul><li><p>前四个字母分别为 Naming 和 Configuration 的前两个字母，最后的s为Service</p></li><li><ul><li>Dynamic Naming and Configuration Service</li></ul></li><li><p>Nacos就是：注册中心 + 配置中心的组合</p></li><li><ul><li>Spring Cloud Alibaba Nacos = SpringCloudEureka + SpringCloudConfig +SpringCloudBus</li></ul></li></ul><h3 id="3、Nacos下载和安装"><a href="#3、Nacos下载和安装" class="headerlink" title="3、Nacos下载和安装"></a>3、Nacos下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>下载版本：nacos-server-1.1.4.zip 或 nacos-server-1.1.4.tar.gz，解压任意目录即可</p><h3 id="4、启动Nacos"><a href="#4、启动Nacos" class="headerlink" title="4、启动Nacos"></a>4、启动Nacos</h3><p>- Windows</p><p>启动：双击bin/startup.cmd运行文件</p><p>访问：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><p>- Linux/Unix/Mac</p><p>启动命令(standalone代表着单机模式运行，非集群模式)</p><p>启动命令：sh startup.sh -m standalone</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Nacos客户端的pom依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加服务配置信息"><a href="#2、添加服务配置信息" class="headerlink" title="2、添加服务配置信息"></a>2、添加服务配置信息</h3><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><p>接下来要起一个名字，这样才能知道这个服务在配置中心叫什么</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">gulimall-coupon</span></code></pre><h3 id="3、添加Nacos客户端注解"><a href="#3、添加Nacos客户端注解" class="headerlink" title="3、添加Nacos客户端注解"></a>3、添加Nacos客户端注解</h3><p>在客户端微服务启动类中添加注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span>   <span class="hljs-comment">//开启服务注册发现，这个注解可加可不加</span></code></pre><h3 id="4、启动客户端微服务"><a href="#4、启动客户端微服务" class="headerlink" title="4、启动客户端微服务"></a>4、启动客户端微服务</h3><p>启动注册中心，启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><p><img src="https://img2.jimu98.cn/blog/20200723155043.png" srcset="/img/loading.gif" alt="image-20200723155043496"></p><h2 id="基于OpenFeign的服务调用"><a href="#基于OpenFeign的服务调用" class="headerlink" title="基于OpenFeign的服务调用"></a>基于OpenFeign的服务调用</h2><h3 id="一、OpenFeign是什么"><a href="#一、OpenFeign是什么" class="headerlink" title="一、OpenFeign是什么"></a>一、OpenFeign是什么</h3><p>说起这个，还得先知道Feign是什么，Feign是一个声明式的Http客户端，它的目的就是让远程调用更加简单，Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数，格式，地址等信息</p><p>OpenFeign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。</p><p>Nacos很好的兼容了OpenFeign， OpenFeign默认集成了 Ribbon， 所以在Nacos下使用OpenFeign默认就实现了负载均衡的效果。</p><h3 id="二、OpenFeign的引入"><a href="#二、OpenFeign的引入" class="headerlink" title="二、OpenFeign的引入"></a>二、OpenFeign的引入</h3><h4 id="1、引入依赖-1"><a href="#1、引入依赖-1" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>service模块中配置OpenFeign的pom依赖（实际是在服务消费者端需要OpenFeign的依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务调用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、启动类添加注解"><a href="#2、启动类添加注解" class="headerlink" title="2、启动类添加注解"></a>2、启动类添加注解</h4><p>在消费者service_edu的启动类添加如下注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span>或者<span class="hljs-meta">@EnableFeignClients</span>(basePackages = <span class="hljs-string">"cn.jimu98.gulimall.member.feign"</span>)</code></pre><h3 id="三、OpenFeign的使用"><a href="#三、OpenFeign的使用" class="headerlink" title="三、OpenFeign的使用"></a>三、OpenFeign的使用</h3><h4 id="1、oss微服务中创建测试api"><a href="#1、oss微服务中创建测试api" class="headerlink" title="1、oss微服务中创建测试api"></a>1、oss微服务中创建测试api</h4><p>服务的生产者的FileController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test() &#123;    <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h4 id="2、edu微服务中创建远程调用接口"><a href="#2、edu微服务中创建远程调用接口" class="headerlink" title="2、edu微服务中创建远程调用接口"></a>2、edu微服务中创建远程调用接口</h4><p>服务消费者中创建feign包，创建如下接口：</p><p>该接口首先写上注解</p><p>@FeignClient(“service-oss”)  表示调用哪个微服务</p><p>然后里面写上具体的方法（该方法去直接复制生产者Controller复制即可，但是要注意全地址，包括类注解地址）</p><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign;<span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(<span class="hljs-meta-string">"service-oss"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/admin/oss/file/test"</span>)</span>    R test();&#125;</code></pre><h4 id="3、调用远程方法"><a href="#3、调用远程方法" class="headerlink" title="3、调用远程方法"></a>3、调用远程方法</h4><p>服务消费者中的TeacherController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span>private OssFileService ossFileService;<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">"测试服务调用"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test()&#123;    <span class="hljs-selector-tag">ossFileService</span><span class="hljs-selector-class">.test</span>();    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h3 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h3><h4 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h4><table><thead><tr><th>策略名</th><th>策略描述</th></tr></thead><tbody><tr><td>BestAvailableRule</td><td>选择一个最小的并发请求的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）</td></tr><tr><td>WeightedResponseTimeRule</td><td>根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</td></tr><tr><td>RetryRule</td><td>对选定的负载均衡策略机上重试机制。</td></tr><tr><td>RoundRobinRule</td><td>轮询选择server</td></tr><tr><td>RandomRule</td><td>随机选择一个server</td></tr><tr><td>ZoneAvoidanceRule</td><td>综合判断server所在区域的性能和server的可用性选择server</td></tr></tbody></table><p>配置负载均衡策略的方式：</p><pre><code class="hljs yaml"><span class="hljs-attr">service-product:</span> <span class="hljs-comment"># 调用的提供者的名称 </span>  <span class="hljs-attr">ribbon:</span>     <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span></code></pre><h3 id="五、OpenFeign的超时控制"><a href="#五、OpenFeign的超时控制" class="headerlink" title="五、OpenFeign的超时控制"></a>五、OpenFeign的超时控制</h3><h4 id="1、模拟长流程业务"><a href="#1、模拟长流程业务" class="headerlink" title="1、模拟长流程业务"></a>1、模拟长流程业务</h4><p>修改oss服务FileController的test方法，添加sleep 3秒：</p><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    log.info(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h4 id="2、远程调用测试"><a href="#2、远程调用测试" class="headerlink" title="2、远程调用测试"></a>2、远程调用测试</h4><p>上面的程序在测试时会出现远程调用超时错误。如下：因为OpenFeign默认等待1秒钟，否则超时报错</p><p>重试规则：每隔一秒发起重试</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 同一实例最大重试次数，不包括首次调用，默认0</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 重试其他实例的最大重试次数，不包括首次所选的server，默认1</span></code></pre><h4 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h4><p>application.yml文件中配置ribbon的超时时间（因为OpenFeing的底层即是对ribbon的封装）</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span></code></pre><h3 id="六、OpenFeign日志"><a href="#六、OpenFeign日志" class="headerlink" title="六、OpenFeign日志"></a>六、OpenFeign日志</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>OpenFeign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解OpenFeign中Http请求的细节。即对OpenFeign远程接口调用的情况进行监控和日志输出。</p><h4 id="2、日志级别"><a href="#2、日志级别" class="headerlink" title="2、日志级别"></a>2、日志级别</h4><ul><li>NONE：默认级别，不显示日志</li><li>BASIC：仅记录请求方法、URL、响应状态及执行时间</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应头信息</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应正文及元数据信息</li></ul><h4 id="3、配置日志bean"><a href="#3、配置日志bean" class="headerlink" title="3、配置日志bean"></a>3、配置日志bean</h4><p>在service_edu中创建配置文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.config</span>;<span class="hljs-keyword">@Configuration</span>public class OpenFeignConfig &#123;    <span class="hljs-keyword">@Bean</span>    Logger.Level feignLoggerLevel()&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Logger</span><span class="hljs-selector-class">.Level</span><span class="hljs-selector-class">.FULL</span>;    &#125;&#125;</code></pre><h4 id="4、开启日志"><a href="#4、开启日志" class="headerlink" title="4、开启日志"></a>4、开启日志</h4><p>在service_edu中，application.yml中指定监控的接口，以及日志级别</p><pre><code class="hljs css"><span class="hljs-selector-tag">logging</span>:  <span class="hljs-selector-tag">level</span>:    <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.feign</span><span class="hljs-selector-class">.OssFileService</span>: <span class="hljs-selector-tag">debug</span> #以什么级别监控哪个接口</code></pre><h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><h3 id="首先导入依赖"><a href="#首先导入依赖" class="headerlink" title="首先导入依赖"></a>首先导入依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置中心来做配置管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="新建bootstrap-yml-配置文件中配置Nacos-Config元数据"><a href="#新建bootstrap-yml-配置文件中配置Nacos-Config元数据" class="headerlink" title="新建bootstrap.yml 配置文件中配置Nacos Config元数据"></a>新建bootstrap.yml 配置文件中配置Nacos Config元数据</h3><blockquote><p>你既然要获取配置，那说明你上来根本没有配置，所以你得创建一个优先级更高的配置</p><p>来指定配置中心的地址</p><p>然后动态获取配置文件</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-sms</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">config:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos中心地址</span>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式，如果是properties文件则不用配置此项</span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.name1&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.age&#125;"</span>)<span class="hljs-keyword">private</span> String age;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"name"</span>, name+<span class="hljs-string">" ..."</span>).put(<span class="hljs-string">"age"</span>, age);&#125;</code></pre><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>public（保留空间）默认新增的所有配置都在public空间</p><p>开发，测试，生产：可能有不同的配置，这时候就可以创建不同的命名空间</p><blockquote><p>你可以创建不同的命名空间，然后创建配置的时候选择不同的命名空间</p><p>然后修改bootstrap文件，spring.cloud.nacos.config.namespace=xxxx;(id编号)</p></blockquote><h3 id="配置集"><a href="#配置集" class="headerlink" title="配置集"></a>配置集</h3><p>所有配置的集合</p><p>配置集ID：类似文件名</p><p>​    Data ID：</p><blockquote><p>使用spring.cloud.nacos.config.group=1111  //切换不同的组</p></blockquote><p>加载多个配置集</p><blockquote><p>spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml</p><p>spring.cloud.nacos.config.ext-config[0].group=dev</p><p>spring.cloud.nacos.config.ext-config[0].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml</p><p>spring.cloud.nacos.config.ext-config[1].group=dev</p><p>spring.cloud.nacos.config.ext-config[1].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[2].data-id=other.yml</p><p>spring.cloud.nacos.config.ext-config[2].group=dev</p><p>spring.cloud.nacos.config.ext-config[2].refresh=true  //配置是否自动刷新</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Nacos</tag>
      
      <tag>服务注册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端项目开发流程</title>
    <link href="/2020/07/08/goujian/8.%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/07/08/goujian/8.%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端项目开发流程"><a href="#【项目创建流程】前端项目开发流程" class="headerlink" title="【项目创建流程】前端项目开发流程"></a>【项目创建流程】前端项目开发流程</h1><h2 id="定义路由模块"><a href="#定义路由模块" class="headerlink" title="定义路由模块"></a>定义路由模块</h2><pre><code class="hljs js"><span class="hljs-comment">// 课程管理</span>  &#123;    path: <span class="hljs-string">'/course'</span>,    component: Layout,    redirect: <span class="hljs-string">'/course/list'</span>,    name: <span class="hljs-string">'Course'</span>,    meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程管理'</span> &#125;,    children: [      &#123;        path: <span class="hljs-string">'list'</span>,        name: <span class="hljs-string">'CourseList'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/list'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程列表'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info'</span>,        name: <span class="hljs-string">'CourseInfo'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'发布课程'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info/:id'</span>,        name: <span class="hljs-string">'CourseInfoEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑课程'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;,      &#123;        path: <span class="hljs-string">'chapter/:id'</span>,        name: <span class="hljs-string">'CourseChapterEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑大纲'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;    ]  &#125;,</code></pre><h2 id="定义api模块"><a href="#定义api模块" class="headerlink" title="定义api模块"></a>定义api模块</h2><pre><code class="hljs js"><span class="hljs-comment">// @ 符号在build/webpack.base.conf.js 中配置 表示 'src' 路径</span><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  list() &#123;    <span class="hljs-keyword">return</span> request(&#123;      url: <span class="hljs-string">'/admin/edu/teacher/list'</span>,      method: <span class="hljs-string">'get'</span>    &#125;)  &#125;&#125;</code></pre><h2 id="定义页面组件脚本"><a href="#定义页面组件脚本" class="headerlink" title="定义页面组件脚本"></a>定义页面组件脚本</h2><pre><code class="hljs vu">&lt;script&gt;import teacherApi from &#39;@&#x2F;api&#x2F;teacher&#39;export default &#123;  &#x2F;&#x2F; 定义数据模型  data() &#123;    return &#123;      list: [] &#x2F;&#x2F; 讲师列表    &#125;  &#125;,  &#x2F;&#x2F; 页面渲染成功后获取数据  created() &#123;    this.fetchData()  &#125;,  &#x2F;&#x2F; 定义方法  methods: &#123;    fetchData() &#123;      &#x2F;&#x2F; 调用api      teacherApi.list().then(response &#x3D;&gt; &#123;        this.list &#x3D; response.data.items      &#125;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h2 id="定义页面组件模板"><a href="#定义页面组件模板" class="headerlink" title="定义页面组件模板"></a>定义页面组件模板</h2><pre><code class="hljs vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    讲师列表  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端业务总结</title>
    <link href="/2020/07/08/goujian/7.%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1/"/>
    <url>/2020/07/08/goujian/7.%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端业务总结"><a href="#【项目创建流程】前端业务总结" class="headerlink" title="【项目创建流程】前端业务总结"></a>【项目创建流程】前端业务总结</h1><h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>为方便后续开发，建议安装如下插件</p><p><img src="https://img2.jimu98.cn/blog/20200723155141.png" srcset="/img/loading.gif" alt="image-20200723155141680"></p><p><img src="https://img2.jimu98.cn/blog/20200723155224.png" srcset="/img/loading.gif" alt="image-20200723155224355"></p><p><img src="https://img2.jimu98.cn/blog/20200723155212.png" srcset="/img/loading.gif" alt="image-20200723155212540"></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h4><p>浏览器的内核包括两部分核心：</p><ul><li><p>DOM渲染引擎</p></li><li><p>JavaScript解析引擎</p></li><li><ul><li>Chrome浏览器内置V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</li></ul></li></ul><h4 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h4><p>脱离浏览器环境也可以运行JavaScript，只要有JavaScript引擎就可以。</p><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境：即Node.js内置了Chrome的V8 引擎，可以在Node.js环境中直接运行JavaScript程序。</p><ul><li><p>在Node.js中写JavaScript和在Chrome浏览器中写JavaScript<strong>基本</strong>没有什么不一样。哪里不一样呢？</p></li><li><ul><li>Node.js没有浏览器API，即document，window的等。</li><li>加了许多Node.js 专属API，例如文件系统，进程，http功能。</li></ul></li></ul><h4 id="Node-js有什么用"><a href="#Node-js有什么用" class="headerlink" title="Node.js有什么用"></a>Node.js有什么用</h4><ul><li><p>如果你想开发类似JavaWeb的简单的后端程序，那么学习Node.js是一个非常好的选择。</p></li><li><p>如果你想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p></li><li><ul><li>通常他会被用来作一个BFF层，即 Backend For Frontend（服务于前端的后端），通俗的说是一个专门用于为前端业务提供数据的后端程序</li></ul></li></ul><h4 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h4><h5 id="BFF-解决什么问题"><a href="#BFF-解决什么问题" class="headerlink" title="BFF 解决什么问题"></a>BFF 解决什么问题</h5><p>一个前端页面向 Service A、Service B 以及 Service C发送请求，不同的微服务返回的值用于渲染页面中不同的组件。此时，每次访问该页面都需要发送 3 个请求。我们需要一个服务来聚合Service A、Service B 以及 Service C响应的数据，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF0_2.png" srcset="/img/loading.gif" alt="img"></p><p>手机、平板端、PC机等用户终端都需要向每个Service，例如Service A发送请求。对于同一个功能，不同的终端需要的数据格式和内容会有不同。此时 Service A 的一个接口，不能同时满足三个客户端的不同需求。我们可以在Service A中开发三个接口，也可以增加一个数据裁剪服务，将数据按照不同终端的不同要求进行裁剪，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF1_2.png" srcset="/img/loading.gif" alt="img"></p><p>BFF层的作用是让前端有能力自由组装后台数据，减少大量的业务沟通成本，加快业务的迭代速度。无论是数据聚合还是数据剪裁，这类程序的特点是不需要太强大的服务器运算能力，但是对程序的灵活性有较高的要求，这两个特点都正好和Node.js的优势相吻合。</p><h5 id="什么是BFF"><a href="#什么是BFF" class="headerlink" title="什么是BFF"></a>什么是BFF</h5><p>用户体验适配器</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击安装 node-v10.14.2-x64.msi</p><blockquote><p>查看版本 node -v</p></blockquote><h3 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h3><p>在为 AngularJS 工作之后，Vue 的作者尤雨溪开发出了这一框架。他声称自己的思路是提取 Angular 中为自己所喜欢的部分，构建出一款相当轻量的框架。Vue 最早发布于 2014 年 2 月。作者在 Hacker News、Echo JS 与 Reddit 的 javascript 版块发布了最早的版本。一天之内，Vue 就登上了这三个网站的首页。Vue 是 Github 上最受欢迎的开源项目之一。同时，在 JavaScript 框架/函数库中，Vue 所获得的星标数已超过 React，并高于 Backbone.js、Angular 2、jQuery 等项目。</p><p>Vue.js 是一款流行的 JavaScript 前端框架，目的是简化 Web 开发。Vue 所关注的核心是 MVC 模式中的视图层，同时，它也能方便地获取数据更新，实现视图与模型的交互。</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是独立于vue的一个项目，可以用于浏览器和node.js中发送ajax请求</p><h3 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h3><h4 id="1、引入脚本库"><a href="#1、引入脚本库" class="headerlink" title="1、引入脚本库"></a>1、引入脚本库</h4><p><strong>在axios_pro文件夹中引入：</strong>element-ui\lib</p><p><img src="http://img1.jimu98.cn//blog/49b60e78-20d8-4928-a8b6-0b2250de4a84.png" srcset="/img/loading.gif" alt="img"></p><h4 id="2、引入css"><a href="#2、引入css" class="headerlink" title="2、引入css"></a>2、引入css</h4><p>在axios.html 的head中引入css</p><pre><code class="hljs js">&lt;!-- <span class="hljs-keyword">import</span> CSS --&gt;&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"element-ui/lib/theme-chalk/index.css"</span>&gt;</code></pre><h4 id="3、引入js"><a href="#3、引入js" class="headerlink" title="3、引入js"></a>3、引入js</h4><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"element-ui/lib/index.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h4 id="4、渲染讲师列表"><a href="#4、渲染讲师列表" class="headerlink" title="4、渲染讲师列表"></a>4、渲染讲师列表</h4><p>注意：项目中的版本是2.4，参考对应版本的文档</p><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;el-button&gt;添加&lt;&#x2F;el-button&gt;    &lt;i class&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;i&gt;    &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;搜索&lt;&#x2F;el-button&gt;    &lt;el-table              :data&#x3D;&quot;teacherList&quot;              stripe              border              style&#x3D;&quot;width: 100%&quot;&gt;        &lt;el-table-column              type&#x3D;&quot;selection&quot;              width&#x3D;&quot;55&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;name&quot;              label&#x3D;&quot;姓名&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;gmtCreate&quot;              label&#x3D;&quot;入驻日期&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              label&#x3D;&quot;级别&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;                &#123;&#123; scope.row.level &#x3D;&#x3D;&#x3D; 1?&#39;高级讲师&#39;:&#39;首席讲师&#39; &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;&lt;&#x2F;div&gt;</code></pre><h3 id="NPM包管理器"><a href="#NPM包管理器" class="headerlink" title="NPM包管理器"></a>NPM包管理器</h3><h4 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h4><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 。</p><pre><code class="hljs coffeescript"><span class="hljs-comment">#在命令提示符输入 npm -v 可查看当前npm版本</span><span class="hljs-built_in">npm</span> -v</code></pre><h4 id="1、项目初始化"><a href="#1、项目初始化" class="headerlink" title="1、项目初始化"></a><strong>1、项目初始化</strong></h4><pre><code class="hljs vala"><span class="hljs-meta">#建立一个空文件夹，在命令提示符进入该文件夹  执行命令初始化</span>npm init<span class="hljs-meta">#按照提示输入相关信息，如果是用默认值则直接回车即可。</span><span class="hljs-meta">#name: 项目名称</span><span class="hljs-meta">#version: 项目版本号</span><span class="hljs-meta">#description: 项目描述</span><span class="hljs-meta">#keywords: &#123;Array&#125;关键词，便于用户搜索到我们的项目</span><span class="hljs-meta">#最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml</span><span class="hljs-meta">#我们之后也可以根据需要进行修改。</span></code></pre><pre><code class="hljs coffeescript"><span class="hljs-comment">#如果想直接生成 package.json 文件，那么可以使用命令</span><span class="hljs-built_in">npm</span> init -y</code></pre><h4 id="2、修改npm镜像"><a href="#2、修改npm镜像" class="headerlink" title="2、修改npm镜像"></a><strong>2、修改npm镜像</strong></h4><p>NPM官方的管理的包都是从 <a href="http://npmjs.com下载的，但是这个网站在国内速度很慢。" target="_blank" rel="noopener">http://npmjs.com下载的，但是这个网站在国内速度很慢。</a></p><p>这里推荐使用淘宝 NPM 镜像 <a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> ，淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。</p><p><strong>设置镜像地址：</strong></p><pre><code class="hljs tcl"><span class="hljs-comment">#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载</span>npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">registry</span> https://<span class="hljs-keyword">registry</span>.npm.taobao.org <span class="hljs-comment">#查看npm配置信息</span>npm config <span class="hljs-keyword">list</span></code></pre><h4 id="3、npm-install命令的使用"><a href="#3、npm-install命令的使用" class="headerlink" title="3、npm install命令的使用"></a><strong>3、npm install命令的使用</strong></h4><p>基本命令</p><pre><code class="hljs vala"><span class="hljs-meta">#使用 npm install 安装依赖包的最新版，</span><span class="hljs-meta">#模块安装的位置：项目目录\node_modules</span><span class="hljs-meta">#同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 &lt;dependencies&gt;</span><span class="hljs-meta">#默认参数：--save  简写  -S  将当前依赖保存在dependencies节点下</span>npm install jquery</code></pre><p>下载特定版本的依赖</p><pre><code class="hljs angelscript">#如果安装时想指定特定的版本npm install <span class="hljs-symbol">jquery@</span><span class="hljs-number">2.1</span>.x</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>下载开发依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖</span><span class="hljs-meta">#使用 -D参数将依赖添加到devDependencies节点</span>npm install --save-dev eslint<span class="hljs-meta">#或简写</span>npm i -D eslint</code></pre><p>下载全局依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#全局安装</span><span class="hljs-meta">#Node.js全局安装的npm包和工具的位置：用户目录\AppData\Roaming\npm\node_modules</span><span class="hljs-meta">#一些命令行工具常使用全局安装的方式</span>npm install --global webpack<span class="hljs-meta">#或简写</span>npm install -g webpack</code></pre><p>根据依赖下载安装包</p><pre><code class="hljs cmake"><span class="hljs-comment">#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹</span><span class="hljs-comment">#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本</span>npm <span class="hljs-keyword">install</span> <span class="hljs-comment">#根据package.json中的配置下载依赖，初始化项目</span></code></pre><h4 id="4、其它命令"><a href="#4、其它命令" class="headerlink" title="4、其它命令"></a><strong>4、其它命令</strong></h4><pre><code class="hljs coffeescript"><span class="hljs-comment">#更新包（更新到最新版本）</span><span class="hljs-built_in">npm</span> update 包名<span class="hljs-comment">#全局更新</span><span class="hljs-built_in">npm</span> update -g 包名<span class="hljs-comment">#卸载包</span><span class="hljs-built_in">npm</span> uninstall 包名<span class="hljs-comment">#全局卸载</span><span class="hljs-built_in">npm</span> uninstall -g 包名</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】非业务功能统一处理</title>
    <link href="/2020/07/08/goujian/6.%E9%9D%9E%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/"/>
    <url>/2020/07/08/goujian/6.%E9%9D%9E%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】非业务功能统一处理"><a href="#【项目创建流程】非业务功能统一处理" class="headerlink" title="【项目创建流程】非业务功能统一处理"></a>【项目创建流程】非业务功能统一处理</h1><h2 id="统一返回数据格式"><a href="#统一返回数据格式" class="headerlink" title="统一返回数据格式"></a>统一返回数据格式</h2><p>项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p><p>例如，我们的系统要求返回的基本数据格式如下：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"code"</span>: <span class="hljs-number">20000</span>,  <span class="hljs-attr">"message"</span>: <span class="hljs-string">"成功"</span>,  <span class="hljs-attr">"data"</span>: &#123;    <span class="hljs-attr">"items"</span>: [      &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1"</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"刘德华"</span>,        <span class="hljs-attr">"intro"</span>: <span class="hljs-string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      &#125;    ]  &#125;&#125;</code></pre><h3 id="定义统一返回结果"><a href="#定义统一返回结果" class="headerlink" title="定义统一返回结果"></a>定义统一返回结果</h3><h4 id="创建返回码定义枚举类"><a href="#创建返回码定义枚举类" class="headerlink" title="创建返回码定义枚举类"></a>创建返回码定义枚举类</h4><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ResultCodeEnum &#123;    SUCCESS(<span class="hljs-keyword">true</span>, <span class="hljs-number">20000</span>,<span class="hljs-string">"成功"</span>),    UNKNOWN_REASON(<span class="hljs-keyword">false</span>, <span class="hljs-number">20001</span>, <span class="hljs-string">"未知错误"</span>),    BAD_SQL_GRAMMAR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21001</span>, <span class="hljs-string">"sql语法错误"</span>),    JSON_PARSE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21002</span>, <span class="hljs-string">"json解析异常"</span>),    PARAM_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21003</span>, <span class="hljs-string">"参数不正确"</span>),    FILE_UPLOAD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21004</span>, <span class="hljs-string">"文件上传错误"</span>),    FILE_DELETE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21005</span>, <span class="hljs-string">"文件刪除错误"</span>),    EXCEL_DATA_IMPORT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21006</span>, <span class="hljs-string">"Excel数据导入错误"</span>),    VIDEO_UPLOAD_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22001</span>, <span class="hljs-string">"视频上传至阿里云失败"</span>),    VIDEO_UPLOAD_TOMCAT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22002</span>, <span class="hljs-string">"视频上传至业务服务器失败"</span>),    VIDEO_DELETE_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22003</span>, <span class="hljs-string">"阿里云视频文件删除失败"</span>),    FETCH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22004</span>, <span class="hljs-string">"获取上传地址和凭证失败"</span>),    REFRESH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22005</span>, <span class="hljs-string">"刷新上传地址和凭证失败"</span>),    FETCH_PLAYAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22006</span>, <span class="hljs-string">"获取播放凭证失败"</span>),    URL_ENCODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23001</span>, <span class="hljs-string">"URL编码失败"</span>),    ILLEGAL_CALLBACK_REQUEST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23002</span>, <span class="hljs-string">"非法回调请求"</span>),    FETCH_ACCESSTOKEN_FAILD(<span class="hljs-keyword">false</span>, <span class="hljs-number">23003</span>, <span class="hljs-string">"获取accessToken失败"</span>),    FETCH_USERINFO_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23004</span>, <span class="hljs-string">"获取用户信息失败"</span>),    LOGIN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23005</span>, <span class="hljs-string">"登录失败"</span>),    COMMENT_EMPTY(<span class="hljs-keyword">false</span>, <span class="hljs-number">24006</span>, <span class="hljs-string">"评论内容必须填写"</span>),    PAY_RUN(<span class="hljs-keyword">false</span>, <span class="hljs-number">25000</span>, <span class="hljs-string">"支付中"</span>),    PAY_UNIFIEDORDER_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25001</span>, <span class="hljs-string">"统一下单错误"</span>),    PAY_ORDERQUERY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25002</span>, <span class="hljs-string">"查询支付结果错误"</span>),    ORDER_EXIST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25003</span>, <span class="hljs-string">"课程已购买"</span>),    GATEWAY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">26000</span>, <span class="hljs-string">"服务不能访问"</span>),    CODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28000</span>, <span class="hljs-string">"验证码错误"</span>),    LOGIN_PHONE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28009</span>, <span class="hljs-string">"手机号码不正确"</span>),    LOGIN_MOBILE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28001</span>, <span class="hljs-string">"账号不正确"</span>),    LOGIN_PASSWORD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28008</span>, <span class="hljs-string">"密码不正确"</span>),    LOGIN_DISABLED_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28002</span>, <span class="hljs-string">"该用户已被禁用"</span>),    REGISTER_MOBLE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28003</span>, <span class="hljs-string">"手机号已被注册"</span>),    LOGIN_AUTH(<span class="hljs-keyword">false</span>, <span class="hljs-number">28004</span>, <span class="hljs-string">"需要登录"</span>),    LOGIN_ACL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28005</span>, <span class="hljs-string">"没有权限"</span>),    SMS_SEND_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28006</span>, <span class="hljs-string">"短信发送失败"</span>),    SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28007</span>, <span class="hljs-string">"短信发送过于频繁"</span>);    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String message;    ResultCodeEnum(Boolean success, Integer code, String message) &#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;&#125;</code></pre><h4 id="创建结果类"><a href="#创建结果类" class="headerlink" title="创建结果类"></a>创建结果类</h4><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel</span>(value = <span class="hljs-string">"全局统一返回结果"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">R</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"是否成功"</span>)    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回码"</span>)    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回消息"</span>)    <span class="hljs-keyword">private</span> String message;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回数据"</span>)    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">R</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">ok</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());        r.setCode(ResultCodeEnum.SUCCESS.getCode());        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">error</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());        r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());        r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">setResult</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(resultCodeEnum.getSuccess());        r.setCode(resultCodeEnum.getCode());        r.setMessage(resultCodeEnum.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">success</span><span class="hljs-params">(Boolean success)</span></span>&#123;        <span class="hljs-keyword">this</span>.setSuccess(success);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">message</span><span class="hljs-params">(String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.setMessage(message);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">code</span><span class="hljs-params">(Integer code)</span></span>&#123;        <span class="hljs-keyword">this</span>.setCode(code);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(String key, Object value)</span></span>&#123;        <span class="hljs-keyword">this</span>.data.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;        <span class="hljs-keyword">this</span>.setData(map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;    List&lt;Teacher&gt; list = teacherService.list();    <span class="hljs-keyword">return</span> R.ok().data(<span class="hljs-string">"items"</span>, list).message(<span class="hljs-string">"获取讲师列表成功"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"remove/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">removeById</span><span class="hljs-params">(@PathVariable String id)</span></span>&#123;    <span class="hljs-keyword">boolean</span> result = teacherService.removeById(id);    <span class="hljs-keyword">if</span>(result)&#123;        <span class="hljs-keyword">return</span> R.ok().message(<span class="hljs-string">"删除成功"</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> R.error().message(<span class="hljs-string">"数据不存在"</span>);    &#125;&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="Controller创建分页方法"><a href="#Controller创建分页方法" class="headerlink" title="Controller创建分页方法"></a>Controller创建分页方法</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list/&#123;page&#125;/&#123;limit&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listPage</span><span class="hljs-params">(@ApiParam(value = <span class="hljs-string">"当前页码"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long page,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(value = <span class="hljs-string">"每页记录数"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long limit,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(<span class="hljs-string">"讲师列表查询对象"</span>)</span> TeacherQueryVo teacherQueryVo)</span>&#123;    IPage&lt;Teacher&gt; pageModel = teacherService.selectPage(page, limit, teacherQueryVo);    List&lt;Teacher&gt; records = pageModel.getRecords();    <span class="hljs-keyword">long</span> total = pageModel.getTotal();    <span class="hljs-keyword">return</span>  R.ok().data(<span class="hljs-string">"total"</span>, total).data(<span class="hljs-string">"rows"</span>, records);&#125;</code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><blockquote><p>在我们平时写项目的时候，一般查询数据字段可能只需要三四个，但是数据库里面有十多个，甚至多数据库，多表查询</p><p>这时候就要根据返回类型创建Vo对象</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherQueryVo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;        <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer level;    <span class="hljs-keyword">private</span> String joinDateBegin;    <span class="hljs-keyword">private</span> String joinDateEnd;&#125;</code></pre><blockquote><p>创建完实体类，就需要写条件查询了</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.service.impl;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TeacherMapper</span>, <span class="hljs-title">Teacher</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TeacherService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;Teacher&gt; <span class="hljs-title">selectPage</span><span class="hljs-params">(Long page, Long limit, TeacherQueryVo teacherQueryVo)</span> </span>&#123;                Page&lt;Teacher&gt; pageParam = <span class="hljs-keyword">new</span> Page&lt;&gt;(page, limit);                QueryWrapper&lt;Teacher&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();        queryWrapper.orderByAsc(<span class="hljs-string">"sort"</span>);        <span class="hljs-keyword">if</span> (teacherQueryVo == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);        &#125;        String name = teacherQueryVo.getName();        Integer level = teacherQueryVo.getLevel();        String begin = teacherQueryVo.getJoinDateBegin();        String end = teacherQueryVo.getJoinDateEnd();        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(name)) &#123;            <span class="hljs-comment">//左%会使索引失效</span>            queryWrapper.likeRight(<span class="hljs-string">"name"</span>, name);        &#125;        <span class="hljs-keyword">if</span> (level != <span class="hljs-keyword">null</span>) &#123;            queryWrapper.eq(<span class="hljs-string">"level"</span>, level);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(begin)) &#123;            queryWrapper.ge(<span class="hljs-string">"join_date"</span>, begin);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(end)) &#123;            queryWrapper.le(<span class="hljs-string">"join_date"</span>, end);        &#125;        <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);    &#125;&#125;</code></pre><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理</p><h3 id="创建统一异常处理器"><a href="#创建统一异常处理器" class="headerlink" title="创建统一异常处理器"></a>创建统一异常处理器</h3><blockquote><p>一般创建在service-base中handler包中，</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> R.error();    &#125;&#125;</code></pre><blockquote><p>例如上面就可以捕获所有异常</p><p>但是在实际项目中，可以通过抛出指定异常，然后捕获自定义异常来返回异常信息</p></blockquote><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h2 id="1、创建自定义异常类"><a href="#1、创建自定义异常类" class="headerlink" title="1、创建自定义异常类"></a><strong>1、创建自定义异常类</strong></h2><p>service-base模块中创建cn.jimu98.guli.service.base.exception包，</p><p>创建GuliException.java通用异常类 继承 RuntimeException，RuntimeException 对代码没有侵入性</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuliException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-comment">//状态码</span>    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接受状态码和消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(Integer code, String message)</span> </span>&#123;        <span class="hljs-keyword">super</span>(message);        <span class="hljs-keyword">this</span>.code=code;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接收枚举类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resultCodeEnum</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCodeEnum.getMessage());        <span class="hljs-keyword">this</span>.code = resultCodeEnum.getCode();    &#125;&#125;</code></pre><h2 id="2、添加异常处理方法"><a href="#2、添加异常处理方法" class="headerlink" title="2、添加异常处理方法"></a>2、添加异常处理方法</h2><p>GlobalExceptionHandler.java中添加</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(GuliException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">GuliException</span> <span class="hljs-title">e</span>)</span>&#123;    log.error(ExceptionUtils.getMessage(e));    <span class="hljs-keyword">return</span> R.error().message(e.getMessage()).code(e.getCode());&#125;</code></pre><h2 id="3、修改FileController"><a href="#3、修改FileController" class="headerlink" title="3、修改FileController"></a>3、修改FileController</h2><p>在类上添加日志注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j</code></pre><p>业务中需要的位置抛出GuliException</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">upload</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        ......    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;        log.error(ExceptionUtils.getMessage(e));        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GuliException(ResultCodeEnum.FILE_UPLOAD_ERROR);    &#125;&#125;</code></pre><h2 id="4、打印完整的异常信息"><a href="#4、打印完整的异常信息" class="headerlink" title="4、打印完整的异常信息"></a>4、打印完整的异常信息</h2><p>GuliException类中重写toString方法</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"GuliException&#123;"</span> +        <span class="hljs-string">"code="</span> + code +        <span class="hljs-string">", message="</span> + <span class="hljs-keyword">this</span>.getMessage() +        <span class="hljs-string">'&#125;'</span>;&#125;</code></pre><h2 id="三、前端错误处理"><a href="#三、前端错误处理" class="headerlink" title="三、前端错误处理"></a>三、前端错误处理</h2><h2 id="1、统一异常错误处理"><a href="#1、统一异常错误处理" class="headerlink" title="1、统一异常错误处理"></a>1、统一异常错误处理</h2><pre><code class="hljs stylus"><span class="hljs-comment">// 上传成功回调</span><span class="hljs-function"><span class="hljs-title">handleAvatarSuccess</span><span class="hljs-params">(res, file)</span></span> &#123;    console.log(res)    <span class="hljs-keyword">if</span> (res.success) &#123;        <span class="hljs-comment">// console.log(res)</span>        this<span class="hljs-selector-class">.teacher</span><span class="hljs-selector-class">.avatar</span> = res<span class="hljs-selector-class">.data</span>.url        <span class="hljs-comment">// 强制重新渲染</span>        this.<span class="hljs-variable">$forceUpdate</span>()    &#125; <span class="hljs-keyword">else</span> &#123;        this.<span class="hljs-variable">$message</span>.error(<span class="hljs-string">'上传失败 （非20000）'</span>)    &#125;&#125;,</code></pre><h2 id="2、http异常错误处理"><a href="#2、http异常错误处理" class="headerlink" title="2、http异常错误处理"></a>2、http异常错误处理</h2><p>注册事件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span> <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"handleAvatarError"</span>&gt;</span></code></pre><p>事件函数</p><pre><code class="hljs js"><span class="hljs-comment">// 错误处理</span>handleAvatarError() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>)    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'上传失败（http失败）'</span>)&#125;</code></pre><h2 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h2><h3 id="配置日志级别"><a href="#配置日志级别" class="headerlink" title="配置日志级别"></a>配置日志级别</h3><p>日志记录器（Logger）的行为是分等级的。如下表所示：</p><p>分为：FATAL、ERROR、WARN、INFO、DEBUG</p><p>默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别</p><pre><code class="hljs yaml"><span class="hljs-comment"># 设置日志级别</span><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">root:</span> <span class="hljs-string">ERROR</span></code></pre><p>这种方式能将ERROR级别以及以上级别的日志打印在控制台上</p><h3 id="Logback日志"><a href="#Logback日志" class="headerlink" title="Logback日志"></a>Logback日志</h3><p>spring boot内部使用Logback作为日志实现的框架。</p><p>Logback和log4j非常相似，如果你对log4j很熟悉，那对logback很快就会得心应手。</p><p>logback相对于log4j的一些优点：<a href="https://blog.csdn.net/caisini_vc/article/details/48551287" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/48551287</a></p><h4 id="配置logback日志"><a href="#配置logback日志" class="headerlink" title="配置logback日志"></a>配置logback日志</h4><p><strong>删除application.yml中的日志配置</strong></p><p><strong>安装idea彩色日志插件：grep console</strong></p><p>resources 中创建 logback-spring.xml （默认日志的名字，必须是这个名字）</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>  <span class="hljs-attr">scan</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">"10 seconds"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>logback<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"log.path"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"D:/project/helen/guli_log/edu"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--控制台日志格式：彩色日志--&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-comment">&lt;!-- boldMagenta:粗红--&gt;</span>    <span class="hljs-comment">&lt;!-- cyan:青色 --&gt;</span>    <span class="hljs-comment">&lt;!-- white:白色 --&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--文件日志格式--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss&#125; |%-5level |%thread |%file:%line |%logger |%msg%n"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ENCODING"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志级别--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志格式--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志字符集--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"INFO_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志过滤器：此日志文件只记录INFO级别的--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"WARN_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录WARN级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ERROR_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录ERROR级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--开发环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>        <span class="hljs-comment">&lt;!--可以灵活设置此处，从而控制日志的输出--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"WARN_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!--生产环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pro"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"ERROR"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h4 id="用日志记录器记录错误日志"><a href="#用日志记录器记录错误日志" class="headerlink" title="用日志记录器记录错误日志"></a>用日志记录器记录错误日志</h4><blockquote><p>类上添加注解@Slf4j</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>统一处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】配置Swagger</title>
    <link href="/2020/07/08/goujian/5.%E9%85%8D%E7%BD%AESwagger/"/>
    <url>/2020/07/08/goujian/5.%E9%85%8D%E7%BD%AESwagger/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】配置Swagger"><a href="#【项目创建流程】配置Swagger" class="headerlink" title="【项目创建流程】配置Swagger"></a>【项目创建流程】配置Swagger</h1><h2 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h2><p><a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>前后端分离开发模式中，api文档是最好的沟通方式。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)可测性 (直接在接口文档上进行测试，以方便理解业务)</p><ul><li>前端工程师编写接口文档（使用swagger2编辑器或其他接口生成工具）</li><li>交给后端工程师</li><li>根据swagger文档编写后端接口</li><li>最终根据生成的swagger文件进行接口联调</li></ul><h2 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>这个可以配置在common中  进行代码复用</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--swagger--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="创建Swagger2配置文件"><a href="#创建Swagger2配置文件" class="headerlink" title="创建Swagger2配置文件"></a>创建Swagger2配置文件</h3><blockquote><p>在service_base中创建Swagger2Config</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">webApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"webApi"</span>)                .apiInfo(webApiInfo())                .select()                <span class="hljs-comment">//只显示api路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/api/.*"</span>)))                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">adminApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"adminApi"</span>)                .apiInfo(adminApiInfo())                .select()                <span class="hljs-comment">//只显示admin路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/admin/.*"</span>)))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">webApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"网站前台-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了网站微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">adminApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"后台管理系统-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了后台管理系统微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p><a href="http://localhost:8101/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8101/swagger-ui.html</a>  进行测试</p></blockquote><h3 id="定义接口说明和参数说明"><a href="#定义接口说明和参数说明" class="headerlink" title="定义接口说明和参数说明"></a>定义接口说明和参数说明</h3><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>Swagger2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】普通接口开发</title>
    <link href="/2020/07/08/goujian/4.%E6%99%AE%E9%80%9A%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"/>
    <url>/2020/07/08/goujian/4.%E6%99%AE%E9%80%9A%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】普通接口开发"><a href="#【项目创建流程】普通接口开发" class="headerlink" title="【项目创建流程】普通接口开发"></a>【项目创建流程】普通接口开发</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><blockquote><p>创建的时候选择utf8mb4  urf8修改了兼容四字节的字符，解决某些汉字出现乱码问题</p><p>utf8_general_ci: 校对速度快，但准确度稍差。</p><p>utf8_unicode_ci: 准确度高，但校对速度稍慢。</p><p>若数据库中有德语、法语或者俄语需求，需使用utf8_unicode_ci。其他情况用utf8_general_ci即可。</p></blockquote><h2 id="建Maven"><a href="#建Maven" class="headerlink" title="建Maven"></a>建Maven</h2><h2 id="改POM"><a href="#改POM" class="headerlink" title="改POM"></a>改POM</h2><h2 id="写YML"><a href="#写YML" class="headerlink" title="写YML"></a>写YML</h2><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8140</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-cms</span> <span class="hljs-comment"># 服务名</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>          <span class="hljs-attr">datasource:</span> <span class="hljs-comment"># mysql数据库连接</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/guli_cms?serverTimezone=GMT%2B8</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">jackson:</span> <span class="hljs-comment">#返回json的全局时间格式</span>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment">#mybatis日志</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:cn/jimu98/guli/service/cms/mapper/xml/*.xml</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h2 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h2><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ComponentScan</span>(&#123;<span class="hljs-string">"cn.jimu98.guli"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceEduApplication</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceEduApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h2><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span> <span class="hljs-comment">//解决跨域问题</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/edu/teacher"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TeacherService teacherService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> teacherService.list();    &#125;&#125;</code></pre><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><blockquote><p>项目经理不让用就自己写吧。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】MyBatisPlas流程</title>
    <link href="/2020/07/08/goujian/3.MyBatisPlas%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/07/08/goujian/3.MyBatisPlas%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】MyBatisPlas流程"><a href="#【项目创建流程】MyBatisPlas流程" class="headerlink" title="【项目创建流程】MyBatisPlas流程"></a>【项目创建流程】MyBatisPlas流程</h1><h2 id="MP简介"><a href="#MP简介" class="headerlink" title="MP简介"></a>MP简介</h2><p><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><ul><li><p>润物无声  </p></li><li><ul><li>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li></ul></li><li><p>效率至上</p></li><li><ul><li>只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。</li></ul></li><li><p>丰富功能</p></li><li><ul><li>热加载、代码生成、分页、性能分析等功能一应俱全。</li></ul></li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><h3 id="创建代码生成器"><a href="#创建代码生成器" class="headerlink" title="创建代码生成器"></a>创建代码生成器</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//String prefix = "dbxxx_";</span>        String moduleName = <span class="hljs-string">"statistics"</span>;        <span class="hljs-comment">// 1、创建代码生成器</span>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();        <span class="hljs-comment">// 2、全局配置</span>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">"user.dir"</span>);        gc.setOutputDir(projectPath + <span class="hljs-string">"/src/main/java"</span>);        gc.setAuthor(<span class="hljs-string">"jimu98"</span>);        gc.setOpen(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//生成后是否打开资源管理器</span><span class="hljs-comment">//        gc.setFileOverride(false); //重新生成时文件是否覆盖</span>        gc.setServiceName(<span class="hljs-string">"%sService"</span>);<span class="hljs-comment">//去掉Service接口的首字母I</span>        gc.setIdType(IdType.ASSIGN_ID); <span class="hljs-comment">//主键策略</span>        gc.setDateType(DateType.ONLY_DATE);<span class="hljs-comment">//定义生成的实体类中日期类型</span>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启Swagger2模式</span>        mpg.setGlobalConfig(gc);        <span class="hljs-comment">// 3、数据源配置</span>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();        dsc.setUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/"</span>  + <span class="hljs-string">"guli_"</span> + moduleName + <span class="hljs-string">"?serverTimezone=GMT%2B8"</span>);        dsc.setDriverName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);        dsc.setUsername(<span class="hljs-string">"root"</span>);        dsc.setPassword(<span class="hljs-string">""</span>);        dsc.setDbType(DbType.MYSQL);        mpg.setDataSource(dsc);        <span class="hljs-comment">// 4、包配置</span>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();        pc.setModuleName(moduleName); <span class="hljs-comment">//模块名</span>        pc.setParent(<span class="hljs-string">"cn.jimu98.guli.service"</span>);        pc.setController(<span class="hljs-string">"controller"</span>);        pc.setEntity(<span class="hljs-string">"entity"</span>);        pc.setService(<span class="hljs-string">"service"</span>);        pc.setMapper(<span class="hljs-string">"mapper"</span>);        mpg.setPackageInfo(pc);        <span class="hljs-comment">// 5、策略配置</span>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表映射到实体的命名策略</span>        strategy.setTablePrefix(moduleName + <span class="hljs-string">"_"</span>);<span class="hljs-comment">//设置表前缀不生成</span>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表字段映射到实体的命名策略</span>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy.setLogicDeleteFieldName(<span class="hljs-string">"is_deleted"</span>);<span class="hljs-comment">//逻辑删除字段名</span>        strategy.setEntityBooleanColumnRemoveIsPrefix(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//去掉布尔值的is_前缀</span>        <span class="hljs-comment">//自动填充</span>        TableFill gmtCreate = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_create"</span>, FieldFill.INSERT);        TableFill gmtModified = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_modified"</span>, FieldFill.INSERT_UPDATE);        ArrayList&lt;TableFill&gt; tableFills = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        tableFills.add(gmtCreate);        tableFills.add(gmtModified);        strategy.setTableFillList(tableFills);        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//restful api风格控制器</span>        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//url中驼峰转连字符</span>        mpg.setStrategy(strategy);        <span class="hljs-comment">//设置BaseEntity</span>        strategy.setSuperEntityClass(<span class="hljs-string">"cn.jimu98.guli.service.base.model.BaseEntity"</span>);        <span class="hljs-comment">// 填写BaseEntity中的公共字段</span>        strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);        <span class="hljs-comment">// 6、执行</span>        mpg.execute();    &#125;&#125;</code></pre><h3 id="优化代码生成器"><a href="#优化代码生成器" class="headerlink" title="优化代码生成器"></a>优化代码生成器</h3><blockquote><p>在真实情况下，每个表都会有三字段，ID，创建时间，更新时间</p><p>所以，这部分实体类可以抽取出来</p><p>一般我们在service_base中创建BaseEntity</p></blockquote><h4 id="首先创建一个基础实体类"><a href="#首先创建一个基础实体类" class="headerlink" title="首先创建一个基础实体类"></a>首先创建一个基础实体类</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.jimu98.service.base.model;<span class="hljs-meta">@Data</span><span class="hljs-meta">@EqualsAndHashCode</span>(callSuper = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@Accessors</span>(chain = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID=<span class="hljs-number">1L</span>;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"讲师ID"</span>)  <span class="hljs-comment">//这个是swagger的注解</span>    <span class="hljs-meta">@TableId</span>(value = <span class="hljs-string">"id"</span>, type = IdType.ASSIGN_ID)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"创建时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT)    <span class="hljs-keyword">private</span> Date gmtCreate;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"更新时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)    <span class="hljs-keyword">private</span> Date gmtModified;&#125;</code></pre><h4 id="然后修改代码生成器中内容"><a href="#然后修改代码生成器中内容" class="headerlink" title="然后修改代码生成器中内容"></a>然后修改代码生成器中内容</h4><pre><code class="hljs java"><span class="hljs-comment">//设置BaseEntity</span>strategy.setSuperEntityClass(<span class="hljs-string">"com.atguigu.guli.service.base.model.BaseEntity"</span>);<span class="hljs-comment">// 填写BaseEntity中的公共字段</span>strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><blockquote><p>@TableId(type = IdType.ASSIGN_ID)</p></blockquote><ul><li>描述：主键注解</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">主键字段名</td></tr><tr><td align="center">type</td><td align="center">Enum</td><td align="center">否</td><td align="center">IdType.NONE</td><td align="center">主键类型</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AUTO</td><td align="center">数据库ID自增</td></tr><tr><td align="center">NONE</td><td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td></tr><tr><td align="center">INPUT</td><td align="center">insert前自行set主键值</td></tr><tr><td align="center">ASSIGN_ID</td><td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td align="center">ASSIGN_UUID</td><td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td></tr><tr><td align="center">ID_WORKER</td><td align="center">分布式全局唯一ID 长整型类型(please use <code>ASSIGN_ID</code>)</td></tr><tr><td align="center">UUID</td><td align="center">32位UUID字符串(please use <code>ASSIGN_UUID</code>)</td></tr><tr><td align="center">ID_WORKER_STR</td><td align="center">分布式全局唯一ID 字符串类型(please use <code>ASSIGN_ID</code>)</td></tr></tbody></table><p>要想影响所有实体的配置，可以设置全局主键配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#全局设置主键生成策略</span><span class="hljs-string">mybatis-plus.global-config.db-config.id-type=auto</span></code></pre><blockquote><p>@TableField  </p></blockquote><ul><li>描述：字段注解(非主键)</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">数据库字段名</td></tr><tr><td align="center">el</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">映射为原生 <code>#{ ... }</code> 逻辑,相当于写在 xml 里的 <code>#{ ... }</code> 部分</td></tr><tr><td align="center">exist</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否为数据库表字段</td></tr><tr><td align="center">condition</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>where</code> 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 <code>% s=#{ %s }</code>,<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java" target="_blank" rel="noopener">参考</a></td></tr><tr><td align="center">update</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>update set</code> 部分注入, 例如：update=”%s+1”：表示更新时会set version=version+1(该属性优先级高于 <code>el</code> 属性)</td></tr><tr><td align="center">insertStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#{columnProperty}&lt;/if&gt;)</code></td></tr><tr><td align="center">updateStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：IGNORED: <code>update table_a set column=#{columnProperty}</code></td></tr><tr><td align="center">whereStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#{columnProperty}&lt;/if&gt;</code></td></tr><tr><td align="center">fill</td><td align="center">Enum</td><td align="center">否</td><td align="center">FieldFill.DEFAULT</td><td align="center">字段自动填充策略</td></tr><tr><td align="center">select</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否进行 select 查询</td></tr><tr><td align="center">keepGlobalFormat</td><td align="center">boolean</td><td align="center">否</td><td align="center">false</td><td align="center">是否保持使用全局的 format 进行处理</td></tr><tr><td align="center">jdbcType</td><td align="center">JdbcType</td><td align="center">否</td><td align="center">JdbcType.UNDEFINED</td><td align="center">JDBC类型 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">typeHandler</td><td align="center">Class&lt;? extends TypeHandler&gt;</td><td align="center">否</td><td align="center">UnknownTypeHandler.class</td><td align="center">类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">numericScale</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">指定小数点后保留的位数</td></tr></tbody></table><blockquote><p>另外这个注解的包可能不会自动引入，有个小BUG，所以需要手动引入一下,其他的就看官方文档吧</p></blockquote><h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><blockquote><p>这个主要是为create_time、update_time进行自动填充</p></blockquote><h4 id="实体类修改"><a href="#实体类修改" class="headerlink" title="实体类修改"></a>实体类修改</h4><p>在实体类（如果前面提取了公共实体类，那么这里操作公共实体类）添加注解@TableField(fill = FieldFill.INSERT)</p><p>FieldFill是一个enum 枚举类型 </p><p>所以create_time设置INSERT  ，update_time设置 INSERT_UPDATE</p><h4 id="实现元对象处理器接口"><a href="#实现元对象处理器接口" class="headerlink" title="实现元对象处理器接口"></a>实现元对象处理器接口</h4><p><strong><code>注意：不要忘记添加 @Component 注解</code></strong></p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start insert fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"createTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start update fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;&#125;</code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h4><pre><code class="hljs java"><span class="hljs-meta">@Version</span><span class="hljs-keyword">private</span> Integer version;</code></pre><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"cn.jimu98.xxx.mapper"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;    &#125;</code></pre><h4 id="注册乐观锁插件"><a href="#注册乐观锁插件" class="headerlink" title="注册乐观锁插件"></a>注册乐观锁插件</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 乐观锁插件</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();&#125;</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页插件</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();&#125;</code></pre><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><h4 id="数据库修改"><a href="#数据库修改" class="headerlink" title="数据库修改"></a>数据库修改</h4><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`deleted`</span> <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span></code></pre><h4 id="实体类修改-1"><a href="#实体类修改-1" class="headerlink" title="实体类修改"></a>实体类修改</h4><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><span class="hljs-keyword">private</span> Integer deleted;</code></pre><h4 id="配置（可选）"><a href="#配置（可选）" class="headerlink" title="配置（可选）"></a>配置（可选）</h4><pre><code class="hljs yaml"><span class="hljs-string">mybatis-plus.global-config.db-config.logic-delete-value=1</span><span class="hljs-string">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span></code></pre><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><table><thead><tr><th><strong>查询方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>setSqlSelect</strong></td><td>设置 SELECT 查询字段</td></tr><tr><td><strong>where</strong></td><td>WHERE 语句，拼接 + WHERE 条件</td></tr><tr><td><strong>and</strong></td><td>AND 语句，拼接 + AND 字段=值</td></tr><tr><td><strong>andNew</strong></td><td>AND 语句，拼接 + AND (字段=值)</td></tr><tr><td><strong>or</strong></td><td>OR 语句，拼接 + OR 字段=值</td></tr><tr><td><strong>orNew</strong></td><td>OR 语句，拼接 + OR (字段=值)</td></tr><tr><td><strong>eq</strong></td><td>等于=</td></tr><tr><td><strong>allEq</strong></td><td>基于 map 内容等于=</td></tr><tr><td><strong>ne</strong></td><td>不等于&lt;&gt;</td></tr><tr><td><strong>gt</strong></td><td>大于&gt;</td></tr><tr><td><strong>ge</strong></td><td>大于等于&gt;=</td></tr><tr><td><strong>lt</strong></td><td>小于&lt;</td></tr><tr><td><strong>le</strong></td><td>小于等于&lt;=</td></tr><tr><td><strong>like</strong></td><td>模糊查询 LIKE</td></tr><tr><td><strong>notLike</strong></td><td>模糊查询 NOT LIKE</td></tr><tr><td><strong>in</strong></td><td>IN 查询</td></tr><tr><td><strong>notIn</strong></td><td>NOT IN 查询</td></tr><tr><td><strong>isNull</strong></td><td>NULL 值查询</td></tr><tr><td><strong>isNotNull</strong></td><td>IS NOT NULL</td></tr><tr><td><strong>groupBy</strong></td><td>分组 GROUP BY</td></tr><tr><td><strong>having</strong></td><td>HAVING 关键词</td></tr><tr><td><strong>orderBy</strong></td><td>排序 ORDER BY</td></tr><tr><td><strong>orderAsc</strong></td><td>ASC 排序 ORDER BY</td></tr><tr><td><strong>orderDesc</strong></td><td>DESC 排序 ORDER BY</td></tr><tr><td><strong>exists</strong></td><td>EXISTS 条件语句</td></tr><tr><td><strong>notExists</strong></td><td>NOT EXISTS 条件语句</td></tr><tr><td><strong>between</strong></td><td>BETWEEN 条件语句</td></tr><tr><td><strong>notBetween</strong></td><td>NOT BETWEEN 条件语句</td></tr><tr><td><strong>addFilter</strong></td><td>自由拼接 SQL</td></tr><tr><td><strong>last</strong></td><td>拼接在最后，例如：last(“LIMIT 1”)</td></tr></tbody></table><p>其他的就看官网吧<a href="https://mp.baomidou.com/guide/wrapper.html#abstractwrapper" target="_blank" rel="noopener">https://mp.baomidou.com/guide/wrapper.html#abstractwrapper</a></p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
      <tag>MyBatis-Plus</tag>
      
      <tag>代码生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】项目框架构建</title>
    <link href="/2020/07/08/goujian/2.%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/07/08/goujian/2.%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】项目框架构建"><a href="#【项目创建流程】项目框架构建" class="headerlink" title="【项目创建流程】项目框架构建"></a>【项目创建流程】项目框架构建</h1><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><blockquote><p>在项目创建初期，应该首先规划一下工程结构</p><p>将各个模块区分开来（根据阿里规范命名）</p><p>重复的功能进行抽离</p><p>pom文件根据范围选择合适的引用地址</p></blockquote><h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><h4 id="删除一些无用的文件"><a href="#删除一些无用的文件" class="headerlink" title="删除一些无用的文件"></a>删除一些无用的文件</h4><h4 id="配置SpringBoot版本"><a href="#配置SpringBoot版本" class="headerlink" title="配置SpringBoot版本"></a>配置SpringBoot版本</h4><h4 id="配置Pom文件依赖版本号"><a href="#配置Pom文件依赖版本号" class="headerlink" title="配置Pom文件依赖版本号"></a>配置Pom文件依赖版本号</h4><p>比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis-plus.version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis-plus.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">velocity.version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">velocity.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">swagger.version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">swagger.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aliyun.oss.version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">aliyun.oss.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jodatime.version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">jodatime.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-fileupload.version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">commons-fileupload.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-io.version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">commons-io.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-lang.version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">commons-lang.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">httpclient.version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">httpclient.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre><h4 id="配置pom依赖"><a href="#配置pom依赖" class="headerlink" title="配置pom依赖"></a>配置pom依赖</h4><blockquote><p>这里不需要真正引入，在子项目中引入</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--Spring Cloud--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--mybatis-plus 持久层--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><h2 id="创建父模块"><a href="#创建父模块" class="headerlink" title="创建父模块"></a>创建父模块</h2><h3 id="创建普通Maven项目即可"><a href="#创建普通Maven项目即可" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h4 id="删除src文件夹"><a href="#删除src文件夹" class="headerlink" title="删除src文件夹"></a>删除src文件夹</h4><h4 id="配置POM"><a href="#配置POM" class="headerlink" title="配置POM"></a>配置POM</h4><blockquote><p>这里一般配置一下lombok mp，swagger之类的 以及子项目复用的依赖</p></blockquote><h2 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h2><h3 id="创建普通Maven项目即可-1"><a href="#创建普通Maven项目即可-1" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h3 id="配置Pom"><a href="#配置Pom" class="headerlink" title="配置Pom"></a>配置Pom</h3><h3 id="改YAM"><a href="#改YAM" class="headerlink" title="改YAM"></a>改YAM</h3><h3 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h3><h3 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h3><blockquote><p>看一下这个业务模块需不需要用代码生成器生成</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】数据库规范</title>
    <link href="/2020/07/08/goujian/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    <url>/2020/07/08/goujian/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】数据库规范"><a href="#【项目创建流程】数据库规范" class="headerlink" title="【项目创建流程】数据库规范"></a>【项目创建流程】数据库规范</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h2><blockquote><p>注意，这里要遵循阿里数据库设计规约（参考《阿里巴巴Java开发手册》）</p></blockquote><p>1、库名与应用名称尽量一致</p><p>2、表名、字段名必须使用小写字母或数字，禁止出现数字开头，</p><p>3、表名不使用复数名词</p><p>4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher</p><p>5、表必备三字段：id, gmt_create, gmt_modified</p><p>6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p><p>7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 </p><p>说明：任何字段如果为非负数，必须是 unsigned。</p><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 </p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 </p><p>8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p><p>9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 </p><p>10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>11、唯一索引名为 uk_字段名(unique key)；普通索引名则为 idx_字段名(index)。</p><p>说明：uk_ 即 unique key；idx_ 即 index 的简称</p><p>12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
