<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【剑指Offer】旋转数组的最小数字</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j=numbers.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;j) &#123;            <span class="hljs-keyword">int</span> mid=(i+j)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(numbers[mid]&gt;numbers[j])                i=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid]&lt;numbers[j])                j=mid;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> numbers[i];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>旋转数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】青蛙跳台问题</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：2<br>示例 2：</p><p>输入：n = 7<br>输出：21<br>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>其实这个题目就是斐波那契数列，但是用到了记忆化</p><p>这么一说  不就有点dp的味道了吗，对，没错。其实算法间没那么清晰的界限。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】斐波那契数列一</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：1<br>示例 2：</p><p>输入：n = 5<br>输出：5</p><p>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(N-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】用两个栈实现队列</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Deque&lt;Integer&gt; stack1;    Deque&lt;Integer&gt; stack2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();        stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        stack1.push(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果第二个栈为空，就把第一个全部倒进第二个</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;                stack2.push(stack1.pop());            &#125;        &#125;        <span class="hljs-comment">//判断第二个栈是否为空，空就返回-1</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> stack2.pop();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】重建二叉树</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>递归解法</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map &lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.length;i++)map.put(inorder[i],i);        <span class="hljs-keyword">return</span> dfs(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> pl,<span class="hljs-keyword">int</span> pr,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> il,<span class="hljs-keyword">int</span> ir)</span></span>&#123;        <span class="hljs-keyword">if</span>(pl&gt;pr)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[pl]);        <span class="hljs-keyword">int</span> k=map.get(root.val);        TreeNode left = dfs(preorder,pl+<span class="hljs-number">1</span>,pl+k-il,inorder,il,k-<span class="hljs-number">1</span>);        TreeNode right = dfs(preorder,pl+k-il+<span class="hljs-number">1</span>,pr,inorder,k+<span class="hljs-number">1</span>,ir);        root.left=left;        root.right=right;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】找出数组中重复的数字</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;  <span class="hljs-comment">//看题目要求，这一段可以不写</span>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span> || nums[i]&gt;n)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">while</span>(nums[i]!=i)&#123;                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<span class="hljs-keyword">return</span> nums[i];                swap(nums,i,nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp=nums[a];        nums[a]=nums[b];        nums[b]=tmp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】从尾到头打印链表</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;        List &lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            list.add(head.val);            head=head.next;        &#125;        <span class="hljs-keyword">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [list.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;            res[i]=list.get(res.length-<span class="hljs-number">1</span>-i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】替换空格</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = s.length();        <span class="hljs-keyword">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length * <span class="hljs-number">3</span>];        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">char</span> c = s.charAt(i);            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;                array[size++] = <span class="hljs-string">'%'</span>;                array[size++] = <span class="hljs-string">'2'</span>;                array[size++] = <span class="hljs-string">'0'</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                array[size++] = c;            &#125;        &#125;        String newStr = <span class="hljs-keyword">new</span> String(array, <span class="hljs-number">0</span>, size);  <span class="hljs-comment">//记住这种转换方法</span>        <span class="hljs-keyword">return</span> newStr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二维数组中的查找</title>
    <link href="/2020/07/10/%E5%89%91%E6%8C%87offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/07/10/%E5%89%91%E6%8C%87offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数target。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是遍历寻找，或者二分，但是这个题很取巧</p><p>比如我们将要求的数和右上角进行比较</p><p>如果右上角小于target，那么这一行所有的数小于target  也就是i++</p><p>如果右上角大于target，那么这一列所有的数都大于target   也就是j–</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;-<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(matrix[i][j]==target)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)i++;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
