<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>晚会互动大屏项目总结</title>
    <link href="/posts/59779/"/>
    <url>/posts/59779/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】晚会互动大屏项目总结"><a href="#【项目笔记】晚会互动大屏项目总结" class="headerlink" title="【项目笔记】晚会互动大屏项目总结"></a>【项目笔记】晚会互动大屏项目总结</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>河传助手是一款校园学习信息平台，提供超级课程表，情侣课表，教学通知，成绩查询，学生评教等一些校园功能。目前为校 区超过20000名学生提供服务，日活跃用户超过10000+。</p><h2 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h2><p><img src="https://img2.jimu98.cn/blog/20201020095355.png" srcset="/img/loading.gif" alt="image-20201020095355071"></p><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://img2.jimu98.cn/blog/20201020095623.png" srcset="/img/loading.gif" alt="image-20201020095623578"></p><h3 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h3><p><img src="https://img2.jimu98.cn/blog/20201020095707.png" srcset="/img/loading.gif" alt="image-20201020095706993"></p><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h3><img src="https://img2.jimu98.cn/blog/20201020100239.png" srcset="/img/loading.gif" alt="image-20201020100239696" style="zoom:30%;" /><h3 id="成绩查询"><a href="#成绩查询" class="headerlink" title="成绩查询"></a>成绩查询</h3><p><img src="https://img2.jimu98.cn/blog/20201020095813.png" srcset="/img/loading.gif" alt="image-20201020095813568"></p><h3 id="微信矩阵"><a href="#微信矩阵" class="headerlink" title="微信矩阵"></a>微信矩阵</h3><p><img src="https://img2.jimu98.cn/blog/20201020100355.png" srcset="/img/loading.gif" alt="image-20201020100355631"></p><h3 id="下学期课表"><a href="#下学期课表" class="headerlink" title="下学期课表"></a>下学期课表</h3><p><img src="https://img2.jimu98.cn/blog/20201020100430.png" srcset="/img/loading.gif" alt="image-20201020100430790"></p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p><img src="https://hcia.ywgzs.cn/api/img/xcxm.png" srcset="/img/loading.gif" alt="xcxm"></p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晚会互动大屏</tag>
      
      <tag>项目</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晚会互动大屏项目总结</title>
    <link href="/posts/59778/"/>
    <url>/posts/59778/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】晚会互动大屏项目总结"><a href="#【项目笔记】晚会互动大屏项目总结" class="headerlink" title="【项目笔记】晚会互动大屏项目总结"></a>【项目笔记】晚会互动大屏项目总结</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>晚会现场互动大屏是一款用于晚会，年会等现场活动气氛互动系统，分为前端（后台，大屏幕），后端，微信小程序端，大屏实时动态投放活动状态，留言等，用于烘托现场气氛。</p><h2 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h2><h3 id="前台（大屏幕）"><a href="#前台（大屏幕）" class="headerlink" title="前台（大屏幕）"></a>前台（大屏幕）</h3><p><img src="https://img2.jimu98.cn/blog/20201019122049.png" srcset="/img/loading.gif" alt="image-20201019122048969"></p><p><img src="https://img2.jimu98.cn/blog/20201019122403.png" srcset="/img/loading.gif" alt="image-20201019122403490"></p><p><img src="https://img2.jimu98.cn/blog/20201019122342.png" srcset="/img/loading.gif" alt="image-20201019122342437"></p><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><h4 id="场控管理"><a href="#场控管理" class="headerlink" title="场控管理"></a>场控管理</h4><p><img src="https://img2.jimu98.cn/blog/20201019121510.png" srcset="/img/loading.gif" alt="image-20201019121510010"></p><p>（界面切换后，前台不会直接刷新，会通过动态刷新方式更改布局）</p><h4 id="礼物管理"><a href="#礼物管理" class="headerlink" title="礼物管理"></a>礼物管理</h4><p><img src="https://img2.jimu98.cn/blog/20201019121532.png" srcset="/img/loading.gif" alt="image-20201019121532114"></p><h4 id="活动管理"><a href="#活动管理" class="headerlink" title="活动管理"></a>活动管理</h4><p><img src="https://img2.jimu98.cn/blog/20201019121322.png" srcset="/img/loading.gif" alt="image-20201019121321416"></p><h4 id="节目单管理"><a href="#节目单管理" class="headerlink" title="节目单管理"></a>节目单管理</h4><p><img src="https://img2.jimu98.cn/blog/20201019121412.png" srcset="/img/loading.gif" alt="image-20201019121411883"></p><h4 id="节目新建-amp-编辑"><a href="#节目新建-amp-编辑" class="headerlink" title="节目新建&amp;编辑"></a>节目新建&amp;编辑</h4><p><img src="https://img2.jimu98.cn/blog/20201019121400.png" srcset="/img/loading.gif" alt="image-20201019121400377"></p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><img src="https://img2.jimu98.cn/blog/20201019121556.png" srcset="/img/loading.gif" alt="image-20201019121556255"></p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><h4 id="首页活动选择"><a href="#首页活动选择" class="headerlink" title="首页活动选择"></a>首页活动选择</h4><p><img src="https://img2.jimu98.cn/blog/20201019121656.png" srcset="/img/loading.gif" alt="image-20201019121656070"></p><h4 id="活动界面"><a href="#活动界面" class="headerlink" title="活动界面"></a>活动界面</h4><p><img src="https://img2.jimu98.cn/blog/20201019121932.png" srcset="/img/loading.gif" alt="image-20201019121932434"></p><h4 id="我的礼物"><a href="#我的礼物" class="headerlink" title="我的礼物"></a>我的礼物</h4><p><img src="https://img2.jimu98.cn/blog/20201019122313.png" srcset="/img/loading.gif" alt="image-20201019122313069"></p><h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><p>所有微服务基于 <code>Spring Boot</code>、<code>Spring Cloud Alibaba</code>构建</p><p><img src="https://img2.jimu98.cn/blog/20201019173034.png" srcset="/img/loading.gif" alt="image-20201019173034653"></p><p>前端视图采用 <code>vue.js</code> + <code>elementUI</code> 产品界面。</p><p>屏幕使用是 DataV用来做基础模板  </p><p>文档链接 <a href="http://datav.jiaminghi.com/guide/" target="_blank" rel="noopener">http://datav.jiaminghi.com/guide/ </a></p><p>使用了如水位图</p><p><img src="https://img2.jimu98.cn/blog/20201019174200.png" srcset="/img/loading.gif" alt="image-20201019174200405"></p><p>胶囊柱图</p><p><img src="https://img2.jimu98.cn/blog/20201019174225.png" srcset="/img/loading.gif" alt="image-20201019174225599"></p><p>留言模块主要使用的是 轮播表</p><p><img src="https://img2.jimu98.cn/blog/20201019174315.png" srcset="/img/loading.gif" alt="image-20201019174315907"></p><p>通过 <code>updateRows</code>方法 不刷新的更新数据</p><p>抽奖界面在此界面基础上  手写了抽奖样式</p><p>为了保证节目效果（主持人喊开始结束）  前端完成抽奖，之后把中奖数据发送到后台，然后再渲染到前台中奖列表中。</p><p>后台操控使用的是<code>vue-element-admin</code> 一款基于elemUI的后台管理模板</p><p>缺什么组件都可以通过elemUI找到相对于组件</p><p>图片上传使用的是 阿里OSS存储服务 也相对简单</p><p>小程序端也比较简单，比较复杂的可能就是点赞的效果，比较难做。调试了很久</p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晚会互动大屏</tag>
      
      <tag>项目</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽奖笔记</title>
    <link href="/posts/50184/"/>
    <url>/posts/50184/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】抽奖笔记"><a href="#【项目笔记】抽奖笔记" class="headerlink" title="【项目笔记】抽奖笔记"></a>【项目笔记】抽奖笔记</h1><p><img src="https://img2.jimu98.cn/blog/20201014200656.png" srcset="/img/loading.gif" alt="image-20201014200655467"></p><p>data</p><pre><code class="hljs vue">index: -1,timer: null,value: &#39;&#39;,status: true,arrList: []</code></pre><p>抽奖js</p><pre><code class="hljs javascript">start () &#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status) &#123;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我开始抽奖'</span>)       <span class="hljs-keyword">this</span>.value = <span class="hljs-string">''</span>       <span class="hljs-keyword">this</span>.arrList = <span class="hljs-keyword">this</span>.shuffle(<span class="hljs-keyword">this</span>.arrList)       setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;         <span class="hljs-keyword">this</span>.recursive()       &#125;, <span class="hljs-number">800</span>)       <span class="hljs-keyword">this</span>.status = !<span class="hljs-keyword">this</span>.status     &#125;   &#125;,   end () &#123;     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'结束抽奖'</span>)     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status) &#123;       <span class="hljs-keyword">return</span>     &#125;     clearTimeout(<span class="hljs-keyword">this</span>.timer) <span class="hljs-comment">// 停止抽奖</span>     <span class="hljs-keyword">this</span>.index = <span class="hljs-keyword">this</span>.randomIndex()     <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.arrList[<span class="hljs-keyword">this</span>.index]     <span class="hljs-comment">// 发送到后台中奖信息</span>     <span class="hljs-keyword">this</span>.status = !<span class="hljs-keyword">this</span>.status   &#125;,   randomIndex: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">this</span>.index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.arrList.length)     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.index   &#125;,   remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">this</span>.arrList.splice(<span class="hljs-keyword">this</span>.randomIndex(), <span class="hljs-number">1</span>)   &#125;,   shuffle (array) &#123;     <span class="hljs-keyword">const</span> length = array == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : array.length <span class="hljs-comment">// 数组长度</span>     <span class="hljs-keyword">if</span> (!length) &#123;       <span class="hljs-comment">// 如果数组长度为0，返回空数组</span>       <span class="hljs-keyword">return</span> []     &#125;     <span class="hljs-keyword">let</span> index = <span class="hljs-number">-1</span> <span class="hljs-comment">// 循环索引</span>     <span class="hljs-keyword">const</span> lastIndex = length - <span class="hljs-number">1</span> <span class="hljs-comment">// 数组的最后一个元素的索引</span>     <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">this</span>.copyArray(array) <span class="hljs-comment">// 复制一份原始数组作为结果数组</span>     <span class="hljs-comment">// console.log(result)</span>     <span class="hljs-keyword">while</span> (++index &lt; length) &#123;       <span class="hljs-comment">// 循环数组长度次</span>       <span class="hljs-keyword">const</span> rand =         index + <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (lastIndex - index + <span class="hljs-number">1</span>))       <span class="hljs-comment">// 生成随机索引，每一次的范围都比上一次少一个</span>       <span class="hljs-keyword">const</span> value = result[rand] <span class="hljs-comment">// 结果数组中对应随机索引的值先存下来，然后和result[index]互换位置</span>       result[rand] = result[index]       result[index] = value     &#125;     <span class="hljs-keyword">return</span> result <span class="hljs-comment">// 返回打乱顺序后的新数组</span>   &#125;,   copyArray (source, array) &#123;     <span class="hljs-keyword">let</span> index = <span class="hljs-number">-1</span> <span class="hljs-comment">// 循环索引</span>     <span class="hljs-keyword">const</span> length = source.length <span class="hljs-comment">// source数组长度</span>     array || (array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length)) <span class="hljs-comment">// 如果没有array参数，就新建一个和source长度一样的数组作为array</span>     <span class="hljs-keyword">while</span> (++index &lt; length) &#123;       <span class="hljs-comment">// 循环source，复制source的元素到array里</span>       array[index] = source[index]     &#125;     <span class="hljs-keyword">return</span> array <span class="hljs-comment">// 返回array</span>   &#125;,   recursive () &#123;     clearTimeout(<span class="hljs-keyword">this</span>.timer)     <span class="hljs-keyword">this</span>.timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;       <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.arrList[<span class="hljs-keyword">this</span>.randomIndex()]       <span class="hljs-keyword">this</span>.recursive()     &#125;, <span class="hljs-number">200</span>)   &#125;</code></pre><p>按钮及其css样式</p><pre><code class="hljs css"><span class="hljs-selector-class">.gift-main</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;  <span class="hljs-attribute">text-align</span>: center;  .select-lucky &#123;    <span class="hljs-selector-tag">width</span>: 100%;    <span class="hljs-selector-tag">height</span>: 10%;  &#125;  <span class="hljs-selector-class">.gift-lucky</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">60%</span>;    .gift-img &#123;      <span class="hljs-selector-tag">border-radius</span>: 100%;      <span class="hljs-selector-tag">width</span>: 320<span class="hljs-selector-tag">px</span>;      <span class="hljs-selector-tag">height</span>: 320<span class="hljs-selector-tag">px</span>;    &#125;  &#125;  <span class="hljs-selector-class">.button-lucky</span> &#123;    //margin:0 auto;    <span class="hljs-selector-tag">height</span>: 20%;    <span class="hljs-selector-tag">width</span>: 100%;  &#125;&#125;<span class="hljs-selector-class">.headImg</span> &#123;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">overflow</span>: auto;  .circleImg&#123;    <span class="hljs-selector-tag">padding</span>: 12<span class="hljs-selector-tag">px</span> 12<span class="hljs-selector-tag">px</span> 12<span class="hljs-selector-tag">px</span>;    <span class="hljs-selector-tag">margin-top</span>: <span class="hljs-selector-tag">px</span>;    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:70px</span>;    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:70px</span>;    <span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">relative</span>;    <span class="hljs-selector-tag">border-radius</span><span class="hljs-selector-pseudo">:50</span>%;    <span class="hljs-selector-tag">-webkit-animation</span>: <span class="hljs-selector-tag">ani</span> 2<span class="hljs-selector-tag">s</span> <span class="hljs-selector-tag">linear</span> <span class="hljs-selector-tag">infinite</span>;&#125;  // .circleImg &#123;  //   padding: 12px 12px 12px;  //   margin-top: px;  //   border-radius: 100%;  //   width: 70px;  //   height: 70px;  //   position: relative;  // &#125;  <span class="hljs-selector-class">.luckyImg</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffff7a</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);    <span class="hljs-attribute">z-index</span>:<span class="hljs-number">999</span>;  &#125;  <span class="hljs-selector-class">.luckyImg</span>&#123;    <span class="hljs-attribute">width</span>:<span class="hljs-number">70px</span>;    <span class="hljs-attribute">height</span>:<span class="hljs-number">70px</span>;    <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">-webkit-animation</span>: ani <span class="hljs-number">2s</span> linear infinite;&#125;<span class="hljs-keyword">@keyframes</span> ani &#123;   0%&#123;        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0px</span> <span class="hljs-number">#ff8329</span>   &#125;   25%&#123;        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff8329</span>   &#125;    50%&#123;        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff8329</span>   &#125;   75%&#123;        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff8329</span>   &#125;   100%&#123;    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0px</span> <span class="hljs-number">#ff8329</span>   &#125;&#125;&#125;<span class="hljs-selector-class">.headImg</span><span class="hljs-selector-pseudo">::-webkit-scrollbar</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-comment">/*滚动条滑块*/</span><span class="hljs-selector-class">.boheadImgx</span><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;  <span class="hljs-comment">/*滚动条里面小方块*/</span>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">#d8d8d8</span>;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#d8d8d8</span>;&#125;<span class="hljs-comment">/*滚动条轨道*/</span><span class="hljs-selector-class">.headImg</span><span class="hljs-selector-pseudo">::-webkit-scrollbar-track</span> &#123;  <span class="hljs-comment">/*滚动条里面轨道*/</span>  <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">#d8d8d8</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffff7a</span>;&#125;<span class="hljs-selector-id">#data-view</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#030409</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  #dv-full-screen-container &#123;    background-image: url("./img/bg.png");    <span class="hljs-selector-tag">background-size</span>: 100% 100%;    <span class="hljs-selector-tag">box-shadow</span>: 0 0 3<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">blue</span>;    <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">flex</span>;    <span class="hljs-selector-tag">flex-direction</span>: <span class="hljs-selector-tag">column</span>;  &#125;  <span class="hljs-selector-class">.main-header</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">justify-content</span>: space-between;    <span class="hljs-attribute">align-items</span>: flex-end;    .mh-left &#123;      <span class="hljs-selector-tag">font-size</span>: 20<span class="hljs-selector-tag">px</span>;      <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-tag">rgb</span>(1, 134, 187);      <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">134</span>, <span class="hljs-number">187</span>);      &#125;    &#125;    <span class="hljs-selector-class">.mh-middle</span> &#123;      <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffff00</span>;      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;    &#125;    <span class="hljs-selector-class">.mh-left</span>,    <span class="hljs-selector-class">.mh-right</span> &#123;      <span class="hljs-attribute">width</span>: <span class="hljs-number">450px</span>;    &#125;  &#125;  <span class="hljs-selector-class">.main-container</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(~<span class="hljs-string">"100% - 80px"</span>);    .border-box-content &#123;      <span class="hljs-selector-tag">padding</span>: 20<span class="hljs-selector-tag">px</span>;      <span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;      <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">flex</span>;    &#125;  &#125;  <span class="hljs-selector-class">.left-main-lucky</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">82%</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">box-sizing</span>: border-box;    .border-box-content &#123;      <span class="hljs-selector-tag">flex-direction</span>: <span class="hljs-selector-tag">column</span>;    &#125;  &#125;  <span class="hljs-selector-class">.right-main-lucky</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">18%</span>;    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">5px</span>;    <span class="hljs-attribute">box-sizing</span>: border-box;  &#125;  <span class="hljs-selector-class">.rmctc-right-lucky</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">35%</span>;  &#125;  <span class="hljs-selector-class">.rmctc-lucky-1</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">40%</span>;  &#125;  <span class="hljs-selector-class">.rmctc-lucky-2</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">60%</span>;  &#125;&#125;<span class="hljs-comment">/* 3D Button */</span><span class="hljs-selector-class">.btn-3d</span> &#123;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">22px</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">60px</span>;  <span class="hljs-attribute">color</span>: white;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span>;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">transition</span>: top <span class="hljs-number">0.01s</span> linear;  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.15</span>);&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e74c3c</span>;&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.yellow</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0d264</span>;&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-pseudo">:active</span> &#123;  <span class="hljs-attribute">top</span>: <span class="hljs-number">9px</span>;&#125;<span class="hljs-comment">/* 3D button colors */</span><span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.red</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e74c3c</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">#c63702</span> inset, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.15</span>) inset,    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">#c24032</span>, <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>),    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">8px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-pseudo">:active</span> &#123;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">#c63702</span> inset, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.15</span>) inset,    <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.yellow</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0d264</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">#f0d264</span> inset, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.15</span>) inset,    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">196</span>, <span class="hljs-number">172</span>, <span class="hljs-number">83</span>, <span class="hljs-number">0.7</span>), <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>),    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">8px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);&#125;<span class="hljs-selector-class">.btn-3d</span><span class="hljs-selector-class">.yellow</span><span class="hljs-selector-pseudo">:active</span> &#123;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">#f0d264</span> inset, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.15</span>) inset,    <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);&#125;<span class="hljs-selector-tag">nav</span> &#123;  <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">240px</span>;&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span>;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">background</span>: tomato;  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;  <span class="hljs-attribute">text-transform</span>: uppercase;  <span class="hljs-attribute">color</span>: ivory;  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">200</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">4px</span> <span class="hljs-number">4px</span> <span class="hljs-number">20px</span> -<span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.35</span>);  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.4s</span>;&#125;<span class="hljs-selector-tag">nav</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">2px</span>);  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> -<span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.35</span>);&#125;<span class="hljs-selector-tag">nav</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:active</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">10px</span>);  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> -<span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.35</span>);&#125;<span class="hljs-selector-tag">input</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">cursor</span>: pointer;  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;&#125;<span class="hljs-selector-id">#toggle</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0%</span>;&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">list-style</span>: none;  <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-attribute">text-align</span>: right;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">22px</span>;  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.4s</span> ease-out;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span>;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">35px</span>;  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">background</span>: tomato;  <span class="hljs-attribute">transition</span>: background <span class="hljs-number">3s</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">10px</span> -<span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.35</span>);&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background</span>: mediumorchid;  <span class="hljs-attribute">transition</span>: background <span class="hljs-number">0.45s</span>;&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>,<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">color</span>: tomato;&#125;<span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">color</span>: ivory;  <span class="hljs-attribute">text-transform</span>: lowercase;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">200</span>;  <span class="hljs-attribute">text-decoration</span>: none;  <span class="hljs-attribute">transition</span>: color <span class="hljs-number">0.3s</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽奖</tag>
      
      <tag>洗牌算法</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【三天两夜】SpringCloud+Jenkins+Docker持续部署积木学堂</title>
    <link href="/posts/48737/"/>
    <url>/posts/48737/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】SpringCloud-Jenkins-Docker持续部署积木学堂"><a href="#【项目笔记】SpringCloud-Jenkins-Docker持续部署积木学堂" class="headerlink" title="【项目笔记】SpringCloud+Jenkins+Docker持续部署积木学堂"></a>【项目笔记】SpringCloud+Jenkins+Docker持续部署积木学堂</h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>本项目搞了三天两夜。。</p><p>好多东西不太理解，网上也搜不到答案，只能一点点的试，而且最开始目的是想压榨到服务器极限，</p><p>最后虽然成功部署，可是一段时间就会有微服务被kill掉。所以跟朋友又借了一台，各占一半内存，稳定性还高。</p><p>先说下准备工作</p><p>A：部署了九个微服务  （需要安装git，java，maven，docker）</p><p>B：部署了Mysql，Nacos，Redis，前端项目（需要安装docker，node，nginx）</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200819181312.png" srcset="/img/loading.gif" alt="image-20200819181312171"></p><p><img src="https://img2.jimu98.cn/blog/20200819180835.png" srcset="/img/loading.gif" alt="image-20200819180835015"></p><p><img src="https://img2.jimu98.cn/blog/20200819180909.png" srcset="/img/loading.gif" alt="image-20200819180909122"></p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>一开始想把积木学堂部署到阿里云送的那个半年的主机。</p><p>本项目一共九个微服务，加上服务器还需要mysql，redis，nacos三个服务。还可能会把前端也部署上去。</p><p>小伙伴们都说可能部署不了。所以为了不浪费时间，先测试一下使用内存。</p><p>（先看写在前面）</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先打开Java自带的性能监测工具jvisualvm</p><p>就在java安装目录那个bin里面 jvisualvm.ext</p><p>打开之后啥也没干。发现这么一个现象。应该就是传说中jvm自动回收了</p><p>（这个是网关微服务，大概还在75M就自动回收了）</p><p><img src="https://img2.jimu98.cn/blog/20200817180023.png" srcset="/img/loading.gif" alt="image-20200817180023623"></p><p>再看一下课程微服务edu，毕竟核心功能，发现他是400M才回收</p><p><img src="https://img2.jimu98.cn/blog/20200817180357.png" srcset="/img/loading.gif" alt="image-20200817180357252"></p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8110</span><span class="hljs-regexp">/admin/</span>edu<span class="hljs-regexp">/teacher/</span>list</code></pre><p>开始搞事情，打开JMeter</p><p><img src="https://img2.jimu98.cn/blog/20200817180443.png" srcset="/img/loading.gif" alt="image-20200817180443858"></p><p>设置20线程，每个100条，我发现到了400M回收了，那我改一下。</p><p><img src="https://img2.jimu98.cn/blog/20200817180629.png" srcset="/img/loading.gif" alt="image-20200817180629335"></p><p><img src="https://img2.jimu98.cn/blog/20200817180809.png" srcset="/img/loading.gif" alt="image-20200817180809858"></p><p>依然400M回收了。如果大家同时400M  九个微服务，加上mysql之类的，肯定不够。</p><p>那我给他设置一个最大内存，看一下，会不会报错！！</p><blockquote><p>-Xms64M -Xmx64M -XX:PermSize=512M -XX:MaxPermSize=1024M</p></blockquote><p>50线程，每个200条共用12s，其实我觉得很顺滑啊。于是乎，我全部改了一下</p><p><img src="https://img2.jimu98.cn/blog/20200817181415.png" srcset="/img/loading.gif" alt="image-20200817181415403"></p><p>我重启了这些服务</p><p><img src="https://img2.jimu98.cn/blog/20200817182215.png" srcset="/img/loading.gif" alt="image-20200817182215686"></p><p>并没有出现可能的故障，也不确定这种方法是否准确，先继续往下做</p><h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><p>好  全部关闭！开始部署。应湖总要求。我重装了一下服务器，从头开始</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>部署有两种方式</p><p>1.服务器安装java环境。</p><p>然后把打包的jar包扔上去，运行一下。</p><p>2.持续集成</p><p>持续集成（简称CI）指的是，频繁的（一天多次）将代码集成到主干。</p><p>持续部署（CD）</p><p>持续集成的目的，就是让产品快速迭代，同时还能保持高质量。</p><p>简单来说就是把代码提交到git上面，就自动根据规则部署成服务。</p><p>那这里使用第二种进行部署。</p><h3 id="Jenkins介绍"><a href="#Jenkins介绍" class="headerlink" title="Jenkins介绍"></a>Jenkins介绍</h3><blockquote><p>Jenkins在这里充当了一个自动构建的角色。无需人工干预。一个配置简单和使用方便的持续集成服务器，或许可以写一个脚本，监控git是否有更新，有的话就下载下来，package一下。但是他最强大的功能是他有很多插件，比如邮件发送</p></blockquote><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>我的Linux服务器是centon7</p><h4 id="1-安装Java"><a href="#1-安装Java" class="headerlink" title="1.安装Java"></a>1.安装Java</h4><p>查找java相关的列表</p><blockquote><p>yum -y list java*</p></blockquote><p>安装jdk</p><p><a href="http://apache.apooloo.cn/#/down/f1b54d77df533af9d9de55cf3f4e2cea" target="_blank" rel="noopener">http://apache.apooloo.cn/#/down/f1b54d77df533af9d9de55cf3f4e2cea</a></p><blockquote><p>cd /usr/local  放到此目录</p><p>tar -zxvf jdk-8u202-linux-x64.tar.gz</p></blockquote><p>建立软连接</p><p>ln -s /usr/local/jdk1.8.0_202/ /usr/local/jdk</p><p>配置环境变量</p><blockquote><p>vim /etc/profile</p></blockquote><p>在文件最后加入：</p><pre><code class="hljs bash"><span class="hljs-comment">#set java environment</span><span class="hljs-built_in">export</span> JAVA_HOME=/usr/<span class="hljs-built_in">local</span>/jdk<span class="hljs-built_in">export</span> JRE_HOME=<span class="hljs-variable">$JAVA_HOME</span>/jre<span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$CLASSPATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/lib:<span class="hljs-variable">$JRE_HOME</span>/lib<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin</code></pre><p>修改/etc/profile之后让其生效</p><blockquote><p>source /etc/profile</p></blockquote><p>完成安装后验证</p><blockquote><p>java -version</p></blockquote><h4 id="2-安装Maven"><a href="#2-安装Maven" class="headerlink" title="2.安装Maven"></a>2.安装Maven</h4><blockquote><p>yum -y list maven*   #查看了一下发现版本都特别低，跟平时用的不太一样，为了安全，还是手动安装吧</p></blockquote><p>官网下载好托到/usr/local</p><p><img src="https://img2.jimu98.cn/blog/20200817191521.png" srcset="/img/loading.gif" alt="image-20200817191521061"></p><p>解压</p><blockquote><p>cd /usr/local</p><p>tar -zvxf apache-maven-3.6.3-bin.tar.gz</p></blockquote><p>编辑文件</p><blockquote><p>cd apache-maven-3.6.3</p><p>vim conf/settings.xml</p></blockquote><p>找到localRepository</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/opt/jarstore<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>找到mirror</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><p>你还没有jarstore文件夹</p><blockquote><p>cd /opt</p><p>mkdir jarstore</p></blockquote><p>配置环境变量</p><blockquote><p>vim /etc/profile</p></blockquote><p>在文件最后加入：</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> MAVEN_HOME=/usr/<span class="hljs-built_in">local</span>/apache-maven-3.6.3<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$MAVEN_HOME</span>/bin:<span class="hljs-variable">$PATH</span></code></pre><p>修改/etc/profile之后让其生效</p><blockquote><p>source /etc/profile</p></blockquote><h4 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3.安装Git"></a>3.安装Git</h4><blockquote><p>yum -y install git</p></blockquote><h4 id="4-安装Docker"><a href="#4-安装Docker" class="headerlink" title="4.安装Docker"></a>4.安装Docker</h4><p>安装些必要的工具</p><blockquote><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p></blockquote><p>添加软件源信息</p><blockquote><p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></blockquote><p>更新并安装Docker-CE</p><blockquote><p>yum makecache fast</p><p>yum -y install docker-ce</p></blockquote><p>开启Docker服务</p><blockquote><p>service docker start</p></blockquote><blockquote><p>这里到另一台服务器B也安装Docker，然后开始安装下面软件</p></blockquote><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><blockquote><p>docker pull mysql  #我这里直接装最新版了</p></blockquote><p>然后创建一个外部目录，用来映射数据之类的</p><blockquote><p>mkdir /opt/mysql</p></blockquote><p>运行mysql</p><pre><code class="hljs bash">docker run -p 3306:3306 --name mymysql -v /opt/mysql/conf:/etc/mysql/conf.d -v /opt/mysql/logs:/logs -v /opt/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</code></pre><p>然后远程连接一下（如果你的服务器安全组规则没有配置，记得去开放下3306）</p><p><img src="https://img2.jimu98.cn/blog/20200817203511.png" srcset="/img/loading.gif" alt="image-20200817203511445"></p><p>这时候顺便把本地开发时候的数据库上传上去</p><p>代码里面的和数据库有关的信息等会一起改。</p><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><blockquote><p>docker pull redis</p></blockquote><p>然后创建一个外部目录，用来映射数据之类的</p><blockquote><p>mkdir /opt/redis</p></blockquote><p>运行redis</p><pre><code class="hljs bash">docker run -p 6379:6379 --name redis1 -v /opt/redis/redis.conf:/etc/redis/redis.conf -v /opt/redis/data:/data -d redis redis-server /etc/redis/redis.conf --requirepass <span class="hljs-string">"123456"</span> --appendonly yes</code></pre><p>测试</p><p><img src="https://img2.jimu98.cn/blog/20200817204930.png" srcset="/img/loading.gif" alt="image-20200817204930031"></p><h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h3><blockquote><p>docker pull nacos/nacos-server</p></blockquote><p>挂载日志和配置文件</p><blockquote><p>mkdir -p /opt/nacos/logs/  #新建logs目录<br>mkdir -p /opt/nacos/init.d/<br>touch /opt/nacos/init.d/custom.properties<br>vim /opt/nacos/init.d/custom.properties</p></blockquote><blockquote><p>配置文件可以不用MySQL，这里尽量模拟真实环境就用了</p></blockquote><pre><code class="hljs bash">server.contextPath=/nacosserver.servlet.contextPath=/nacosserver.port=8848 spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://xxx.xxx.xxx.xxx:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=<span class="hljs-literal">true</span>db.user=rootdb.password=1234  nacos.cmdb.dumpTaskInterval=3600nacos.cmdb.eventTaskInterval=10nacos.cmdb.labelTaskInterval=300nacos.cmdb.loadDataAtStart=<span class="hljs-literal">false</span> management.metrics.export.elastic.enabled=<span class="hljs-literal">false</span> management.metrics.export.influx.enabled=<span class="hljs-literal">false</span>server.tomcat.accesslog.enabled=<span class="hljs-literal">true</span>server.tomcat.accesslog.pattern=%h %l %u %t <span class="hljs-string">"%r"</span> %s %b %D %&#123;User-Agent&#125;i  nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**nacos.naming.distro.taskDispatchThreadCount=1nacos.naming.distro.taskDispatchPeriod=200nacos.naming.distro.batchSyncKeyCount=1000nacos.naming.distro.initDataRatio=0.9nacos.naming.distro.syncRetryDelay=5000nacos.naming.data.warmup=<span class="hljs-literal">true</span>nacos.naming.expireInstance=<span class="hljs-literal">true</span></code></pre><p>执行mysql脚本</p><blockquote><p>新建一个nacos 数据库 然后选择utf8mb4   //是不是很贴心</p></blockquote><pre><code class="hljs mysql">CREATE TABLE &#96;config_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) DEFAULT NULL,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;c_desc&#96; varchar(256) DEFAULT NULL,  &#96;c_use&#96; varchar(64) DEFAULT NULL,  &#96;effect&#96; varchar(64) DEFAULT NULL,  &#96;type&#96; varchar(64) DEFAULT NULL,  &#96;c_schema&#96; text,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;; &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_aggr&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;  &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_beta&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;; &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_tag&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;; &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_tags_relation&#96; (  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;nid&#96;),  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;; &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;group_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;; &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;his_config_info&#96; (  &#96;id&#96; bigint(64) unsigned NOT NULL,  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,  &#96;data_id&#96; varchar(255) NOT NULL,  &#96;group_id&#96; varchar(128) NOT NULL,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL,  &#96;md5&#96; varchar(32) DEFAULT NULL,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,  &#96;src_user&#96; text,  &#96;src_ip&#96; varchar(20) DEFAULT NULL,  &#96;op_type&#96; char(10) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;nid&#96;),  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),  KEY &#96;idx_did&#96; (&#96;data_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;  &#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;tenant_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;  CREATE TABLE &#96;tenant_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;; CREATE TABLE users (username varchar(50) NOT NULL PRIMARY KEY,password varchar(500) NOT NULL,enabled boolean NOT NULL); CREATE TABLE roles (username varchar(50) NOT NULL,role varchar(50) NOT NULL,constraint uk_username_role UNIQUE (username,role)); CREATE TABLE permissions (    role varchar(50) NOT NULL,    resource varchar(512) NOT NULL,    action varchar(8) NOT NULL,    constraint uk_role_permission UNIQUE (role,resource,action)); INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE); INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);</code></pre><p>启动容器 </p><blockquote><p>docker  run <br>–name mynacos -d <br>-p 8848:8848 <br>–privileged=true <br>–restart=always <br>-e JVM_XMS=128m <br>-e JVM_XMX=128m <br>-e MODE=standalone <br>-e PREFER_HOST_MODE=hostname <br>-v /opt/nacos/logs:/usr/docker/data/nacos/logs <br>-v /opt/nacos/init.d/custom.properties:/usr/docker/data/nacos/init.d/custom.properties <br>nacos/nacos-server</p></blockquote><blockquote><p>这里限制了nacos的最大内存</p><p>使用docker stats  查看docker内存占用</p></blockquote><p>然后访问</p><blockquote><p><a href="http://xxxx.xxx..xxx.xx:8848/nacos" target="_blank" rel="noopener">http://xxxx.xxx..xxx.xx:8848/nacos</a>   记得后面的nacos</p><p>默认密码 nacos nacos   //登录之后右上角改密码，毕竟不是开发阶段了</p></blockquote><p>到这里以后就要修改下代码中每个微服务设计到mysql，redis，nacos的配置信息了。</p><blockquote><p>修改的时候遇到一个坑，nacos也不要加http://  否则可能会出问题</p></blockquote><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p><img src="https://img2.jimu98.cn/blog/20200817190346.png" srcset="/img/loading.gif" alt="image-20200817190346545"></p><blockquote><p>这里创建私有仓库，毕竟代码中包含很多私密配置信息</p></blockquote><p>然后把代码上传上去</p><blockquote><p>!!!!!!注意，从下面开始，我就要用另一台服务器了，</p><p>经过我很多天的测试，一台服务器确实跑不起来</p><p>整个项目我用了两台4G服务器</p><p>A：部署Nacos，Redis，Mysql ，前端项目  B：运行九个微服务。</p></blockquote><blockquote><p>这时候回到服务器A，开始做部署</p></blockquote><h2 id="配置jenkins-war"><a href="#配置jenkins-war" class="headerlink" title="配置jenkins.war"></a>配置jenkins.war</h2><p>首先把jenkins.war 上传到 /usr/local/jenkins</p><blockquote><p>cd /usr/local/jenkins</p><p>nohup java -jar /usr/local/jenkins/jenkins.war &gt;/usr/local/jenkins/jenkins.out &amp;</p><p>//这句话要敲两次回车</p></blockquote><blockquote><p>记得去打开8080端口  然后访问<a href="http://xxxx:8080/" target="_blank" rel="noopener">http://xxxx:8080/</a></p></blockquote><p>这里他加载有些慢，等着就好</p><p><img src="https://img2.jimu98.cn/blog/20200817225034.png" srcset="/img/loading.gif" alt="image-20200817225034488"></p><p>等他加载完了然后查看密码</p><blockquote><p>cat /root/.jenkins/secrets/initialAdminPassword</p></blockquote><p>然后把密码输入进去。顺便暂时保存一下密码，等下还用</p><p>然后赶快更新源</p><blockquote><p>cd /root/.jenkins/updates #进入更新配置位置</p></blockquote><p>输入下面内容</p><blockquote><p>sed -i ‘s/http://updates.jenkins-ci.org/download/https://mirrors.tuna.tsinghua.edu.cn/jenkins/g’ default.json &amp;&amp; sed -i ‘s/http://<a href="http://www.google.com/https:\/\/www.baidu.com/g&#39;" target="_blank" rel="noopener">www.google.com/https:\/\/www.baidu.com/g&#39;</a> default.json</p></blockquote><p>这时候重启下jenkins</p><blockquote><p>nohup java -jar /usr/local/jenkins/jenkins.war &gt;/usr/local/jenkins/jenkins.out &amp;</p></blockquote><p>然后刷新下网页，他又让你输密码，你输就完事了</p><p>选第一个</p><p><img src="https://img2.jimu98.cn/blog/20200817230139.png" srcset="/img/loading.gif" alt="image-20200817230139051"></p><p>大概几分钟就好了，他会卡一会</p><p><img src="https://img2.jimu98.cn/blog/20200817230309.png" srcset="/img/loading.gif" alt="image-20200817230309763"></p><p>然后一直下一步</p><p>登录之后点这里</p><p>全局工具配置</p><p><img src="https://img2.jimu98.cn/blog/20200818002941.png" srcset="/img/loading.gif" alt="image-20200818002941875"></p><h3 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h3><blockquote><p>which jdk   //输出jdk目录</p></blockquote><p>然后填进去，记得把自动安装取消勾选</p><p><img src="https://img2.jimu98.cn/blog/20200818020418.png" srcset="/img/loading.gif" alt="image-20200818020418445"></p><h3 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h3><blockquote><p>which jdk  //这个也可以查路径</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200818020602.png" srcset="/img/loading.gif" alt="image-20200818020602697"></p><p><img src="https://img2.jimu98.cn/blog/20200818143552.png" srcset="/img/loading.gif" alt="image-20200818143552414"></p><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>git也一样</p><blockquote><p>which git</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200818020712.png" srcset="/img/loading.gif" alt="image-20200818020712731"></p><h2 id="自动化部署项目"><a href="#自动化部署项目" class="headerlink" title="自动化部署项目"></a>自动化部署项目</h2><h3 id="在每一个项目中添加文件Dockerfile"><a href="#在每一个项目中添加文件Dockerfile" class="headerlink" title="在每一个项目中添加文件Dockerfile"></a>在每一个项目中添加文件Dockerfile</h3><pre><code class="hljs java">#FROM java:8FROM openjdk:<span class="hljs-number">8</span>-jdk-alpineARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENTRYPOINT [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>, <span class="hljs-string">"app.jar"</span>, <span class="hljs-string">"-Xms32M -Xmx32M -XX:PermSize=32M -XX:MaxPermSize=64M"</span>]</code></pre><blockquote><p>-Xms32M -Xmx32M -XX:PermSize=32M -XX:MaxPermSize=64M  有些过分，如果两个服务器可以改大点</p></blockquote><p>在项目pom文件添加打包类型，和maven插件</p><blockquote><p><packaging>jar</packaging></p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">buildArgs</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">JAR_FILE</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">buildArgs</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>在有数据库的微服务pom里面加上这个</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></code></pre><p>打开Jenkins  添加项目，添加一个流水线项目</p><p><img src="https://img2.jimu98.cn/blog/20200819174119.png" srcset="/img/loading.gif" alt="image-20200819174119254"></p><p>构建这里添加一个参数，脚本会根据你的参数去拉取git，你也可以写死</p><p><img src="https://img2.jimu98.cn/blog/20200819175251.png" srcset="/img/loading.gif" alt="image-20200819175251088"></p><p><img src="https://img2.jimu98.cn/blog/20200819175302.png" srcset="/img/loading.gif" alt="image-20200819175302747"></p><p>选择执行本地文件，添加一下git账号密码</p><p><img src="https://img2.jimu98.cn/blog/20200819174036.png" srcset="/img/loading.gif" alt="image-20200819174035572"></p><p>然后保存。。。。这里可以选择哪个git钩子函数，这样你一上传git他就能自动构建。</p><p>git凭证ID这里查询</p><p><img src="https://img2.jimu98.cn/blog/20200819174445.png" srcset="/img/loading.gif" alt="image-20200819174445743"></p><blockquote><p>如果你问我的都是英文，找不到这个啊，emmm。出来挨打！</p></blockquote><p>在总项目目录下添加</p><pre><code class="hljs shell">//git凭证IDdef git_auth = "xxxxxxxxx"//git的url地址def git_url = "https://gitee.com/jimu98/jimuxuetang.git"//镜像的版本号def tag = "latest"node &#123;    stage('拉取代码') &#123;      checkout([$class: 'GitSCM', branches: [[name: "*/$&#123;branch&#125;"]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: "$&#123;git_auth&#125;", url: "$&#123;git_url&#125;"]]])    &#125;    stage('编译，项目依赖工程') &#123;      sh "mvn -f common clean install"    &#125;    stage('编译，网关微服务') &#123;      sh "mvn -f infrastructure/api_gateway clean package dockerfile:build"    &#125;    stage('编译，service_cms') &#123;      sh "mvn -f service/service_cms clean package dockerfile:build"    &#125;    stage('编译，service_edu') &#123;      sh "mvn -f service/service_edu clean package dockerfile:build"    &#125;    stage('编译，service_oss') &#123;      sh "mvn -f service/service_oss clean package dockerfile:build"    &#125;    stage('编译，service_sms') &#123;      sh "mvn -f service/service_sms clean package dockerfile:build"    &#125;    stage('编译，service_statistics') &#123;      sh "mvn -f service/service_statistics clean package dockerfile:build"    &#125;    stage('编译，service_trade') &#123;      sh "mvn -f service/service_trade clean package dockerfile:build"    &#125;    stage('编译，service_ucenter') &#123;      sh "mvn -f service/service_ucenter clean package dockerfile:build"    &#125;    stage('编译，service_vod') &#123;      sh "mvn -f service/service_vod clean package dockerfile:build"    &#125;&#125;</code></pre><p>然后再创建一个任务</p><p><img src="https://img2.jimu98.cn/blog/20200819174602.png" srcset="/img/loading.gif" alt="image-20200819174602587"></p><p>这次选择自由风格的就可以了。</p><p><img src="https://img2.jimu98.cn/blog/20200819174725.png" srcset="/img/loading.gif" alt="image-20200819174725514"></p><p>这里我选择的是在前一个工程创建完成之后构建，也就是前一个任务把微服务都打包成docker容器之后</p><p>这个脚本作用自动去构建这些，不用手动运行。</p><blockquote><p>构建就点执行shell   如果遇到英文   翻译一下  shell总认识吧。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200818032806.png" srcset="/img/loading.gif" alt="image-20200818032806609"></p><p><img src="https://img2.jimu98.cn/blog/20200819174837.png" srcset="/img/loading.gif" alt="image-20200819174837295"></p><p>添加脚本</p><blockquote><p>贴心提示：我这里微调了一下限制的内存</p><p>经过测试   edu，cms微服务比较容易被kill   我给他的容量大一点</p></blockquote><pre><code class="hljs shell">imageId=`docker ps -a| grep api_gateway | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 200M --name api_gateway -p 9110:9110 api_gatewayimageId=`docker ps -a| grep service_edu | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 400M --name service_edu -p 8110:8110 service_eduimageId=`docker ps -a| grep service_oss | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_oss -p 8120:8120 service_ossimageId=`docker ps -a| grep service_vod | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_vod -p 8130:8130 service_vodimageId=`docker ps -a| grep service_cms | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 400M --name service_cms -p 8140:8140 service_cmsimageId=`docker ps -a| grep service_sms | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_sms -p 8150:8150 service_smsimageId=`docker ps -a| grep service_ucenter | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_ucenter -p 8160:8160 service_ucenterimageId=`docker ps -a| grep service_trade | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_trade -p 8170:8170 service_tradeimageId=`docker ps -a| grep service_statistics | awk '&#123;print $1&#125;'`if [ "$imageId" !=  "" ] ; then    #停掉容器    docker stop $imageId    #删除容器    docker rm $imageIdecho "成功删除容器"fidocker run -di -m 256M --name service_statistics -p 8180:8180 service_statistics</code></pre><p>修改下脚本路径</p><p>端口号，项目路径，名字</p><p><img src="https://img2.jimu98.cn/blog/20200818033016.png" srcset="/img/loading.gif" alt="image-20200818033016748"></p><blockquote><p>我这里放一些名字，如果你需要的话可以从这里复制</p></blockquote><pre><code class="hljs ebnf"><span class="hljs-attribute">api_gateway</span><span class="hljs-attribute">service_cms</span><span class="hljs-attribute">service_edu</span><span class="hljs-attribute">service_oss</span><span class="hljs-attribute">service_sms</span><span class="hljs-attribute">service_statistics</span><span class="hljs-attribute">service_trade</span><span class="hljs-attribute">service_ucenter</span></code></pre><p>然后把代码提交到git，选择运行</p><p><img src="https://img2.jimu98.cn/blog/20200819175604.png" srcset="/img/loading.gif" alt="image-20200819175604734"></p><p>如果出现构建找不到dockerfile文件</p><p>需要在maven的xml文件中添加信赖</p><blockquote><p><pluginGroup>com.spotify</pluginGroup></p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200818220803.png" srcset="/img/loading.gif" alt="image-20200818220803562"></p><blockquote><p>构建成功，看一下docker运行</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200818221709.png" srcset="/img/loading.gif" alt="image-20200818221709001"></p><blockquote><p>free -h  看下Linux内存</p></blockquote><blockquote><p>看完是不是觉得，就这？就这三天两夜？？？哈哈，主要是本人太菜了。</p></blockquote><h1 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h1><blockquote><p>前端其实也是可以使用Jenkins持续构建的。但是我感觉前端项目不怎么修改</p><p>而且夜已深。直接扔到服务器运行了，Nginx代理一下</p><p>暂时先写到这里了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>递归</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】计算机网络-HTTP</title>
    <link href="/posts/62035/"/>
    <url>/posts/62035/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】计算机网络-HTTP篇"><a href="#【java总结】计算机网络-HTTP篇" class="headerlink" title="【java总结】计算机网络-HTTP篇"></a>【java总结】计算机网络-HTTP篇</h1><blockquote><p>本内容参考了多位大佬，几十篇博客整理出来的，方便自己的复习，同时有不全面，不正确的内容欢迎补充</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>这个协议对于网络工程师来说，他只是一个协议而已，但对于我们java工程师，或者前端工程师，或者其他非网络计算机从业者都太重要了。我们java开发的很大部分都是web应用，。我们对Web的操作都是通过HTTP协议来进⾏传 输数据的，前端也是很直接的利益相关（怎么有股知乎的味道。）总而言之，Http就是Web通信的基础，这是我们必学的。我一定要总结的全面，透彻。方便自己，方便大家。</p><h3 id="Http基本概念"><a href="#Http基本概念" class="headerlink" title="Http基本概念"></a>Http基本概念</h3><p>HTTP全称是 HyperText Transfer Protocal，即：超文本传输协议。是互联网上应用最为广泛的一种<strong>网络通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。目前我们使用的是<strong>HTTP/1.1 版本</strong>。</p><p>前面不是说了网络的分层概念吗，我们的HTTP协议是在最上层，也就是应⽤层。这是最贴近我们的程序员的层次。</p><blockquote><p>我们逐步一点点来看，解决一个又一个小概念，争取建立一个完整的HTTP体系</p><p>最终解决一个大的问题：在浏览器输入 URL 后发生了什么？</p></blockquote><h3 id="URI-和-URL-有什么区别？"><a href="#URI-和-URL-有什么区别？" class="headerlink" title="URI 和 URL 有什么区别？"></a>URI 和 URL 有什么区别？</h3><p>URI：统一资源标识符（Uniform Resource Identifier），就是在某一规则下能把一个资源独一无二地标识出来。它可以理解成是一个资源的名字，比如<code>积木</code>,<code>jimu98</code>甚至<code>jimu98@foxmail.com</code>或者是<code>aaa.html</code>，只要可以唯一的标识一个名字，那么我们就把他称作uri，甚至<code>https://www.jimu98.cn/aaa.html</code>也是一个URI(这个不是应该叫URL，别着急)</p><p>URI：统一资源标识符(uniform resource identifier)，比如<code>https://www.jimu98.cn/aaa.html</code>，</p><p>其实，我们可以发现，URI强调的是给资源标记命名，URL强调的是给资源定位，但是你会发现，URL显然比URI包含信息更多，我通过URL也可以知道自己的资源名字可能是<code>aaa.html</code>，并且我还知道了他的地址.</p><p>所以大多数情况下大家觉得给一个网络资源分别命名和给出地址太麻烦，干脆就用地址既当地址用，又当标记名用</p><p>所以，URL也充当了WWW万维网里面URI的角色，但是他比URI多了一层意义，我不光知道你叫什么，我还知道你在哪里。</p><p>我们在浏览器输入的都是URL，因为我们输入的目的是为了找到某一个资源。</p><h3 id="DNS：负责解析域名"><a href="#DNS：负责解析域名" class="headerlink" title="DNS：负责解析域名"></a>DNS：负责解析域名</h3><blockquote><p>当我们需要访问一个远程资源的时候，必然要和他建立连接(建立TCP，或者UDP连接，基于IP协议)</p><p>所以我们要知道他的地址，可是随着互联网的发展，越来越多的web应用进入大家视线，比如我们访问一些常用的网站，<code>www.baidu.com</code> <code>www.jd.com</code> 这些时候，我们明明输入的不是ip。</p><p>其实让我们记IP，也是可以访问的，但是你愿意记那么长的数字吗，反正我不愿意，于是乎DNS <code>域名解析协议</code> 诞生了，他就可以把一个特殊含义的域名转换成一个IP地址。</p><p>但是你想啊，你想要用baidu这个名字，别人也想，那到底该给谁呢。于是肯定有专门的管理机构去统一规范。</p><p>但是，我们还有一个叫做本地DNS的东西，通过配置Host文件，去自定义一个域名，实现本地映射。</p></blockquote><blockquote><p>DNS工作流程：</p><p>1、在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个ip地址映射，完成域名解析。</p><p>2、如果hosts里没有这个域名的映射，则会查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析记过给客户端，完成域名解析，此解析具有权威性。</p><p>4、如果要查询域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址（baidu.com）给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 主机。</p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把请求转至上上级，以此循环。不管是本地DNS服务器用是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></blockquote><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><blockquote><p>http请求由三部分组成，分别是：请求行、请求报头、空行、请求数据</p><p>可以分别理解成我使用什么方法，我支持什么格式，我的格式说完了，我的正式数据</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729170117.png" srcset="/img/loading.gif" alt="image-20200729170117264"></p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><blockquote><p>请求行由请求方法、URL字段和HTTP协议的版本组成，格式如下</p><p>Method     Request-URI      HTTP-Version     CRLF </p><p>其中 Method 表示请求方法；GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS（可选项）</p><p>Request-URI是一个统一资源标识符；（前面也说过了）</p><p>HTTP-Version表示请求的HTTP协议 版本；（后面说版本的区别）</p><p>CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p></blockquote><h4 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h4><blockquote><p>通用报头：（现在在解释请求报文，后面还有响应报文，他们两公用的报头）</p><p>Date：表示消息产生的日期和时间。<br>Connection：允许发送指定连接的选项。例如指定连接是连续的；或者指定“close”选项，通知服务器，在响应完成后，关闭连接。<br>Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制）。</p><p>//————————————————–</p><p>请求报头：（不同的报头在不同的http版本种诞生时间不同，可以看后面版本了解）</p><p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。<br>User-Agent：发送请求的浏览器类型、操作系统等信息。<br>Accept：客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息。<br>Accept-Charset请求报头域用于指定客户端接受的字符集 。<br>Accept-Encoding：客户端可识别的数据编码。<br>Accept-Language：表示浏览器所支持的语言类型。<br>Authorization请求报头域主要用于证明客户端有权查看某个资源。<br>Connection：允许客户端和服务器指定与请求/响应连接有关的选项。例如，这时为Keep-Alive则表示 保持连接。<br>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p><p>//————————————————–</p><p>实体报头：（用来定义被传送数据的类型，既可用于请求，又可用于响应）</p><p>Content-Type：发送给接收者的实体正文的媒体类型。<br>Content-Lenght：实体正文的长度。<br>Content-Language：描述资源所用的自然语言。<br>Content-Encoding：实体报头被用作媒体类型的修饰符。它的值指示了已经被应用到实体正文的附加 内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。<br>Last-Modified：实体报头用于指示资源的最后修改日期和时间。<br>Expires：实体报头给出响应过期的日期和时间。</p></blockquote><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><blockquote><p>就是告诉服务器，我的请求头到此为止</p></blockquote><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><blockquote><p>在get中，数据就在url中体现了，所以这里的数据指的在post提交中的数据，至于PUT、DELETE这些，他们其实也可以理解成post</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729172717.png" srcset="/img/loading.gif" alt="image-20200729172717402"></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><blockquote><p>HTTP 的响应报文由状态行、响应报头、空行、响应正文 （和请求体相当类似）</p></blockquote><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><blockquote><p>就是告诉我们  请求的数据是否找到，如果没找到是因为啥，返回一些状态码（404大家都遇到过吧）</p></blockquote><pre><code class="hljs basic"><span class="hljs-number">1</span>xx：表明服务端接收了客户端请求，客户端继续发送请求；<span class="hljs-number">2</span>xx：客户端发送的请求被服务端成功接收并成功进行了处理；<span class="hljs-number">3</span>xx：服务端给客户端返回用于重定向的信息；<span class="hljs-number">4</span>xx：客户端的请求有非法内容；<span class="hljs-number">5</span>xx：服务端未能正常处理客户端的请求而出现意外错误。<span class="hljs-number">2</span>xx:<span class="hljs-symbol">200 </span>OK：表示从客户端发送给服务器的请求被正常处理并返回；<span class="hljs-symbol">204 </span>No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）<span class="hljs-symbol">206 </span>Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的<span class="hljs-keyword">GET</span>请求，响应报文中包含由Content-Range指定范围的实体内容。<span class="hljs-number">3</span>xx:<span class="hljs-symbol">301 </span>Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；<span class="hljs-symbol">302 </span>Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<span class="hljs-symbol">303 </span>See Other：表示请求的资源被分配了新的URL，应使用<span class="hljs-keyword">GET</span>方法定向获取请求的资源<span class="hljs-symbol">304 </span><span class="hljs-keyword">Not</span> Modified：表示客户端发送附带条件（是指采用<span class="hljs-keyword">GET</span>方法的请求报文中包含<span class="hljs-keyword">if</span>-Match、<span class="hljs-keyword">If</span>-Modified-Since、<span class="hljs-keyword">If</span>-None-Match、<span class="hljs-keyword">If</span>-Range、<span class="hljs-keyword">If</span>-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；<span class="hljs-symbol">307 </span>与<span class="hljs-number">302</span>相同，但不会把POST请求变成<span class="hljs-keyword">GET</span><span class="hljs-number">4</span>xx:<span class="hljs-symbol">400 </span>Bad Request:表示请求报文中存在语法错误；<span class="hljs-symbol">401 </span>Unauthorized：经许可，需要通过HTTP认证；<span class="hljs-symbol">403 </span>Forbidden：服务器拒绝该次访问（访问权限出现问题）<span class="hljs-symbol">404 </span><span class="hljs-keyword">Not</span> Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；<span class="hljs-number">5</span>xx:<span class="hljs-symbol">500 </span>Inter Server <span class="hljs-keyword">Error</span>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；<span class="hljs-symbol">503 </span>Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</code></pre><blockquote><p>突然想到某个老师教过，当你遇到404错误，你给用户返回一个503，显得你网站特别火爆（啊哈哈哈哈哈哈）</p><p>也就是说，其实看到某些状态码的时候，也不一定可信，因为后台可以改掉</p></blockquote><h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><blockquote><p>GET与POST是我们常用的两种HTTP Method（就是你在前端form表单那里写的，或者你后台用@PostMapping接收的那个）</p></blockquote><blockquote><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被收藏，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul></blockquote><blockquote><p>但是，GET和POST的底层都是TCP/IP，你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>但是不同的浏览器对数据量有所限制，业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p><p>如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p></blockquote><blockquote><p>还有一个比较重要的区别，很多面试笔记里面都没有写这一条（）</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。</p><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p><p>以上就是post和get全部区别的</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729192410.png" srcset="/img/loading.gif" alt="image-20200729192410542"></p><p>其实HTTP协议中还⽀持着其他的⽅法，⽐如：Input、Delete、OPTIONS很多这样的⽅法。</p><p>⽽由于常⽤，于是我们也可能仅仅知道GET和POST⽅法了。 </p><p>HTTP提供⽅法的⽬的就是为了告知服务器该客户端想进⾏什么操作。当HTTP是OPTIONS⽅法的时候， 服务器端就会返回它⽀持什么HTTP⽅法。 当然了，现在RESTful盛⾏，也就是充分利⽤了HTTP协议的这些⽅法</p><p>RESTful  以后再专门总结一下（不然我怎么水博客）</p><h3 id="HTTP协议版本详解"><a href="#HTTP协议版本详解" class="headerlink" title="HTTP协议版本详解"></a>HTTP协议版本详解</h3><blockquote><p>版本这里有些枯燥，都是些知识点，作为了解可以跳过</p></blockquote><p>到现在为⽌，HTTP协议已经有四个版本了： </p><ul><li><p>HTTP/0.9</p><p>HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。</p></li><li><p>HTTP1.0</p><p>引入了新的命令POST和HEAD（http数据头部）命令，可自定义类型, 常见Content-Type值：text/xml image/jpeg audio/mp3</p><p>同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。</p><p>但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。</p></li><li><p>HTTP1.1</p><p>新增方法：PUT、PATCH、OPTIONS、DELETE，引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p></li><li><p>HTTP/2</p><p>HTTP2.0是SPDY（谷歌公司研发的https的一种协议）的升级版<br>1.头信息和数据体都是二进制，称为头信息帧和数据帧<br>2.复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）<br>3.引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度<br>4.HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）</p></li><li><p>HTTP/3 </p></li></ul><h4 id="HTTP1-0和HTTP1-1区别"><a href="#HTTP1-0和HTTP1-1区别" class="headerlink" title="HTTP1.0和HTTP1.1区别"></a>HTTP1.0和HTTP1.1区别</h4><blockquote><p>HTTP1.0和HTTP1.1最主要的区别就是： HTTP1.1默认是持久化连接！</p><p>在HTTP1.0默认是短连接：简单来说就是：每次与服务器交互，都需要新开⼀个连接！</p><p>在HTTP1.1中默认就使⽤持久化连接来解决：建⽴⼀次连接，多次请求均由这个连接完成！(如果阻塞 了，还是会开新的TCP连接的)</p></blockquote><blockquote><p>HTTP 1.1增加host字段</p></blockquote><blockquote><p>HTTP 1.1中引⼊了 Chunked transfer-coding ，范围请求，实现断点续传(实际上就是利⽤ HTTP消息头使⽤分块传输编码，将实体主体分块传输)</p></blockquote><blockquote><p>HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，⽽不⽤⼀个个等待响应之 后再请求</p><p>仅仅是提出了理论，浏览器默认关闭HTTP pipelining！</p></blockquote><h4 id="HTTP2和HTTP1-1的区别"><a href="#HTTP2和HTTP1-1的区别" class="headerlink" title="HTTP2和HTTP1.1的区别"></a>HTTP2和HTTP1.1的区别</h4><h5 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h5><p>管线化(pipelining)和⾮管线化的区别：</p><p><img src="https://img2.jimu98.cn/blog/20200729163522.png" srcset="/img/loading.gif" alt="image-20200729163522493"></p><blockquote><p>HTTP Pipelining其实是把多个HTTP请求放到⼀个TCP连接中⼀⼀发送，⽽在发送过程中不需要等 待服务器对前⼀个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应！</p></blockquote><blockquote><p>在HTTP1.0中，发送⼀次请求时，需要等待服务端响应了才可以继续发送请求。 在HTTP1.1中，发送⼀次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来⼀⼀接收 </p><p>所以说，⽆论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的 名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB</p></blockquote><blockquote><p>HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：多路复⽤ (Multiplexing)</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729164525.png" srcset="/img/loading.gif" alt="image-20200729164525340"></p><h5 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h5><blockquote><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议</p></blockquote><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><blockquote><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p></blockquote><h5 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h5><blockquote><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></blockquote><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><blockquote><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p></blockquote><h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP是⽆状态的，也就是说，它是不对通信状态进⾏保存的。它并不知道之前通信的对⽅是谁。这样 设计的⽬的就是为了让HTTP简单化，能够快速处理⼤量的事务！ </p><p>但是，我们经常是需要知道访问的⼈是谁，比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。（你说保存在用户的数据库里面，那首先得登录吧，我们平时用的京东之类的购物网站可不是这样，未登录状态下就可以添加购物车）于是就有了Cookie技术了。 </p><h4 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h4><blockquote><p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）</p></blockquote><blockquote><ol><li>首先用户在客户端浏览器向服务器发起登陆请求（或者不登录，但是第一次访问同样会给你一个cookie）</li><li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li><li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li><li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li></ol></blockquote><h4 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h4><blockquote><p>刚才说的cookie一个重要概念就是保存在本地，那如果我想区分用户权限，有一个用户是普通用户，我给了他VIP1权限，并且保存在了他的CK里面，但是他自己改成了VIP15，然后我的网站判断这个人拥有全部权限。。。。。于是。。。。。。</p><p>很明显，这样是不安全的，于是，类似的又有了一个session的机制，session把会话内容保存在服务器端</p></blockquote><blockquote><ol><li>首先用户在客户端浏览器发起登陆请求</li><li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。</li><li>客户端浏览器会把这个唯一的 session 标识保存在起来（一般保存在ck里面）</li><li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li></ol></blockquote><blockquote><p>大家会不会有一个疑问，说生成了一个session，又保存到了我的ck里面，那岂不是还是不安全，但是，我们可以抓包看一下</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729195513.png" srcset="/img/loading.gif" alt="image-20200729195513482"></p><blockquote><p>我们能从这么一个字符串看出任何有效信息吗（一般来说，我们都能往服务器存数据了，应该没人往前台写隐私信息吧，emmmm<del>~</del>应该不会吧）他只是给了我们一个ID，有效信息都在服务器，他会根据我们的ID去服务器查找有效信息，然后返回对应内容。</p></blockquote><h4 id="session和cookie有什么区别"><a href="#session和cookie有什么区别" class="headerlink" title="session和cookie有什么区别"></a>session和cookie有什么区别</h4><blockquote><ol><li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li><li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li><li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li><li>而 session 机制提供的会话是保存在服务端的。</li></ol></blockquote><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><blockquote><p>本块知识对细节要求较高，还是希望大家可以了解下ssl证书，以及非对称加密之类的概念</p><p>推荐先阅读码农翻身中关于https的小故事，然后再来理解https</p></blockquote><h3 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h3><blockquote><ol><li>通信使用明文不对数据进行加密（内容容易被窃听）</li><li>不验证通信方身份（容易伪装）</li><li>无法确定报文完整性（内容易被篡改）</li></ol><p>不安全：大家还记得我在计算机网络基础篇里面说的联网过程吗</p><p>从你家的网线出发，到小区的交换机，再到城市中央的路由器，再到小伙伴的小区交换机，再到小伙伴的电脑桌面。</p><p>任意一个环节都可以接入一台电脑，然后抓包，数据是可以被抓下来的。</p><p>比如我们传输一段 password：123456，那么黑客就直接可以看到了</p><p>但是我们传输一段 password：123456，使用加密技术之后 黑客可能看到的就是 E10ADC3949BA59ABBE56E057F20F883E</p></blockquote><blockquote><p>因此我们应该使用加密技术，但是码农翻身中 张大胖和Bill 的聊天，也指出了问题，如果中间人获取了他们的公钥，然后进行中间人攻击，那又失去了他的安全性。</p><p>于是乎，他们把自己的公钥交给，权威机构生成证书，权威机构在保证自己绝对安全的情况下，才能为整个互联网的安全做背书。</p></blockquote><h3 id="ssl证书"><a href="#ssl证书" class="headerlink" title="ssl证书"></a>ssl证书</h3><blockquote><p>SSL 协议就是用来解决 HTTP 传输过程的不安全问题，到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><p>（个人认为，大家还是喜欢把他叫做SSL，不信你去百度搜索下SSL证书和TLS证书，看看哪个广告多）</p><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p></blockquote><p>SSL/TLS协议的基本过程是这样的</p><blockquote><ol><li>服务端将非对称加密的公钥发送给客户端；</li><li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li><li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li><li>二者利用对称加密的key对需要传输的消息做加解密传输。</li></ol></blockquote><p>然后我们来看HTTPS</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS=HTTP+SSL</p><p>HTTPS也就是披着SSL羊皮的HTTP</p><p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。</p><h3 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h3><blockquote><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul></blockquote><blockquote><p>个人觉得，这个HTTPS加密流程作用性价比不高</p><p>又废资源又费钱（我用的免费的。。。）</p><p>而且我访问一个网站，黑客真的会在中间截获数据吗，我觉得更应该从源头或者目的来截获吧（可能是我网络安全知识薄弱，不太懂）</p><p>而且很明显，多了9次握手，那速度势必会影响 emmmm。。。</p></blockquote><h2 id="在浏览器中输入url地址，发生了什么？"><a href="#在浏览器中输入url地址，发生了什么？" class="headerlink" title="在浏览器中输入url地址，发生了什么？"></a>在浏览器中输入url地址，发生了什么？</h2><blockquote><ul><li>1.解析url地址，</li><li>2.DNS解析</li><li>3.TCP连接</li><li>4.发送HTTP请求</li><li>5.服务器处理请求</li><li>6.服务器返回HTTP报文</li><li>7.浏览器解析渲染页面</li></ul></blockquote><p>1.解析该url地址的域名，浏览器会检查这是一个url还是查询的关键字，然后自动编码，还会做一些安全检查</p><p>2.DNA解析的过程是递归的，下面以请求 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 为例：首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><p>3.HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><p>4.发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求体。请求行格式及示例如下：</p><pre><code class="hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">Request</span>-<span class="hljs-title">URL</span> <span class="hljs-title">HTTP</span>-<span class="hljs-title">Version</span> <span class="hljs-title">CRLF</span></span><span class="hljs-function"><span class="hljs-title">GET</span> <span class="hljs-title">index</span>.<span class="hljs-title">html</span> <span class="hljs-title">HTTP</span>/1.1</span></code></pre><p>常用的方法有：GET, POST, PUT, DELETE, OPTIONS, HEAD</p><p>5.服务器处理这里可说可不说</p><p><img src="https://img2.jimu98.cn/blog/20200731164923.png" srcset="/img/loading.gif" alt="image-20200731164923701"></p><p>6.后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应体。</p><p>7.浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p><p><img src="https://img2.jimu98.cn/blog/20200731165020.png" srcset="/img/loading.gif" alt="image-20200731165020227"></p><h2 id="向淘宝请求首页，怎么提高性能"><a href="#向淘宝请求首页，怎么提高性能" class="headerlink" title="向淘宝请求首页，怎么提高性能"></a>向淘宝请求首页，怎么提高性能</h2><blockquote><p>从请求、传输、渲染3个方面提升</p></blockquote><h3 id="一、请求"><a href="#一、请求" class="headerlink" title="一、请求"></a>一、请求</h3><p>浏览器为了减少请求传输，实现了自己的缓存机制。浏览器缓存就是把一个已经请求过的Web资源拷贝一份副本存储在浏览器中，当再次请求相同的URL时，先去查看缓存，如果有本地缓存，浏览器缓存机制会根据验证机制（Etag）和过期机制(Last-Modified)进行判断是使用缓存，还是从服务器传输资源文件。具体流程如下图所示：</p><p><img src="http://college.creditease.cn/resources/upload/image/20170925/1506321631051056382.png" srcset="/img/loading.gif" alt="img"></p><p>浏览器的请求有些是并发的，有些是阻塞的，比如：图片、CSS、接口的请求是并发；JS文件是阻塞的。请求JS的时候，浏览器会中断渲染进程，等待JS文件加载解析完毕，再重新渲染。所以要把JS文件放在页面的最后。</p><p>JS也可以通过两种方式由阻塞改成并行：一种是通过创建script标签，插入DOM中；另一种是在Script标签中增加async属性。</p><p>每种浏览器对同一域名并发的数量有限制，IE6/7是2，IE9是10，其他常见的浏览器是6，所以减少资源请求数量和使用多域名配置资源文件，能大大提高网站性能。</p><p>减少资源请求数量的方法，大致有以下几种：</p><p>1、通过打包工具，合并资源，减少资源数量。就是开发版本是很多个资源文件，部署的时候，按类合并成几个文件来输出。在实现模块管理的同时，实现统一输出。</p><p>2、CSS中，使用css sprite减少图片请求数量。</p><p>3、通过延迟加载技术，在用户无感知的情况下请求资源。</p><p>4、通过服务器配置，实现一次请求，返回多个资源文件，如淘宝CDN那样。</p><p>除了减少请求数量，也可以使用CDN镜像，来减少网络节点，实现快速响应。使用了CDN的请求，会根据用户所处的地理位置，找寻最近的CDN节点，如果请求是新的，则从资源服务器拷贝到节点，然后再返回给客户端。如果请求已经存在，则直接从节点返回客户端。</p><p>通过上面我们了解的缓存机制，如果我们部署上线的时候，是需要刷新缓存的。普通缓存通过强刷就能改过来，而CDN缓存则需要通过改变URL来实现。同时我们不可能要求用户按着Ctrl来刷新，所以通过打包工具，在部署的时候，统一更改URL是最有效的方式。而不常变更的库文件，比如echart、jquery，则不建议更改。</p><h3 id="二、传输"><a href="#二、传输" class="headerlink" title="二、传输"></a>二、传输</h3><p>从服务器往客户端传输，可以开启gzip压缩来提高传输效率。</p><p>Gzip有从1-10的十个等级。越高压缩的越小，但压缩使用的服务器硬件资源就越多。根据实践，等级为5的时候最均衡，此时压缩效果是100k可以压缩成20k。</p><h3 id="三、渲染"><a href="#三、渲染" class="headerlink" title="三、渲染"></a>三、渲染</h3><p>浏览器在加载了html后，就会一边解析，一边根据解析出来的结果进行资源请求，并生成DOM树。而加载完毕的CSS，则被渲染引擎根据生成好的DOM树，来生成渲染树。等所有资源解析完毕计算好layout后，向浏览器界面绘制。随着用户操作，JS会修改DOM节点或样式，重新绘制和重新排列。重新绘制指的是绘制DOM节点对应的渲染节点，重新排列是指重新计算这些节点在浏览器界面的位置。很显然，重排是非常耗性能的。我们要做的是减少重排的次数。</p><p>生成DOM树的时候，我们可以通过减少DOM节点来优化性能。最初都是用table布局，节点深度和数量相当复杂，性能很差。同样CSS作为层叠样式表，层级也不可太深，不然遍历的成本很高。另外CSS的expression属性相当耗性能，能不用则不用。动画效果能用CSS写的就不用JS写，渲染引擎不一样，性能损耗也不一样。</p><p>上面说的是解析渲染的过程，我们再接着说说用户交互操作的过程。用户操作就会导致重绘和重排，重排一定会引起重绘，而重绘不一定会引起重排。到底怎样会引起重排呢？简单的定义，DOM结构的变化，以及DOM样式中几何属性的变化，就会导致重排。几何属性顾名思义，就是宽、高、边框、外补丁、内补丁等俗称盒模型的属性。同时还有offset之类的边距属性。</p><p>重排是最耗能的，减少重排的方法有：</p><p>1、如果需要多次改变DOM，则先在内存中改变，最后一次性的插入到DOM中。</p><p>2、同上一条，如果多次改变样式，合成一条，再插入DOM中。</p><p>3、由于position的值为absoute和fixed时候，是脱离文档流的，操作此类DOM节点，不会引起整页重排。所以动画元素设置position使其脱离文档流。</p><p>4、当DOM节点的display等于none的时候，是不会存在于渲染树的，所以如果有比较复杂的操作，先使其display等于none，等待所有操作完毕后，再将display设成block，这样就只重排两次。</p><p>5、获取会导致重排的属性值时，存入变量，再次使用时就不会再次重排。获取这些属性会导致重排：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p><p>以上就是浏览器如何把资源变成肉眼所见的页面的，除了上述根据浏览器流程而总结出来的性能优化，我们还需要看看javascript作为程序，需要的优化。先来看看javascript的垃圾回收机制。</p><p>Javascript的引擎会在固定的时间间隔，将不再使用的局部变量注销掉，释放其所占的内存。而闭包的存在，将使引用一直存在，无法被释放掉。全局变量的生命周期直至浏览器卸载页面才会结束。所以一般来讲，内存溢出就是由于全局变量的不释放和闭包引起。为了防止内存溢出，我们可以做的方法有:</p><p>1、业务代码放在匿名立即执行函数里面，执行完毕会立即释放掉。</p><p>2、少用全局变量，同时用完的变量手动注销掉。</p><p>3、使用回调来代替闭包访问内部属性</p><p>4、当不可避免使用闭包时，慎重的对待其中的细节。不用的时候注销掉。</p><p>5、通过浏览器自带的工具profiles，来检查内存活动情况。如果是波浪型的，说明正常。如果是倾斜式渐进上涨的，说明有内存不会被释放，需要检查相应的函数。</p><p>最后再说一点，函数里返回异步取的值，经常有人这么：</p><pre><code class="hljs routeros">Var getList = function()&#123; $.ajax().then(function(data)&#123;  Return data;&#125;) &#125;;Var<span class="hljs-built_in"> users </span>= getList();</code></pre><p>毫无疑问，由于函数内的返回是异步的，所以返回只能是undefined，而不是想要的data。于是为了实现返回data，就把ajax的async属性设置成了false，由异步改为同步，来获取到data。然而最大的问题来了，同步是会中断渲染进程的，也就是请求返回的等待中，整个页面是卡死的，用户操作也不会有响应。这个问题真正的解决方案是返回promise对象，而不是把异步改成同步。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】计算机网络-基础篇</title>
    <link href="/posts/62807/"/>
    <url>/posts/62807/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】计算机网络-基础篇"><a href="#【java总结】计算机网络-基础篇" class="headerlink" title="【java总结】计算机网络-基础篇"></a>【java总结】计算机网络-基础篇</h1><blockquote><p>本内容参考了多位大佬，几十篇博客整理出来的，方便自己的复习，同时有不全面，不正确的内容欢迎补充</p><p>计算机网络-HTTP 篇 <a href="https://www.jimu98.cn/2020/07/29/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/">点这里</a></p></blockquote><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h3><p>那我们作为一个程序员，难免会去编写一些通信类应用，甚至开发桌面端应用（好像C++更多吧），就算你是一个前端，那么总是要和后台取数据吧，天天post，get，我们也总要学一些计算机网络知识。（详细学习的话强烈推荐谢希仁老师的计算机网络）</p><p>那么什么是计算机网络呢？</p><p>很多书都是这么一句话：计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。</p><p>我们生活中从电脑出发，背后连接着一根网线（如果使用的无线，那么就把他当作一根看不见的线）然后这跟网线连接到家里墙上的一个出口，然后这个出口连接到小区的汇聚交换机上面，然后中间经过其他交换机，路由器，再连接到我们这个城市的中心路由器上面。其他城市的小伙伴同样这样，然后两个城市间架起一座桥梁（我们这里暂时只把他记作光纤），那么，网络就是这样。</p><blockquote><p>从宏观上面来看，就是这么简单</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728203448.png" srcset="/img/loading.gif" alt="image-20200728203448182"></p><p>但是我们继续想，网络可能同时有大量的数据，同时在光纤上面传输，而且还同时有大量的人发送，</p><p>我们怎么才能在光纤上传递文字，图片，甚至音频，接受到你的消息以后，你怎么把他还原，看一看他到第是什么</p><p>于是乎，网络又变得复杂了起来，甚至复杂到一种很难解释的情况。</p><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>（举个例子：一个皇帝又管大家吃饭，又管外出打仗，这时候还要考虑王阿姨家的猫和另一个省的一条狗重名了，王阿姨不乐意了，可是生活就是这样，皇帝于是决定周一处理打仗的事情，周三处理王阿姨的事情，情况有所缓解，于是乎他设立了不同的官员去做不同的事情，就这样，把大事分成小事去做就解决了这个问题）</p><p>这时候，有人提出来，我们把网络分层，每一层只处理本层的事情，处理完再传递给下一层</p><p>于是ISO（国际标准化组织）提出了OSI/RM（开放系统互连参考模型）大家根据单词首字母简单记一下</p><p>这个组织把网络通信分为了七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>但是有趣的是ISO提出来以后没啥产品，于是伴随着Internet火遍大江南北，TCP/IP才成为真正使用的协议</p><p>更有趣的TCP/IP的四层把物理层和数据链路层给合并了，但是物理层这么重要的一层，直接跟物理设备打交道，这也太没面子了</p><p>而且最主要的人类思考起来不太方便，那么我们经常说的是TCP/IP的五层模型</p><p><img src="https://img2.jimu98.cn/blog/20200728212643.png" srcset="/img/loading.gif" alt="image-20200728212643527"></p><blockquote><p>这张图还是要背的，有些时候理解不了的知识，那么就去背。背会了，慢慢就理解了。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200731170532.gif" srcset="/img/loading.gif" alt="1403129_1582549890987_005L0VzSly1gc53dab9gvg30v41830yk"></p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>（举个例子，小A和小B要通讯，小A要给小B发送一幅蒙娜丽莎，但是光纤可不能直接发送画呀，只能发送0，1字符串，于是小A发送了 1100111代表蒙娜丽莎，小B收到了，非要翻译成清明上河图，你说这闹的。。。）</p><p>所以通信双方想要通信，必须建立约定，约定好1100111就是蒙娜丽莎，约定就可以称作协议，因此通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><p>换个例子</p><p>小A和小B要通讯，比作小A给小B寄快递</p><p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p><p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p><p><code>ping</code> 可以说是网络层ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-IP解释"><a href="#TCP-IP解释" class="headerlink" title="TCP/IP解释"></a>TCP/IP解释</h3><p>这个分层相当重要，前面也说过了，TCP/IP才是我们真正实现了的协议（那么我们到底说的是四层呢还是五层呢，在生活中常用五层，但是TCP/IP提出时候就是四层，但是大家不要迷惑，你就站在他们头顶，聊到四层，就往四层想，聊到五层，就往五层想，游刃有余的时候，就能感觉到，他们就是一个东西，emmm，这里我有点说不清楚。。）</p><blockquote><p>另外，TCP/IP是一个协议簇，也就是一个组合，包含了多种协议，但是TCP和IP最具代表性，所以被称为TCP/IP协议。</p></blockquote><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>它们都属于传输层协议,</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p><p><img src="https://img2.jimu98.cn/blog/20200810232133.png" srcset="/img/loading.gif" alt="image-20200810232133417"></p><blockquote><p>① URG: 表示紧急指针是否有效<br>② ACK: 表示确认号是否有效(携带ACK标志的TCP报文段称为确认报文段)<br>③ PSH: 提示接收端应用程序要立即从TCP接收缓冲区读走数据，以腾出空间接收后续的数据。(若应用程序不读走数据，数据会一直留在TCP模块的接收缓冲区)<br>④ RST: 表示要求对方重新建立连接(携带RST标志的TCP报文段为复位报文段)<br>⑤ SYN: 表示请求建立一个连接(携带SYN标志的TCP报文段称为同步报文段)<br>⑥ FIN: 表示通知对方要关闭连接(携带FIN标志的TCP报文段为结束报文段)</p></blockquote><h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP  三次握手"></a>TCP  三次握手</h5><blockquote><p>这个好多人都吃过亏，感觉好复杂，我觉得码农翻身里面这一段解释的特别简单</p><p>第一次：A跟B说话   B收到了 B知道A发送消息没问题</p><p>第二次：B跟A说话   A收到了  A知道B发送和接收都没问题</p><p>第三次：A跟B说话   B收到了  B知道A发送和接收都没问题</p><p>于是乎，A和B可以正常通讯了</p></blockquote><p>为什么需要三次握手呢？两次不行吗？</p><blockquote><p>在谢希仁的《计算机网络》中是这样说的：”为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。”</p><p>我们先要知道TCP是基于IP协议的（下面有解释），而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。</p><p>比如A和B说话，A跟B说：“在吗，借我一块钱”，B回答他：“给你转到支付宝了”，但是B说的这句话走的一条很漫长的路，走了一分钟。</p><p>但是A说完了，等了好久B都不理他，他以为B就没收到他说的话，他又发了一句话：“在吗，借我一块钱”，这时候B又收到了，他不知道这是A从新发送的，以为又建立了一个新的通话连接，于是这个过程就会浪费很多的资源，而三次握手就相对保险。</p></blockquote><p>简单的理解了，那我们也要看看复杂的情况（我会尽量说的清楚）</p><p>暂时只看绿色部分的三次握手（状态大家可以百度一下TCP11种状态，我感觉直接翻译可能更乱）</p><blockquote><p>1.第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x（也就是随机值）；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</p><p>2.第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RCVD</code>状态；</p><p>3.第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729161601.png" srcset="/img/loading.gif" alt="image-20200729161600822"></p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><blockquote><p>举个栗子：把客户端比作男孩，服务器比作女孩。通过他们的分手来说明“四次挥手”过程。</p><p>“第一次挥手”：男孩发现女孩变成了自己讨厌的样子，忍无可忍，于是决定分手，随即写了一封信告诉女孩。</p><p>“第二次挥手”：女孩收到信之后，知道了男孩要和自己分手，怒火中烧，心中暗骂：你算什么东西，当初你可不是这个样子的！于是立马给男孩写了一封回信：分手就分手，给我点时间，我要把你的东西整理好，全部还给你！男孩收到女孩的第一封信之后，明白了女孩知道自己要和她分手。随后等待女孩把自己的东西收拾好。</p><p>“第三次挥手”：过了几天，女孩把男孩送的东西都整理好了，于是再次写信给男孩：你的东西我整理好了，快把它们拿走，从此你我恩断义绝！</p><p>“第四次挥手”：男孩收到女孩第二封信之后，知道了女孩收拾好东西了，可以正式分手了，于是再次写信告诉女孩：我知道了，这就去拿回来！（这里有一个重要的概念 <code>TIME-WAIT</code> 阿正哥说这个可以比作冷静期 emmm~）</p><p>这里双方都有各自的坚持。女孩自发出第二封信开始，限定一天内收不到男孩回信，就会再发一封信催促男孩来取东西！</p><p>男孩自发出第二封信开始，限定两天内没有再次收到女孩的信就认为，女孩收到了自己的第二封信；若两天内再次收到女孩的来信，就认为自己的第二封信女孩没收到，需要再写一封信，再等两天…..</p><p>倘若双方信都能正常收到，最少只用四封信就能彻底分手！这就是“四次挥手”。</p></blockquote><blockquote><p>上面的解释应该很清楚解释了为什么是四次挥手</p><p><strong>这里强调一下TIME-WAIT的概念</strong></p><p>因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。</p><p><strong>什么是MSL？</strong></p><p>MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。 关于MSL的大小，RFC<br>793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，<br>以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，并且这个数值是硬编码在内核中的，<br>也就是说除非你重新编译内核，否则没法修改它：</p><p><strong>为什么客户端在TIME-WAIT阶段要等2MSL?</strong></p><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p><p><strong>如果没有time_wait会怎么样？</strong><br> 我们举一个比较简单的例子：假设服务端发送了断开请求的包，（假设没有TIME_WAIT），客户端收到后立马就回复了确认包，连接就关闭了，但是服务器这边其实还有一个数据在路上，到了之后会发现客户端已经关闭了，一脸懵逼的收到了一个RST包，然后也关闭了连接，这样就导致了数据包的丢失。</p></blockquote><h5 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h5><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><blockquote><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方。首先接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>定义流量窗口为接收缓存剩余的空间。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p></blockquote><h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h6><blockquote><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p></blockquote><p>流量控制之滑动窗口机制</p><blockquote><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728230255.png" srcset="/img/loading.gif" alt="image-20200728230255200"></p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上，是不是很随便，大家记住他很随便就可以了</p><h4 id="TCP与UDP区别及应用"><a href="#TCP与UDP区别及应用" class="headerlink" title="TCP与UDP区别及应用"></a>TCP与UDP区别及应用</h4><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">传输效率低</td><td align="left">传输效率高</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口</td><td align="left">无</td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始、拥塞避免、快重传、快恢复</td><td align="left">无</td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场合</td><td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td><td align="left">对效率要求高，对准确性要求低</td></tr></tbody></table><p><img src="https://img2.jimu98.cn/blog/20200728221157.png" srcset="/img/loading.gif" alt="image-20200728221157748"></p><h3 id="IP解释"><a href="#IP解释" class="headerlink" title="IP解释"></a>IP解释</h3><p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”</strong>，它们携带的货物就是像HTTP，FTP这样的协议等。</p><p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p><h3 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h3><blockquote><p>首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，</p><p>如果有，就直接将数据包发送到这个MAC地址；<br>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</p><p>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。</p><p>如果不相同就忽略此数据包；<br>如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；</p><p>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></blockquote><h3 id="常见的路由选择协议，以及它们的区别"><a href="#常见的路由选择协议，以及它们的区别" class="headerlink" title="常见的路由选择协议，以及它们的区别"></a>常见的路由选择协议，以及它们的区别</h3><p><strong>RIP协议</strong>（路由信息协议）：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong>（开放最短路径优先）：底层是迪杰斯特拉算法，它选择路由的度量标准是带宽，延迟。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>网络分层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】JUC多线程与高并发</title>
    <link href="/posts/13586/"/>
    <url>/posts/13586/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】JUC多线程与高并发"><a href="#【java总结】JUC多线程与高并发" class="headerlink" title="【java总结】JUC多线程与高并发"></a>【java总结】JUC多线程与高并发</h1><p>占个位置  ，日后更新</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>JUC</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】框架之SpringCloud</title>
    <link href="/posts/5671/"/>
    <url>/posts/5671/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】框架之SpringCloud"><a href="#【java总结】框架之SpringCloud" class="headerlink" title="【java总结】框架之SpringCloud"></a>【java总结】框架之SpringCloud</h1><h1 id="SpringCloud基础"><a href="#SpringCloud基础" class="headerlink" title="SpringCloud基础"></a>SpringCloud基础</h1><h2 id="什么是-spring-cloud？"><a href="#什么是-spring-cloud？" class="headerlink" title="什么是 spring cloud？"></a>什么是 spring cloud？</h2><blockquote><p>spring cloud 是一系列框架的有序集合。是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200809203031.png" srcset="/img/loading.gif" alt="image-20200809203030808"></p><h1 id="SpringCloud组件"><a href="#SpringCloud组件" class="headerlink" title="SpringCloud组件"></a>SpringCloud组件</h1><blockquote><p>alibaba的统一放到下面那个模块说，这里复习传统框架</p></blockquote><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><blockquote><p>Eureka是netflix公司研发并且开源的一个服务发现组件。</p></blockquote><p>Eureka组件包含注册中心（Eureka Server）和eureka客户端。</p><p>服务注册中心：Eureka客户端会把自身服务注册到注册中心，为其他Eureka客户端提供服务，Eureka客户端通过注册中心相互发现对应服务并进行调用</p><p>Eureka客户端：相对注册中心而言，所有注册到服务注册中心的服务都可以表述为Eureka客户端；但是站在提供方和消费方的角度看，Eureka客户端又可以称之为服务端</p><blockquote><p>客户端有一个内置的，使用轮询的负载算法，向所有服务器发送心跳（默认30s），如果服务器多个心跳周期都没有接受到，就会从服务列表中把这个节点移除（默认90s）</p></blockquote><h4 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h4><p>首先你要创建一个eureka的服务端,弄一个Model,然后给它的pom文件加上:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka-server服务端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>表示这是一个eureka的服务端</p><p>然后在这个服务端的主启动类上加上注解:</p><blockquote><p>@EnableEurekaServer   //标注这是个eureka服务端</p></blockquote><p>然后在编写yml配置文件:</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><span class="hljs-comment">#端口号</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#eureka服务端的实例名称</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示不向注册中心注册自己。</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span>    <span class="hljs-attr">service-url:</span>     <span class="hljs-comment">#设置与Eureka  单机</span>       <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre><p>这个服务端就算搭建好了,之后我们需要在我们的被调用方中配置,将其注册进我们的eureka中:</p><p>首先是pom文件:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>然后在启动类上加上注解:</p><blockquote><p>@EnableEurekaClient  //本服务启动后会自动注册进eureka服务中，服务发现</p></blockquote><p>最后依然是在配置文件中加上:</p><pre><code class="hljs yaml"><span class="hljs-comment">#客户端注册进rureka服务列表内</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span><span class="hljs-comment">#这个url就是服务端的url</span></code></pre><p>首先启动我们的eureka服务端,再启动我们的客户端,也就是在微服务中被调用端</p><p>访问localhost:7001就会出现以下页面:红框就是我们注册进去的服务,出现在这里也就说明注册成功,这个服务名是根据客户端的配置文件中配置得来的.</p><p><img src="https://img2.jimu98.cn/blog/20200809205030.png" srcset="/img/loading.gif" alt="image-20200809205030554"></p><h5 id="Eureka的集群"><a href="#Eureka的集群" class="headerlink" title="Eureka的集群"></a>Eureka的集群</h5><blockquote><p>Eureka的集群很简单，在yml文件defaultZone配置多个地址即可</p></blockquote><h4 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h4><blockquote><ul><li>为了保证EurekaClient可以正常运行，当网络发生故障的时候，不应该删除客户端节点</li><li>当某个节点短时间丢失过多客户端时，那么这个节点就会进入自我保护模式</li><li>默认自我保护开启：eureka.server.enable-self-preservation = true</li></ul></blockquote><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>服务提供者在启动时，会向EurekaServer发起一次请求，将自己注册到Eureka注册中心中去</p><h4 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h4><p>在注册服务完成以后，服务提供者会维持一个心跳 （每30s定时向EurekaServer发起请求）， 告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><h4 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h4><p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。</p><p>因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><h5 id="zookeeper和eureka的区别在哪"><a href="#zookeeper和eureka的区别在哪" class="headerlink" title="zookeeper和eureka的区别在哪?"></a>zookeeper和eureka的区别在哪?</h5><p>eureka遵守AP原则,zookeeper遵守CP原则</p><blockquote><p>CA-单点集群,满足一致性,可用性的系统,通常在可扩展性上不太强大<br>CP-满足一致性,分区容忍必的系统,通常性能不是特别高。<br>AP-满足可用性,分区容忍性的系统,通常可能对一致性要求低一些</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200809210412.png" srcset="/img/loading.gif" alt="image-20200809210412328"></p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><blockquote><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p></blockquote><h4 id="使用流程-1"><a href="#使用流程-1" class="headerlink" title="使用流程"></a>使用流程</h4><p>首先启动Zookeeper服务器</p><p>然后创建一个服务提供者</p><blockquote><p>pom引入相应的包</p><p>yml填写zookeeper服务器地址</p><p>主启动要加上@EnableDiscoveryClient注解 该注解用于向consul，zookeeper作为注册中心时注册服务</p></blockquote><p>然后创建服务消费者</p><ul><li>yml需要配置</li><li>pom引入相应的包</li><li>yml填写zookeeper服务器地址</li><li>主启动要加上@EnableDiscoveryClient注解 该注解用于向consul，zookeeper作为注册中心时注册服务</li></ul><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><blockquote><p>Consul是一套开源的分布式服务发现和配置管理系统，Go语言开发的</p></blockquote><p>使用流程和zookeeper类似</p><h3 id="三个注册中心的异同点"><a href="#三个注册中心的异同点" class="headerlink" title="三个注册中心的异同点"></a>三个注册中心的异同点</h3><p><img src="https://api2.mubu.com/v3/document_image/6b782435-e2f0-4f3b-86ce-83a77ed4916a-1015484.jpg" srcset="/img/loading.gif" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/ff363757-a70d-46a5-b0c8-1b74ca261441-1015484.jpg" srcset="/img/loading.gif" alt="image"></p><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><blockquote><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端，负载均衡的软件</p></blockquote><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="集中式LB"><a href="#集中式LB" class="headerlink" title="集中式LB"></a>集中式LB</h5><p>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</p><h5 id="进程内LB"><a href="#进程内LB" class="headerlink" title="进程内LB"></a>进程内LB</h5><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。<br>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><h4 id="使用流程-2"><a href="#使用流程-2" class="headerlink" title="使用流程"></a>使用流程</h4><p>先编写以下的配置文件:</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>    <span class="hljs-attr">application:</span>        <span class="hljs-attr">name:</span> <span class="hljs-string">spring-cloud-ribbon</span><span class="hljs-attr">server:</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><span class="hljs-attr">ping-server:</span>    <span class="hljs-attr">ribbon:</span>        <span class="hljs-attr">eureka:</span>            <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">listOfServers:</span> <span class="hljs-string">localhost:9092,localhost:9999</span>        <span class="hljs-attr">ServerListRefreshInterval:</span> <span class="hljs-number">15000</span></code></pre><p>然后创建一个RestTemplate的bean</p><p>之后注入测试</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RibbonClient</span>(name = <span class="hljs-string">"ping-a-server"</span>,configuration = RibbonConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ServerLocationApp</span> </span>&#123;    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/server-location"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serverLocation</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(            <span class="hljs-string">"http://ping-server/locaus"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServerLocationApp<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>也可以通过bean来设置规则</p><p>主启动类添加@RibbonClient</p><h4 id="Ribbon的负载算法"><a href="#Ribbon的负载算法" class="headerlink" title="Ribbon的负载算法"></a>Ribbon的负载算法</h4><blockquote><ul><li>RoundRobinRule： 默认轮询的方式</li><li>RandomRule： 随机方式</li><li>WeightedResponseTimeRule： 根据响应时间来分配权重的方式，响应的越快，分配的值越大。</li><li>BestAvailableRule： 选择并发量最小的方式</li><li>RetryRule： 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</li><li>ZoneAvoidanceRule： 根据性能和可用性来选择。</li><li>AvailabilityFilteringRule： 过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</li></ul></blockquote><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>Feign是一个声明式的Web服务客户端,让编写Web服务客户端变得非常容易,只需 创建一个接口并在接口上添加注解即可</p><p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求进行封装，因此，Fergn是进一步的封装，Feign内置了Ribbon，用来做<strong>客户端负载均衡</strong>，OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如<code>@RequesMapping</code>等等。</p><p>OpenFeign的<code>@FeignClient</code>可以解析SpringMVC的<code>@RequestMapping</code>注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>主启动类增加 @EnableFeignClients 注解</p><p>在业务上面直接标注如：@FeignClient(name = “user-center”)</p><h5 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h5><p>OpenFeign默认等一秒钟，所以需要在yml配置文件中配置ribbon的等待时间</p><p><img src="https://api2.mubu.com/v3/document_image/61e1b4a8-7fb7-48b3-855c-89905411f61a-1015484.jpg" srcset="/img/loading.gif" alt="image"></p><h5 id="OpenFeign日志功能"><a href="#OpenFeign日志功能" class="headerlink" title="OpenFeign日志功能"></a>OpenFeign日志功能</h5><ul><li><p>日志级别<img src="https://api2.mubu.com/v3/document_image/863dd2e0-d5b4-4877-a16d-57f32113edfa-1015484.jpg" srcset="/img/loading.gif" alt="img"></p></li><li><p>配置日志Bean</p><p><img src="https://api2.mubu.com/v3/document_image/4aad5579-b54b-4623-9c39-7f8fb7c0992a-1015484.jpg" srcset="/img/loading.gif" alt="img"></p></li><li><p>yml要开启日志</p><p><img src="https://api2.mubu.com/v3/document_image/79ac7075-18e6-4111-8b1d-8dc328437a8e-1015484.jpg" srcset="/img/loading.gif" alt="img"></p></li></ul><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><h3 id="分布式面临的问题"><a href="#分布式面临的问题" class="headerlink" title="分布式面临的问题"></a>分布式面临的问题</h3><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p><ul><li>服务雪崩</li></ul><p>假设存在如下调用链</p><p><img src="https://img2.jimu98.cn/blog/20200809230835.png" srcset="/img/loading.gif" alt="image-20200809230835604"></p><p><img src="https://img2.jimu98.cn/blog/20200809230821.png" srcset="/img/loading.gif" alt="image-20200809230821438"></p><p>如上图所示，一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。</p><p>怎么解决？<code>服务熔断</code>和<code>服务降级</code>就可以视为解决服务雪崩的手段之一。</p><h4 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h4><blockquote><p>服务器忙，请稍后再试，返回一个友好提示，fallback，或者启动备用方案</p></blockquote><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><blockquote><p>保险丝达到最大服务访问后，拉闸限电，然后调用服务降级的方法并返回友好提示</p></blockquote><h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><blockquote><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p></blockquote><h3 id="Hystrix（豪猪哥）"><a href="#Hystrix（豪猪哥）" class="headerlink" title="Hystrix（豪猪哥）"></a>Hystrix（豪猪哥）</h3><blockquote><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。</p><p>“断路器”本身是一种开关设置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出服务方无法处理的异常，这样就保证服务方调用线程不会被长时间、不必要的占用，从而避免故障在在分布式系统中的绵延，乃至雪崩。</p></blockquote><h4 id="使用流程-3"><a href="#使用流程-3" class="headerlink" title="使用流程"></a>使用流程</h4><p>首先新建一个服务提供者</p><p>引入相应地pom</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Hystrix依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>然后配置yml</p><pre><code class="hljs yaml"><span class="hljs-comment">#服务实例名称修改</span><span class="hljs-attr">instance-id:</span> <span class="hljs-string">lingluocloud-dept8001-hystrix</span></code></pre><p>然后在业务类标注</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"paymentInfo_TimeOutHandler"</span>,commandProperties = &#123;<span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value = <span class="hljs-string">"3000"</span>) <span class="hljs-comment">//3秒钟以内就是正常的业务逻辑</span></code></pre><p>然后在主启动类 添加@EnableCircuitBreaker注解</p><h5 id="解决代码膨胀"><a href="#解决代码膨胀" class="headerlink" title="解决代码膨胀"></a>解决代码膨胀</h5><blockquote><p>@DefaultProperties(defaultFallback = “”) //在controller类上标注，如果配置了兜底方法，就按照自己的来，如果没有的话就按照这里配置的</p></blockquote><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><h3 id="gataway"><a href="#gataway" class="headerlink" title="gataway"></a>gataway</h3><blockquote><p>SpringCloud在之前是使用的<code>netflix</code>公司zuul，后来<code>zuul1</code>的性能表现不是很理想，而且<code>zuul2.0</code>连续跳票，所以催生了spring团队开发了<code>Gateway</code>项目。</p></blockquote><p>API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。</p><h4 id="Nginx和gataway的区别"><a href="#Nginx和gataway的区别" class="headerlink" title="Nginx和gataway的区别"></a>Nginx和gataway的区别</h4><ul><li>像Nginx这类网关，性能肯定是没得说，它适合做那种门户网关，是作为整个全局的网关，是对外的，处于最外层的；而Gateway这种，更像是业务网关，主要用来对应不同的客户端提供服务的，用于聚合业务的。各个微服务独立部署，职责单一，对外提供服务的时候需要有一个东西把业务聚合起来。</li><li>像Nginx这类网关，都是用不同的语言编写的，不易于扩展；而Gateway就不同，它是用Java写的，易于扩展和维护</li><li>Gateway这类网关可以实现熔断、重试等功能，这是Nginx不具备的</li></ul><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><blockquote><p>对于一些简单的项目来说，我们一般都是直接把相关配置放在单独的配置文件中，以 properties 或者 yml 的格式出现，更省事儿的方式是直接放到 application.properties 或 application.yml 中。但是这样的方式有个明显的问题，那就是，当修改了配置之后，必须重启服务，否则配置无法生效。</p><p>目前有一些用的比较多的开源的配置中心，比如携程的 Apollo、蚂蚁金服的 disconf 等，对比 Spring Cloud Config，这些配置中心功能更加强大。有兴趣的可以拿来试一试。</p></blockquote><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>最简单的配置中心，就是启动一个服务作为服务方，之后各个需要获取配置的服务作为客户端来这个服务方获取配置。</p><p>先在 github 中建立配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">data:</span>  <span class="hljs-attr">env:</span> <span class="hljs-string">config-eureka-dev</span>  <span class="hljs-attr">user:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">eureka-client-user</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span></code></pre><p>创建配置中心服务端</p><p>新建 Spring Boot 项目，引入 config-server 和 starter-web</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- spring cloud config 服务端包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置 config 相关的配置项</p><p>bootstrap.yml 文件</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-single-server</span>  <span class="hljs-comment"># 应用名称</span>  <span class="hljs-attr">cloud:</span>     <span class="hljs-attr">config:</span>        <span class="hljs-attr">server:</span>          <span class="hljs-attr">git:</span>            <span class="hljs-attr">uri:</span> <span class="hljs-string">https://github.com/huzhicheng/config-only-a-demo</span> <span class="hljs-comment">#配置文件所在仓库</span>            <span class="hljs-attr">username:</span> <span class="hljs-string">github</span> <span class="hljs-string">登录账号</span>            <span class="hljs-attr">password:</span> <span class="hljs-string">github</span> <span class="hljs-string">登录密码</span>            <span class="hljs-attr">default-label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#配置文件分支</span>            <span class="hljs-attr">search-paths:</span> <span class="hljs-string">config</span>  <span class="hljs-comment">#配置文件所在根目录</span></code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">3301</span></code></pre><p>在 Application 启动类上增加相关注解 <code>@EnableConfigServer</code></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableConfigServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>启动服务，接下来测试一下。新建 Spring Boot 项目，引入 config-server 和 starter-web</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- spring cloud config 服务端包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置 config 相关的配置项</p><p>bootstrap.yml 文件</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-single-server</span>  <span class="hljs-comment"># 应用名称</span>  <span class="hljs-attr">cloud:</span>     <span class="hljs-attr">config:</span>        <span class="hljs-attr">server:</span>          <span class="hljs-attr">git:</span>            <span class="hljs-attr">uri:</span> <span class="hljs-string">https://github.com/huzhicheng/config-only-a-demo</span> <span class="hljs-comment">#配置文件所在仓库</span>            <span class="hljs-attr">username:</span> <span class="hljs-string">github</span> <span class="hljs-string">登录账号</span>            <span class="hljs-attr">password:</span> <span class="hljs-string">github</span> <span class="hljs-string">登录密码</span>            <span class="hljs-attr">default-label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#配置文件分支</span>            <span class="hljs-attr">search-paths:</span> <span class="hljs-string">config</span>  <span class="hljs-comment">#配置文件所在根目录</span></code></pre><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">3301</span></code></pre><p>在 Application 启动类上增加相关注解 <code>@EnableConfigServer</code></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableConfigServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>启动服务，接下来测试一下。</p><p>Spring Cloud Config 有它的一套访问规则，我们通过这套规则在浏览器上直接访问就可以。</p><pre><code class="hljs yaml"><span class="hljs-string">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><span class="hljs-string">/&#123;application&#125;-&#123;profile&#125;.yml</span><span class="hljs-string">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><span class="hljs-string">/&#123;application&#125;-&#123;profile&#125;.properties</span><span class="hljs-string">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span></code></pre><p>{application} 就是应用名称，对应到配置文件上来，就是配置文件的名称部分，例如我上面创建的配置文件。</p><p>{profile} 就是配置文件的版本，我们的项目有开发版本、测试环境版本、生产环境版本，对应到配置文件上来就是以 application-{profile}.yml 加以区分，例如application-dev.yml、application-sit.yml、application-prod.yml。</p><p>{label} 表示 git 分支，默认是 master 分支，如果项目是以分支做区分也是可以的，那就可以通过不同的 label 来控制访问不同的配置文件了。</p><p><em>创建配置中心客户端，使用配置</em></p><p>配置中心服务端好了，配置数据准备好了，接下来，就要在我们的项目中使用它了。</p><p>1、引用相关的 maven 包。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- spring cloud config 客户端包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2、初始化配置文件</p><p>bootstrap.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><span class="hljs-meta">---</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-single-client</span>  <span class="hljs-attr">cloud:</span>     <span class="hljs-attr">config:</span>       <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3301</span>       <span class="hljs-attr">label:</span> <span class="hljs-string">master</span>       <span class="hljs-attr">profile:</span> <span class="hljs-string">prod</span><span class="hljs-meta">---</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-single-client</span>  <span class="hljs-attr">cloud:</span>     <span class="hljs-attr">config:</span>       <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3301</span>       <span class="hljs-attr">label:</span> <span class="hljs-string">master</span>       <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span></code></pre><p>配置了两个版本的配置，并通过 spring.profiles.active 设置当前使用的版本，例如本例中使用的 dev 版本。</p><p>application.yml</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">3302</span><span class="hljs-attr">management:</span>  <span class="hljs-attr">endpoint:</span>    <span class="hljs-attr">shutdown:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">"*"</span><span class="hljs-attr">data:</span>  <span class="hljs-attr">env:</span> <span class="hljs-string">NaN</span>  <span class="hljs-attr">user:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">NaN</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">NaN</span></code></pre><p>其中 management 是关于 actuator 相关的，接下来自动刷新配置的时候需要使用。</p><p>data 部分是当无法读取配置中心的配置时，使用此配置，以免项目无法启动。</p><p>3、要读取配置中心的内容，需要增加相关的配置类，Spring Cloud Config 读取配置中心内容的方式和读取本地配置文件中的配置是一模一样的。可以通过 @Value 或 @ConfigurationProperties 来获取。</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>4、要读取配置中心的内容，需要增加相关的配置类，Spring Cloud Config 读取配置中心内容的方式和读取本地配置文件中的配置是一模一样的。可以通过 @Value 或 @ConfigurationProperties 来获取。</p><p>使用 @Value 的方式：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;data.env&#125;"</span>)    <span class="hljs-keyword">private</span> String env;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;data.user.username&#125;"</span>)    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;data.user.password&#125;"</span>)    <span class="hljs-keyword">private</span> String password;&#125;</code></pre><p>使用 @ConfigurationProperties 的方式：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"data"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitAutoRefreshConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;        <span class="hljs-keyword">private</span> String username;        <span class="hljs-keyword">private</span> String password;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> username;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;            <span class="hljs-keyword">this</span>.username = username;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> password;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;            <span class="hljs-keyword">this</span>.password = password;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"UserInfo&#123;"</span> +                    <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +                    <span class="hljs-string">", password='"</span> + password + <span class="hljs-string">'\''</span> +                    <span class="hljs-string">'&#125;'</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> String env;    <span class="hljs-keyword">private</span> UserInfo user;&#125;</code></pre><h4 id="实现自动刷新"><a href="#实现自动刷新" class="headerlink" title="实现自动刷新"></a>实现自动刷新</h4><p>在 config client 端配置中增加 actuator 配置，上面大家可能就注意到了。</p><pre><code class="hljs yaml"><span class="hljs-attr">management:</span>  <span class="hljs-attr">endpoint:</span>    <span class="hljs-attr">shutdown:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">"*"</span></code></pre><p>其实这里主要用到的是 refresh 这个接口</p><p>2、在需要读取配置的类上增加 @RefreshScope 注解，我们是 controller 中使用配置，所以加在 controller 中。</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RefreshScope</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> GitConfig gitConfig;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> GitAutoRefreshConfig gitAutoRefreshConfig;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"show"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> gitConfig;    &#125;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"autoShow"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">autoShow</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> gitAutoRefreshConfig;    &#125;&#125;</code></pre><p>注意，以上都是在 client 端做的修改。</p><p>之后，重启 client 端，重启后，我们修改 github 上的配置文件内容，并提交更改，再次刷新页面，没有反应。没有问题。</p><p>接下来，我们发送 POST 请求到 <a href="http://localhost:3302/actuator/refresh" target="_blank" rel="noopener">http://localhost:3302/actuator/refresh</a> 这个接口，用 postman 之类的工具即可，此接口就是用来触发加载新配置的</p><p><em>在 github 中配置 Webhook</em></p><p>这就结束了吗，并没有，总不能每次改了配置后，就用 postman 访问一下 refresh 接口吧，还是不够方便呀。 github 提供了一种 webhook 的方式，当有代码变更的时候，会调用我们设置的地址，来实现我们想达到的目的。</p><p>1、进入 github 仓库配置页面，选择 Webhooks ，并点击 add webhook；</p><p><img src="https://img2.jimu98.cn/blog/20200809234405.png" srcset="/img/loading.gif" alt="image-20200809234405039"></p><p>2、之后填上回调的地址，也就是上面提到的 actuator/refresh 这个地址，但是必须保证这个地址是可以被 github 访问到的。如果是内网就没办法了。这也仅仅是个演示，一般公司内的项目都会有自己的代码管理工具，例如自建的 gitlab，gitlab 也有 webhook 的功能，这样就可以调用到内网的地址了。</p><p><img src="https://img2.jimu98.cn/blog/20200809234423.png" srcset="/img/loading.gif" alt="image-20200809234423513"></p><p><em>使用 Spring Cloud Bus 来自动刷新多个端</em></p><blockquote><p>Spring Cloud Bus 将分布式系统的节点与轻量级消息代理链接。这可以用于广播状态更改（例如配置更改）或其他管理指令。一个关键的想法是，Bus 就像一个扩展的 Spring Boot 应用程序的分布式执行器，但也可以用作应用程序之间的通信渠道。</p><p>—— Spring Cloud Bus 官方解释</p></blockquote><p>如果只有一个 client 端的话，那我们用 webhook ，设置手动刷新都不算太费事，但是如果端比较多的话呢，一个一个去手动刷新未免有点复杂。这样的话，我们可以借助 Spring Cloud Bus 的广播功能，让 client 端都订阅配置更新事件，当配置更新时，触发其中一个端的更新事件，Spring Cloud Bus 就把此事件广播到其他订阅端，以此来达到批量更新。</p><h2 id="服务总线"><a href="#服务总线" class="headerlink" title="服务总线"></a>服务总线</h2><h3 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h3><blockquote><p>通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。Spring bus的一个核心思想是通过分布式的启动器对spring boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。</p></blockquote><h4 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h4><p>添加依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>需要多引入spring-cloud-starter-bus-amqp包，增加对消息总线的支持</p><p>配置文件 bootstrap.properties</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">spring-cloud-config-client</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">spring.cloud.config.name</span>=<span class="hljs-string">springcloud-config</span><span class="hljs-meta">spring.cloud.config.profile</span>=<span class="hljs-string">dev</span><span class="hljs-meta">spring.cloud.config.label</span>=<span class="hljs-string">master</span><span class="hljs-meta">spring.cloud.config.discovery.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.cloud.config.discovery.serviceId</span>=<span class="hljs-string">spring-cloud-config-server</span><span class="hljs-meta">eureka.client.service-url.defaultZone</span>=<span class="hljs-string">http://localhost:8761/eureka/</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><span class="hljs-comment">## 开启消息跟踪</span><span class="hljs-meta">spring.cloud.bus.trace.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string"></span></code></pre><p>配置文件需要增加RebbitMq的相关配置，这样客户端代码就改造完成了。</p><h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><blockquote><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，依托Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 由于SpringCloud Netflix进入维护期，目前Alibaba在国内有趋势逐渐成为主流</p></blockquote><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><h2 id="nacos：服务注册与发现-配置中心-服务总线"><a href="#nacos：服务注册与发现-配置中心-服务总线" class="headerlink" title="nacos：服务注册与发现+配置中心+服务总线"></a>nacos：服务注册与发现+配置中心+服务总线</h2><blockquote><p>Nacos=Eureka+Config+Bus</p><p>前四个字母分别为 Naming 和 Configuration 的前两个字母，最后的s为Service</p></blockquote><p>Nacos提供基于DNS和基于RPC的服务发现，即能被用来支持https/http的服务注册与发现，也支持RPC如dubbo的服务注册与发现。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Nacos支持三种部署模式</p><ul><li>单机模式 - 用于测试和单机试用。</li><li>集群模式 - 用于生产环境，确保高可用。</li><li>多集群模式 - 用于多数据中心场景。</li></ul><p>在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：</p><ul><li>1.安装数据库，版本要求：5.6.5+</li><li>2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql</li><li>3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</li></ul><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><span class="hljs-meta">db.num</span>=<span class="hljs-string">1</span><span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><span class="hljs-meta">db.user</span>=<span class="hljs-string">nacos_devtest</span><span class="hljs-meta">db.password</span>=<span class="hljs-string">youdontknow</span></code></pre><p>再以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql</p><p>集群：</p><p>使用mysql数据库</p><pre><code class="hljs properties"><span class="hljs-comment"># application.properties配置文件添加如下内容</span><span class="hljs-meta">db.num</span>=<span class="hljs-string">2</span><span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><span class="hljs-meta">db.url.1</span>=<span class="hljs-string">jdbc:mysql://11.163.152.9:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><span class="hljs-meta">db.user</span>=<span class="hljs-string">nacos_devtest</span><span class="hljs-meta">db.password</span>=<span class="hljs-string">nacos</span><span class="hljs-attr">123456</span><span class="hljs-comment">#cluster.conf.example 文件重命名为cluster.conf </span><span class="hljs-comment"># 删除文件中的注释</span><span class="hljs-comment"># ip 为集群中其他节点的ip ,注意必须包含所有其他节点的ip和端口</span><span class="hljs-meta">10.10.109.214</span>:<span class="hljs-string">8848</span><span class="hljs-meta">11.16.128.34</span>:<span class="hljs-string">8848</span><span class="hljs-meta">11.16.128.36</span>:<span class="hljs-string">8848</span><span class="hljs-attr">123456</span></code></pre><p>微服务里面：</p><h4 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>service模块中配置Nacos客户端的pom依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>Copy</code></pre><h4 id="2、添加服务配置信息"><a href="#2、添加服务配置信息" class="headerlink" title="2、添加服务配置信息"></a>2、添加服务配置信息</h4><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址Copy</span></code></pre><p>接下来要起一个名字，这样才能知道这个服务在配置中心叫什么</p><pre><code class="hljs applescript"><span class="hljs-comment">#spring:</span>  <span class="hljs-built_in">application</span>:    <span class="hljs-built_in">name</span>: gulimall-couponCopy</code></pre><h4 id="3、添加Nacos客户端注解"><a href="#3、添加Nacos客户端注解" class="headerlink" title="3、添加Nacos客户端注解"></a>3、添加Nacos客户端注解</h4><p>在客户端微服务启动类中添加注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableDiscoveryClient</span>   <span class="hljs-comment">//开启服务注册发现，这个注解可加可不加Copy</span></code></pre><h4 id="4、启动客户端微服务"><a href="#4、启动客户端微服务" class="headerlink" title="4、启动客户端微服务"></a>4、启动客户端微服务</h4><p>启动注册中心，启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><h2 id="sentinel：服务容错-限流，熔断，负载"><a href="#sentinel：服务容错-限流，熔断，负载" class="headerlink" title="sentinel：服务容错(限流，熔断，负载)"></a>sentinel：服务容错(限流，熔断，负载)</h2><h2 id="Seata：分布式事物"><a href="#Seata：分布式事物" class="headerlink" title="Seata：分布式事物"></a>Seata：分布式事物</h2><h2 id="alibab-cloud-sms：短信通讯"><a href="#alibab-cloud-sms：短信通讯" class="headerlink" title="alibab cloud sms：短信通讯"></a>alibab cloud sms：短信通讯</h2><h2 id="alibaba-cloud-oss：阿里云存储"><a href="#alibaba-cloud-oss：阿里云存储" class="headerlink" title="alibaba cloud oss：阿里云存储"></a>alibaba cloud oss：阿里云存储</h2><h1 id="SpringCloud其他问题"><a href="#SpringCloud其他问题" class="headerlink" title="SpringCloud其他问题"></a>SpringCloud其他问题</h1><h2 id="Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别"><a href="#Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别" class="headerlink" title="Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别"></a>Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</h2><p>1.ZooKeeper保证的是CP,Eureka保证的是AP</p><p>ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的</p><p>Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的</p><p>自我保护机制会导致</p><p>Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务</p><p>Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)</p><p>当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)</p><p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪</p><p>2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等</p><p>3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题</p><p>4.Eureka本质上是一个工程,而ZooKeeper只是一个进程</p><h2 id="Ribbon和Feign的区别？"><a href="#Ribbon和Feign的区别？" class="headerlink" title="Ribbon和Feign的区别？"></a>Ribbon和Feign的区别？</h2><p>1.Ribbon和Feign都是调用其他服务的，但方式不同。<br>2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients<br>3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。<br>4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】框架之MyBatis</title>
    <link href="/posts/6749/"/>
    <url>/posts/6749/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】框架之MyBatis"><a href="#【java总结】框架之MyBatis" class="headerlink" title="【java总结】框架之MyBatis"></a>【java总结】框架之MyBatis</h1><h1 id="MyBatis基础"><a href="#MyBatis基础" class="headerlink" title="MyBatis基础"></a>MyBatis基础</h1><h2 id="什么是MyBatis？"><a href="#什么是MyBatis？" class="headerlink" title="什么是MyBatis？"></a>什么是MyBatis？</h2><p>MyBatis 本是 apache 的一个开源项目 iBatis，Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p><h2 id="Mybaits的优点？"><a href="#Mybaits的优点？" class="headerlink" title="Mybaits的优点？"></a>Mybaits的优点？</h2><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p><p>（4）能够与Spring很好的集成；</p><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><p>缺点：</p><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><p>mybatis提供查询缓存，用于减轻数据库压力，提高数据库性能</p><p>MyBatis的缓存分为一级缓存和二级缓存，分别如下：</p><ul><li>一级缓存放在session里面，默认就有。</li><li>二级缓存放在它的命名空间里，默认是打开的。使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置</li></ul><p>在config.xml设置二级缓存开关 ， 还要在具体的mapper.xml开启二级缓存</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-comment">&lt;!--开启二级缓存--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><p>需要将映射的javapojo类实现序列化</p><!--开启本Mapper的namespace下的二级缓存--><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">"LRU"</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">"10000"</span>/&gt;</span></code></pre><h1 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h1><h2 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h2><h3 id="1-创建mybatis-config-xml；"><a href="#1-创建mybatis-config-xml；" class="headerlink" title="1.创建mybatis-config.xml；"></a>1.创建mybatis-config.xml；</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--configuration核心配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!--environments可以配置多个环境，default选择默认环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-comment">&lt;!--事务管理--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mybatis？useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guo"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guo"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h3 id="2-编辑mybatis工具类"><a href="#2-编辑mybatis工具类" class="headerlink" title="2.编辑mybatis工具类"></a>2.编辑mybatis工具类</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//第一步！</span>            <span class="hljs-comment">// /*使用mybatis获取sqlSessionFactory对象*/</span>            String resource = <span class="hljs-string">"mybatis-config.xml"</span>;            <span class="hljs-comment">/*获取配置文件resource*/</span>            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**第二步！！</span><span class="hljs-comment">     * 从sqlSessionFactory中获取sqlsession</span><span class="hljs-comment">     * sqlsession完全包含了面向数据库执行sql命令所需的所有方法</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre><h3 id="3-创建mapper映射文件"><a href="#3-创建mapper映射文件" class="headerlink" title="3.创建mapper映射文件"></a>3.创建mapper映射文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--接口实现类由原来的userdaoimpl转变为一个mapper配置文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"cn.jimu98.dao.UserDao"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"cn.jimu98.pojo.User"</span>&gt;</span>        select * from user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        SqlSession sqlSession = MybatisUtils.getSqlSession();        UserDao userDao = sqlSession.getMapper(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        List&lt;User&gt; userList = userDao.getUserList();        <span class="hljs-keyword">for</span> (User user : userList) &#123;            System.out.println(user);        &#125;        sqlSession.close();    &#125;&#125;</code></pre><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="引入外部配置文件"><a href="#引入外部配置文件" class="headerlink" title="引入外部配置文件"></a>引入外部配置文件</h3><p>db.properties</p><pre><code class="hljs properties"><span class="hljs-meta">db.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">db.password</span>=<span class="hljs-string">123</span><span class="hljs-meta">db.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-meta">db.url</span>=<span class="hljs-string">jdbc:mysql:///test01?serverTimezone=Asia/Shanghai</span></code></pre><p>mybatis-config.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.driver&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.url&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.username&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.password&#125;"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.mapper"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><table><thead><tr><th align="left">Setting(设置)</th><th align="left">Description（描述）</th><th align="left">Valid Values(验证值组)</th><th align="left">Default(默认值)</th></tr></thead><tbody><tr><td align="left">cacheEnabled</td><td align="left">在全局范围内启用或禁用缓存配置任何映射器在此配置下</td><td align="left">true or false</td><td align="left">TRUE</td></tr><tr><td align="left">lazyLoadingEnabled</td><td align="left">在全局范围内启用或禁用延迟加载。禁用时，所有查询将热加载</td><td align="left">true or false</td><td align="left">TRUE</td></tr><tr><td align="left">aggressiveLazyLoading</td><td align="left">启用时，有延迟加载属性的对象将被完全加载后调用懒惰的任何属性。否则，每一个属性是按需加载。</td><td align="left">true or false</td><td align="left">TRUE</td></tr><tr><td align="left">multipleResultSetsEnabled</td><td align="left">允许或不允许从一个单独的语句（需要兼容的驱动程序）要返回多个结果集。</td><td align="left">true or false</td><td align="left">TRUE</td></tr><tr><td align="left">useColumnLabel</td><td align="left">使用列标签，而不是列名。在这方面，不同的驱动有不同的行为。参考驱动文档或测试两种方法来决定你的驱动程序的行为如何。</td><td align="left">true or false</td><td align="left">TRUE</td></tr><tr><td align="left">useGeneratedKeys</td><td align="left">允许 JDBC 支持生成的密钥。兼容的驱动程序是必需的。此设置强制生成的键被使用，如果设置为 true，一些驱动会不兼容性，但仍然可以工作。</td><td align="left">true or false</td><td align="left">FALSE</td></tr><tr><td align="left">autoMappingBehavior</td><td align="left">指定 MyBatis 应如何自动映射列到字段/属性。NONE自动映射。 PARTIAL 只会自动映射结果没有嵌套结果映射定义里面。 FULL 会自动映射的结果映射任何复杂的（包含嵌套或其他）。</td><td align="left">NONE, PARTIAL, FULL</td><td align="left">PARTIAL</td></tr><tr><td align="left">defaultExecutorType</td><td align="left">配置默认执行人。SIMPLE执行人确实没有什么特别的。 REUSE执行器重用准备好的语句。 BATCH执行器重用语句和批处理更新。</td><td align="left">SIMPLE REUSE BATCH</td><td align="left">SIMPLE</td></tr><tr><td align="left">defaultStatementTimeout</td><td align="left">设置驱动程序等待一个数据库响应的秒数。</td><td align="left">Any positive integer</td><td align="left">Not Set (null)</td></tr><tr><td align="left">safeRowBoundsEnabled</td><td align="left">允许使用嵌套的语句RowBounds。</td><td align="left">true or false</td><td align="left">FALSE</td></tr><tr><td align="left">mapUnderscoreToCamelCase</td><td align="left">从经典的数据库列名 A_COLUMN 启用自动映射到骆驼标识的经典的 Java 属性名 aColumn。</td><td align="left">true or false</td><td align="left">FALSE</td></tr><tr><td align="left">localCacheScope</td><td align="left">MyBatis的使用本地缓存，以防止循环引用，并加快反复嵌套查询。默认情况下（SESSION）会话期间执行的所有查询缓存。如果 localCacheScope=STATMENT 本地会话将被用于语句的执行，只是没有将数据共享之间的两个不同的调用相同的 SqlSession。</td><td align="left">SESSION or STATEMENT</td><td align="left">SESSION</td></tr><tr><td align="left">dbcTypeForNull</td><td align="left">指定为空值时，没有特定的JDBC类型的参数的 JDBC 类型。有些驱动需要指定列的 JDBC 类型，但其他像 NULL，VARCHAR 或 OTHER 的工作与通用值。</td><td align="left">JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td><td align="left">OTHER</td></tr><tr><td align="left">lazyLoadTriggerMethods</td><td align="left">指定触发延迟加载的对象的方法。</td><td align="left">A method name list separated by commas</td><td align="left">equals,clone,hashCode,toString</td></tr><tr><td align="left">defaultScriptingLanguage</td><td align="left">指定所使用的语言默认为动态SQL生成。</td><td align="left">A type alias or fully qualified class name.</td><td align="left">org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver</td></tr><tr><td align="left">callSettersOnNulls</td><td align="left">指定如果setter方法或地图的put方法时，将调用检索到的值是null。它是有用的，当你依靠Map.keySet（）或null初始化。注意原语（如整型，布尔等）不会被设置为null。</td><td align="left">true or false</td><td align="left">FALSE</td></tr><tr><td align="left">logPrefix</td><td align="left">指定的前缀字串，MyBatis将会增加记录器的名称。</td><td align="left">Any String</td><td align="left">Not set</td></tr><tr><td align="left">logImpl</td><td align="left">指定MyBatis的日志实现使用。如果此设置是不存在的记录的实施将自动查找。</td><td align="left">SLF4J or LOG4J or LOG4J2 or JDK_LOGGING or COMMONS_LOGGING or STDOUT_LOGGING or NO_LOGGING</td><td align="left">Not set</td></tr><tr><td align="left">proxyFactory</td><td align="left">指定代理工具，MyBatis将会使用创建懒加载能力的对象。</td><td align="left">CGLIB</td><td align="left">JAVASSIST</td></tr></tbody></table><h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><blockquote><p>这个是 MyBatis 中定义的别名，分两种，一种是 MyBatis 自带的别名，另一种是我们自定义的别名。</p></blockquote><p>本来，我们在 Mapper 中定义数据类型时，需要写全路径，如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserCount"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.Integer"</span>&gt;</span>    select count(*) from user ;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>但是，每次写全路径比较麻烦。这种时候，我们可以用类型的别名来代替，例如用 int 做 Integer 的别名：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserCount"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"int"</span>&gt;</span>    select count(*) from user ;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h4 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h4><p>我们自己的对象，在 Mapper 中定义的时候，也是需要写全路径：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span>&gt;</span>    select * from user;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>这种情况下，写全路径也比较麻烦，我们可以给我们自己的 User 对象取一个别名，在 mybatis-config.xml 中添加 typeAliases 节点：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"java"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.driver&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.url&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.username&#125;"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.password&#125;"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.mapper"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p>这里，我们给 User 对象取了一个别名叫 jimu98，然后，我们就可以在 Mapper 中直接使用 jimu98来代替 User 对象了：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"jimu98"</span>&gt;</span>    select * from user;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>但是，这种一个一个去枚举对象的过程非常麻烦，我们还可以批量给对象定义别名，批量定义主要是利用包扫描来做，批量定义默认的类的别名，是类名首字母小写，例如如下配置：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.model"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre><p>这个配置就表示给 cn.jimu98.mybatis.model 包下的所有类取别名，默认的别名就是类名首字母小写。这个时候，我们在 Mapper 中，就可以利用 user 代替 User 全路径了：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>&gt;</span>    select * from user;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>在最新版中，批量定义的别名，类名首字母也可以不用小写，在实际开发中，我们一般使用第二种方式（批量定义的方式）</p><h2 id="Mapper-映射文件"><a href="#Mapper-映射文件" class="headerlink" title="Mapper 映射文件"></a>Mapper 映射文件</h2><h3 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h3><blockquote><p>这个表示输入的参数类型。</p></blockquote><p>在 MyBatis 中，我们在 mapper 引用变量时，默认使用的是 <code>#</code>，像下面这样：</p><pre><code class="hljs cs">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"getUserById"</span> resultType=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span>&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user <span class="hljs-keyword">where</span> id=<span class="hljs-meta">#&#123;id&#125;;</span>&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>除了使用 <code>#</code> 之外，我们也可以使用 <code>$</code> 来引用一个变量：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span>&gt;</span>    select * from user where id=$&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p><code>$</code> 相当于是参数拼接的方式，而 <code>#</code> 则相当于是占位符的方式。</p><h4 id="对象参数"><a href="#对象参数" class="headerlink" title="对象参数"></a>对象参数</h4><p>例如添加一个用户：</p><pre><code class="hljs java"><span class="hljs-function">Integer <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;</code></pre><p>对应的 mapper 文件如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span>&gt;</span>    insert into user (username,address,favorites) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;favorites,typeHandler=cn.jimu98.mybatis.typehandler.List2VarcharHandler&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre><p>我们在引用的时候，直接使用属性名就能够定位到对象了。如果对象存在多个，我们也需要给对象添加 @Param 注解，如果给对象添加了 @Param 注解，那么对象属性的引用，会有一些变化。如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Integer</span> <span class="hljs-selector-tag">addUser</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">"user"</span>) User user);</code></pre><p>如果对象参数添加了 @Param 注解，Mapper 中的写法就会发生变化：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id="addUser" parameterType="cn.jimu98.mybatis.model.User"&gt;    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (username,address,favorites) <span class="hljs-keyword">values</span> (#&#123;<span class="hljs-keyword">user</span>.username&#125;,#&#123;<span class="hljs-keyword">user</span>.address&#125;,#&#123;<span class="hljs-keyword">user</span>.favorites,typeHandler=cn.jimu98.mybatis.typehandler.List2VarcharHandler&#125;);&lt;/<span class="hljs-keyword">insert</span>&gt;</code></pre><p>注意多了一个前缀，这个前缀不是变量名，而是 @Param 注解中定义名称。</p><h4 id="Map-参数"><a href="#Map-参数" class="headerlink" title="Map 参数"></a>Map 参数</h4><p>如果想要使用 Map 传递参数，技术上来说，肯定是没有问题的。</p><pre><code class="hljs java"><span class="hljs-function">Integer <span class="hljs-title">updateUsernameById</span><span class="hljs-params">(HashMap&lt;String,Object&gt; map)</span></span>;</code></pre><p>XML 文件写法如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateUsernameById"</span>&gt;</span>    update user set username = #&#123;username&#125; where id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre><p>引用的变量名，就是 map 中的 key。基本上和实体类是一样的，如果给 map 取了别名，那么在引用的时候，也要将别名作为前缀加上，这一点和实体类也是一样的。</p><h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>resultType 是返回类型，在实际开发中，如果返回的数据类型比较复杂，一般我们使用 resultMap，但是，对于一些简单的返回，使用 resultType 就够用了。</p><p>resultType 返回的类型可以是简单类型，可以是对象，可以是集合，也可以是一个 hashmap，如果是 hashmap，map 中的 key 就是字段名，value 就是字段的值。</p><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>先来看一个基本用法：</p><p>首先在 mapper.xml 中定义一个 resultMap：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"MyResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.javaboy.mybatis.model.User"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><p>在这个 resultMap 中，id 用来描述主键，column 是数据库查询出来的列名，property 则是对象中的属性名。</p><p>然后在查询结果中，定义返回值时使用这个 ResultMap：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"MyResultMap"</span>&gt;</span>    select * from user where id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><p>动态 SQL 是 MyBatis 中非常强大的一个功能。例如一些常见的查询场景：</p><ul><li>查询条件不确定</li><li>批量插入</li></ul><p><img src="https://img2.jimu98.cn/blog/20200809003512.png" srcset="/img/loading.gif" alt="image-20200809003512530"></p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogWithTitleLike"</span></span><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  SELECT * FROM BLOG  WHERE state = ‘ACTIVE’  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span>    AND title like #&#123;title&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span>    AND title like #&#123;title&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span>    AND author_name like #&#123;author.name&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span>      AND title like #&#123;title&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span>      AND author_name like #&#123;author.name&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>      AND featured = 1    <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h4 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h4><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  SELECT * FROM BLOG  WHERE  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"state != null"</span>&gt;</span>    state = #&#123;state&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span>    AND title like #&#123;title&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span>    AND author_name like #&#123;author.name&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><pre><code class="hljs xml">SELECT * FROM BLOGWHERE</code></pre><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><pre><code class="hljs xml">SELECT * FROM BLOGWHEREAND title like ‘someTitle’</code></pre><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  SELECT * FROM BLOG  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"state != null"</span>&gt;</span>         state = #&#123;state&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span>        AND title like #&#123;title&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span>        AND author_name like #&#123;author.name&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><p>如果 <em>where</em> 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"WHERE"</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">"AND |OR "</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre><p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p><p>用于动态更新语句的类似解决方案叫做 <em>set<em>。</em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateAuthorIfNecessary"</span>&gt;</span>  update Author    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username != null"</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"password != null"</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"email != null"</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"bio != null"</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>  where id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>来看看与 <em>set</em> 元素等价的自定义 <em>trim</em> 元素吧：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"SET"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectPostIn"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"domain.blog.Post"</span>&gt;</span>  SELECT *  FROM POST P  WHERE ID in  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span></span><span class="hljs-tag">      <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span>&gt;</span>        #&#123;item&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p><strong>提示</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p><pre><code class="hljs xml">@Update(&#123;"<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>",<span class="actionscript">  <span class="hljs-string">"update Author"</span>,</span><span class="actionscript">  <span class="hljs-string">"  &lt;set&gt;"</span>,</span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'username != null'</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'password != null'</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'email != null'</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'bio != null'</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="actionscript">  <span class="hljs-string">"  &lt;/set&gt;"</span>,</span><span class="actionscript">  <span class="hljs-string">"where id=#&#123;id&#125;"</span>,</span>  "<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>"&#125;)void updateAuthorValues(Author author);</code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p><code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectBlogsLike"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Blog"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pattern"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"'%' + _parameter.getTitle() + '%'"</span> /&gt;</span>  SELECT * FROM BLOG  WHERE title LIKE #&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h5 id="模糊查询like的三种方式："><a href="#模糊查询like的三种方式：" class="headerlink" title="模糊查询like的三种方式："></a>模糊查询like的三种方式：</h5><p>1、直接在参数上拼接%</p><p>2、使用concat()函数做字符串拼接</p><p>select * from orders where number like concat(concat(‘%’, #{number}),’%’)</p><p>3、bind标签</p> <bind name="ll" value="'%'+number+'%'"/><p>  select * from orders where number like #{ll}</p><h2 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h2><ul><li><p>写sql语句时起别名</p></li><li><p>在MyBatis的全局配置文件中开启驼峰命名规则</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 开启驼峰命名规则，可以将数据库中的下划线映射为驼峰命名 --&gt;</span>        <span class="hljs-comment">&lt;!-- 例如：dept_id 可以映射为deptId --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapUndercoreToCamelCase"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>1234567</code></pre></li><li><p>在Mapper映射文件中使用<code>resultMap</code>来自定义映射规则</p></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getOrder"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"orderresultmap"</span>&gt;</span>select * from orders where order_id=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”me.gacl.domain.order”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderresultmap”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">!–用id属性来映射主键字段–</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”id”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_id”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> = <span class="hljs-string">“orderno”</span> <span class="hljs-attr">column</span> =<span class="hljs-string">”order_no”/</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”price”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_price”</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span></code></pre><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><blockquote><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p></blockquote><h1 id="MyBatis其他问题"><a href="#MyBatis其他问题" class="headerlink" title="MyBatis其他问题"></a>MyBatis其他问题</h1><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p><h2 id="什么是MyBatis的接口绑定-有什么好处"><a href="#什么是MyBatis的接口绑定-有什么好处" class="headerlink" title="什么是MyBatis的接口绑定,有什么好处"></a>什么是MyBatis的接口绑定,有什么好处</h2><p>答：接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><h2 id="接口绑定有几种实现方式-分别是怎么实现的"><a href="#接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="接口绑定有几种实现方式,分别是怎么实现的?"></a>接口绑定有几种实现方式,分别是怎么实现的?</h2><p>答：接口绑定有两种实现方式：</p><ul><li>一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定。</li><li>另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</li></ul><h2 id="什么情况下用注解绑定-什么情况下用xml绑定"><a href="#什么情况下用注解绑定-什么情况下用xml绑定" class="headerlink" title="什么情况下用注解绑定,什么情况下用xml绑定"></a>什么情况下用注解绑定,什么情况下用xml绑定</h2><p>当Sql语句比较简单时候,用注解绑定。<br>当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p><h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】框架之SpringMVC</title>
    <link href="/posts/28045/"/>
    <url>/posts/28045/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】框架之SpringMVC"><a href="#【java总结】框架之SpringMVC" class="headerlink" title="【java总结】框架之SpringMVC"></a>【java总结】框架之SpringMVC</h1><h1 id="SpringMVC基础"><a href="#SpringMVC基础" class="headerlink" title="SpringMVC基础"></a>SpringMVC基础</h1><h2 id="Spring-Web-MVC是什么"><a href="#Spring-Web-MVC是什么" class="headerlink" title="Spring Web MVC是什么"></a>Spring Web MVC是什么</h2><p>Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化日常Web开发的。在传统的 Jsp/Servlet 技术体系中，如果要开发接口，一个接口对应一个 Servlet，会导致我们开发出许多 Servlet，使用 SpringMVC 可以有效的简化这一步骤。</p><h2 id="Spring-Web-MVC能帮我们做什么"><a href="#Spring-Web-MVC能帮我们做什么" class="headerlink" title="Spring Web MVC能帮我们做什么"></a>Spring Web MVC能帮我们做什么</h2><ul><li>让我们能非常简单的设计出干净的 Web 层和薄薄的 Web 层；</li><li>进行更简洁的 Web 层的开发；</li><li>天生与 Spring 框架集成（如 IoC 容器、AOP 等）；</li><li>提供强大的约定大于配置的契约式编程支持；</li><li>能简单的进行 Web 层的单元测试；</li><li>支持灵活的 URL 到页面控制器的映射；</li><li>非常容易与其他视图技术集成，如 Velocity、FreeMarker 等等，因为模型数据不放在特定的 API 里，而是放在一个 Model 里（Map 数据结构实现，因此很容易被其他框架使用）；</li><li>非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的 API；</li><li>提供一套强大的 JSP 标签库，简化 JSP 开发；</li><li>支持灵活的本地化、主题等解析；</li><li>更加简单的异常处理；</li><li>对静态资源的支持；</li><li>支持 RESTful 风格</li></ul><h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><p><img src="https://img2.jimu98.cn/blog/20200808165459.png" srcset="/img/loading.gif" alt="image-20200808165458277"></p><p><img src="https://img2.jimu98.cn/blog/20200808184514.png" srcset="/img/loading.gif" alt="image-20200808184514391"></p><p>具体执行步骤如下：</p><p>1、用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。<br>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet<br>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、DispatcherServlet将模型数据填充到视图中<br>7、DispatcherServlet将结果响应给用户</p><h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ul><li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li><li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li><li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li><li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li><li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。</li></ul><h1 id="SpringMVC使用"><a href="#SpringMVC使用" class="headerlink" title="SpringMVC使用"></a>SpringMVC使用</h1><h2 id="Hello-SpringMVC"><a href="#Hello-SpringMVC" class="headerlink" title="Hello SpringMVC"></a>Hello SpringMVC</h2><h3 id="1-创建一个Maven工程"><a href="#1-创建一个Maven工程" class="headerlink" title="1.创建一个Maven工程"></a>1.创建一个Maven工程</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h3 id="2-编写Controller"><a href="#2-编写Controller" class="headerlink" title="2.编写Controller"></a>2.编写Controller</h3><p>备一个 Controller，即一个处理浏览器请求的接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这就是一个请求处理接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 这就是前端发送来的请求</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp 这就是服务端给前端的响应</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值是一个 ModelAndView，Model 相当于是我们的数据模型，View 是我们的视图</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"hello"</span>);        mv.addObject(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre><p>这里我们我们创建出来的 Controller 就是前端请求处理接口。</p><h3 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3.创建视图"></a>3.创建视图</h3><p>这里我们就采用 jsp 作为视图，在 webapp 目录下创建 hello.jsp 文件，内容如下：</p><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello $&#123;name&#125;!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="4-创建配置文件"><a href="#4-创建配置文件" class="headerlink" title="4.创建配置文件"></a>4.创建配置文件</h3><p>在 resources 目录下，创建一个名为 spring-servlet.xml 的 springmvc 的配置文件，这里，我们先写一个简单的 demo ，因此可以先不用添加 spring 的配置。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.helloworld.MyController"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"/hello"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--这个是处理器映射器，这种方式，请求地址其实就是一个 Bean 的名字，然后根据这个 bean 的名字查找对应的处理器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerMapping"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beanName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/hello"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerAdapter"</span>/&gt;</span>        <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/jsp/"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h3 id="5-加载-springmvc-配置文件"><a href="#5-加载-springmvc-配置文件" class="headerlink" title="5.加载 springmvc 配置文件"></a>5.加载 springmvc 配置文件</h3><p>在 web 项目启动时，加载 springmvc 配置文件，这个配置是在 web.xml 中完成的。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><p>所有请求都将自动拦截下来，拦截下来后，请求交给 DispatcherServlet 去处理，在加载 DispatcherServlet 时，还需要指定配置文件路径。这里有一个默认的规则，如果配置文件放在 webapp/WEB-INF/ 目录下，并且配置文件的名字等于 DispatcherServlet 的名字+ <code>-servlet</code>（即这里的配置文件路径是 webapp/WEB-INF/springmvc-servlet.xml），如果是这样的话，可以不用添加 init-param 参数，即不用手动配置 springmvc 的配置文件，框架会自动加载。</p><h3 id="6-项目启动成功后"><a href="#6-项目启动成功后" class="headerlink" title="6.项目启动成功后"></a>6.项目启动成功后</h3><p>浏览器输入  <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 就可以看到如下页面：</p><p><img src="https://img2.jimu98.cn/blog/20200808180951.png" srcset="/img/loading.gif" alt="image-20200808180951449"></p><h2 id="重定向和转发"><a href="#重定向和转发" class="headerlink" title="重定向和转发"></a>重定向和转发</h2><pre><code class="hljs java"><span class="hljs-comment">//实现转发</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello11.action"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello11</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;    request.setAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"cjj"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:hello.action"</span>;&#125;<span class="hljs-comment">//实现重定向</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello12.action"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello12</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;    request.setAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"cjj"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/hello.action"</span>;&#125;</code></pre><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>（1）解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注册spring提供的针对POST请求的中文乱码问题 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><p>（2）get请求中文参数出现乱码解决方法有两个：</p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><blockquote><p>&lt;ConnectorURIEncoding=”utf-8” connectionTimeout=”20000” port=”8080” protocol=”HTTP/1.1” redirectPort=”8443”/&gt;</p></blockquote><p> ②另外一种方法对参数进行重新编码：</p><p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h2 id="Spring-MVC的异常处理"><a href="#Spring-MVC的异常处理" class="headerlink" title="Spring MVC的异常处理"></a>Spring MVC的异常处理</h2><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h2 id="SpringMVC常用的注解"><a href="#SpringMVC常用的注解" class="headerlink" title="SpringMVC常用的注解"></a>SpringMVC常用的注解</h2><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？</h3><p>可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p><h2 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h2><p>直接在方法的形参中声明request,SpringMvc就自动把request对象传入。</p><h2 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h2><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样，不一样的话需要加@RequestParam</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">print</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"nick"</span>)</span> String name)</span>&#123;        System.out.println(<span class="hljs-string">"Hello，"</span> + name);        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><h2 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h2><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>是单例模式,所以在多线程访问的时候有线程安全问题,所以不要用同步,会影响性能的,</p><p>解决方案是不要在controller中定义成员变量：</p><blockquote><p>也就是不要在controller中定义比如</p><p>private String name;  这类操作</p><p>如果非要用，这个时候就可以用Spring的注解@Scope来实现</p><p>比如把这个bean 的范围设置成session，表示这bean是会话级别的， @Scope(“session”) </p><p>当我们首次访问这个Controller的时候，他会根据判断这个会话是不是处于同一个session中，如果是一个新的，容器会执行init方法，如果一样就不会。</p></blockquote><h2 id="为什么设计成单例设计模式"><a href="#为什么设计成单例设计模式" class="headerlink" title="为什么设计成单例设计模式?"></a>为什么设计成单例设计模式?</h2><p>因为单例模式可以提高程序运行效率，提高性能，不需要每次访问都创建新的对象，所以，不需要花费额外的性能去创建对象，销毁对象，管理对象等等……..</p><h2 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h2><p>返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h2 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h2><p>通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTful风格</title>
    <link href="/posts/49423/"/>
    <url>/posts/49423/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】RESTful风格"><a href="#【项目笔记】RESTful风格" class="headerlink" title="【项目笔记】RESTful风格"></a>【项目笔记】RESTful风格</h1><p>REST：Representational State Transfer（表象层状态转变），你一定以为是rest这个单词，其实他是这三个单词的缩写。</p><h2 id="什么是RESTful？"><a href="#什么是RESTful？" class="headerlink" title="什么是RESTful？"></a>什么是RESTful？</h2><p>RESTful是一种帮助计算机系统通过 Internet 进行通信的架构风格，而不是具体的协议。它代表着分布式服务的架构风格，这使得微服务更容易理解和实现。如果一个架构符合REST原则，就称它为RESTful架构。</p><blockquote><p><strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p><p>看Url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果如何</p></blockquote><p>每一个URI代表一种资源；<br>客户端和服务器之间，传递这种资源的某种表现层；<br>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><blockquote><p>GET /rest/api/getDogs –&gt; GET /rest/api/dogs 获取所有小狗狗  </p><p>GET /rest/api/addDogs –&gt; POST /rest/api/dogs 添加一个小狗狗  </p><p>GET /rest/api/editDogs/:dog_id –&gt; PUT /rest/api/dogs/:dog_id 修改一个小狗狗  </p><p>GET /rest/api/deleteDogs/:dog_id –&gt; DELETE /rest/api/dogs/:dog_id 删除一个小狗狗 </p></blockquote><p>左边的这种设计，很明显不符合REST风格，上面已经说了，URI 只负责准确无误的暴露资源，而 getDogs/addDogs…已经包含了对资源的操作，这是不对的。相反右边却满足了，它的操作是使用标准的HTTP动词来体现。</p><h2 id="RESTful6大原则"><a href="#RESTful6大原则" class="headerlink" title="RESTful6大原则"></a>RESTful6大原则</h2><p>REST之父Roy Fielding在论文中阐述REST架构的6大基本原则，它们分别是：</p><h3 id="1-C-S架构"><a href="#1-C-S架构" class="headerlink" title="1. C-S架构"></a>1. C-S架构</h3><p>数据的存储在Server端，Client端只需使用就行。两端彻底分离的好处使client端代码的可移植性变强，Server端的拓展性变强。两端单独开发，互不干扰。</p><h3 id="2-无状态"><a href="#2-无状态" class="headerlink" title="2. 无状态"></a>2. 无状态</h3><p>http请求本身就是无状态的，基于C-S架构，客户端的每一次请求带有充分的信息能够让服务端识别。请求所需的一些信息都包含在URL的查询参数、header、div，服务端能够根据请求的各种参数，无需保存客户端的状态，将响应正确返回给客户端。无状态的特征大大提高的服务端的健壮性和可拓展性。</p><p>当然，这种无状态性的约束也是有缺点的，客户端的每一次请求都必须带上相同重复的信息确定自己的身份和状态，造成传输数据的冗余性，但这种确定对于性能和使用来说，几乎是忽略不计的。</p><h3 id="3-统一的接口"><a href="#3-统一的接口" class="headerlink" title="3.统一的接口"></a>3.统一的接口</h3><p>REST架构的核心内容，统一的接口对于RESTful服务非常重要。客户端只需要关注实现接口就可以，接口的可读性加强，使用人员方便调用。</p><p>REST接口约束定义为：资源识别; 请求动作; 响应信息; 它表示通过uri标出你要操作的资源，通过请求动作（http method）标识要执行的操作，通过返回的状态码来表示这次请求的执行结果。</p><h3 id="4-一致的数据格式"><a href="#4-一致的数据格式" class="headerlink" title="4.一致的数据格式"></a>4.一致的数据格式</h3><p>服务端返回的数据格式要么是XML，要么是Json（获取数据），或者直接返回状态码，一些知名网站的开放平台的操作数据的api，post、put、patch都是返回的一个状态码 。</p><p>如请求一条微博信息，服务端响应信息应该包含这条微博相关的其他URL，客户端可以进一步利用这些URL发起请求获取感兴趣的信息，再如分页可以从第一页的返回数据中获取下一页的URT也是基于这个原理。</p><h3 id="5-可缓存"><a href="#5-可缓存" class="headerlink" title="5.可缓存"></a>5.可缓存</h3><p>在万维网上，客户端可以缓存页面的响应内容。因此响应都应隐式或显式的定义为可缓存的，若不可缓存则要避免客户端在多次请求后用旧数据或脏数据来响应。管理得当的缓存会部分地或完全地除去客户端和服务端之间的交互，进一步改善性能和延展性。</p><h3 id="6-按需编码、可定制代码"><a href="#6-按需编码、可定制代码" class="headerlink" title="6.按需编码、可定制代码"></a>6.按需编码、可定制代码</h3><p>服务端可选择临时给客户端下发一些功能代码让客户端来执行，从而定制和扩展客户端的某些功能。比如服务端可以返回一些 Javascript 代码让客户端执行，去实现某些特定的功能。提示：REST架构中的设计准则中，只有按需编码为可选项。如果某个服务违反了其他任意一项准则，严格意思上不能称之为RESTful风格。</p><h2 id="REST常见问题"><a href="#REST常见问题" class="headerlink" title="REST常见问题"></a>REST常见问题</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>实用的是如何正确地理解 RESTful架构和设计好RESTful API。</p><h2 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h2><h3 id="Spring-Boot-构建-RESTful-风格应用"><a href="#Spring-Boot-构建-RESTful-风格应用" class="headerlink" title="Spring Boot 构建 RESTful 风格应用"></a>Spring Boot 构建 RESTful 风格应用</h3><h4 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h4><h4 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h4><h4 id="3-配置数据库"><a href="#3-配置数据库" class="headerlink" title="3.配置数据库"></a>3.配置数据库</h4><h4 id="4-编写实体类"><a href="#4-编写实体类" class="headerlink" title="4.编写实体类"></a>4.编写实体类</h4><pre><code class="hljs java"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_book"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"book_name"</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//省略 getter/setter</span>&#125;</code></pre><h4 id="5-编写controller"><a href="#5-编写controller" class="headerlink" title="5.编写controller"></a>5.编写controller</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;&#125;</code></pre><p>此时，一个标准的RESTful风格的项目就写完了。</p><h5 id="根据-id-查询接口"><a href="#根据-id-查询接口" class="headerlink" title="根据 id 查询接口"></a>根据 id 查询接口</h5><ul><li><a href="http://127.0.0.1:8080/books/{id}" target="_blank" rel="noopener">http://127.0.0.1:8080/books/{id}</a></li></ul><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><ul><li><a href="http://127.0.0.1:8080/books" target="_blank" rel="noopener">http://127.0.0.1:8080/books</a></li></ul><p>查询结果中，除了该有的数据之外，也包含了分页数据：</p><p><img src="https://img2.jimu98.cn/blog/20200807204822.png" srcset="/img/loading.gif" alt="image-20200807204822481"></p><p>如果要分页或者排序查询，可以使用 _links 中的链接。<code>http://127.0.0.1:8080/books?page=1&amp;size=3&amp;sort=id,desc</code> 。</p><p><img src="https://img2.jimu98.cn/blog/20200807204853.png" srcset="/img/loading.gif" alt="image-20200807204852929"></p><h4 id="查询定制"><a href="#查询定制" class="headerlink" title="查询定制"></a>查询定制</h4><p>最广泛的定制，就是查询，因为增删改操作的变化不像查询这么丰富。对于查询的定制，非常容易，只需要提供相关的方法即可。例如根据作者查询书籍：</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>BookRepository extends JpaRepository&lt;Book,Long&gt; &#123;    List&lt;Book&gt; findBookByAuthorContaining(@Param(<span class="hljs-string">"author"</span>) String author);&#125;</code></pre><p>注意，方法的定义，参数要有 @Param 注解。</p><p><img src="https://img2.jimu98.cn/blog/20200807204932.png" srcset="/img/loading.gif" alt="image-20200807204932718"></p><h2 id="SpringBoot常用web注解"><a href="#SpringBoot常用web注解" class="headerlink" title="SpringBoot常用web注解"></a>SpringBoot常用web注解</h2><h3 id="web注解"><a href="#web注解" class="headerlink" title="web注解"></a>web注解</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"users"</span>) <span class="hljs-comment">//等价于 @RequestMapping(value="/users",method=RequestMethod.GET)</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"users"</span>) <span class="hljs-comment">//等价于@RequestMapping(value="/users",method=RequestMethod.POST)</span><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/users/&#123;userId&#125;"</span>) <span class="hljs-comment">//等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.PUT)</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/users/&#123;userId&#125;"</span>)  <span class="hljs-comment">//等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.DELETE)</span><span class="hljs-meta">@PatchMapping</span>(<span class="hljs-string">"/profile"</span>)  <span class="hljs-comment">//一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</span><span class="hljs-comment">//----------前后端传值---------------</span><span class="hljs-meta">@PathVariable</span>  <span class="hljs-comment">//用于获取路径参数</span><span class="hljs-meta">@RequestParam</span>  <span class="hljs-comment">//用于获取查询参数。</span></code></pre><p>@ResponseBody  //将java对象转为json格式的数据然后返回。</p><p>举个简单的例子：</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/klasses/&#123;klassId&#125;/teachers"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">getKlassRelatedTeachers</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         @PathVariable(<span class="hljs-string">"klassId"</span>)</span> Long klassId,</span><span class="hljs-function">         @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value = <span class="hljs-string">"type"</span>, required = <span class="hljs-keyword">false</span>)</span> String type ) </span>&#123;...&#125;</code></pre><p>如果我们请求的 url 是：<code>/klasses/{123456}/teachers?type=web</code></p><p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code></p><blockquote><p>@PathVariable(“name”) String name  //这个注解甚至可以映射</p><p>这一切的注解和花哨操作都是基于两个接口</p><p><strong>HttpServletRequest</strong></p><p><strong>HttpServletResponse</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">print</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        String name = request.getParameter(<span class="hljs-string">"name"</span>);        System.out.println(<span class="hljs-string">"Hello，"</span> + name);        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p>关于 <strong>HttpServletRequest</strong> 接口是非常非常非常常用的。</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>返回客户端发出请求时的完整 URL。</td></tr><tr><td>getRequestURI()</td><td>返回请求行中的参数部分。</td></tr><tr><td>getQueryString ()</td><td>方法返回请求行中的参数部分（参数名 + 值）</td></tr><tr><td>getRemoteHost()</td><td>返回发出请求的客户机的完整主机名。</td></tr><tr><td>getRemoteAddr()</td><td>返回发出请求的客户机的 IP 地址。</td></tr><tr><td>getPathInfo()</td><td>返回请求 URL 中的额外路径信息。额外路径信息是请求 URL 中的位于 Servlet 的路径之后和查询参数之前的内容，它以 “/“ 开头。</td></tr><tr><td>getRemotePort()</td><td>返回客户机所使用的网络端口号。</td></tr><tr><td>getLocalAddr()</td><td>返回 WEB 服务器的 IP 地址。</td></tr><tr><td>getLocalName()</td><td>返回 WEB 服务器的主机名。</td></tr><tr><td>getHeader(string name)</td><td>以 String 的形式返回指定请求头的值。如果该请求不包含指定名称的头，则此方法返回 null。如果有多个具有相同名称的头，则此方法返回请求中的第一个头。头名称是不区分大小写的。可以将此方法与任何请求头一起使用</td></tr><tr><td>getParameter(String name)</td><td><strong>根据 name 获取请求参数 (常用)</strong></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-meta">@RequestBody</span>  <span class="hljs-comment">//用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且Content-Type 为 application/json 格式的数据</span><span class="hljs-meta">@Valid</span>  <span class="hljs-comment">//用于验证接收参数是否符合pojo定义的要求</span><span class="hljs-meta">@RequestParam</span>  <span class="hljs-comment">//将前台传过来的名称进行转换</span></code></pre><p>我用一个简单的例子来给演示一下基本使用！</p><p>我们有一个注册的接口：</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/sign-up"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">signUp</span><span class="hljs-params">(@RequestBody @Valid UserRegisterRequest userRegisterRequest)</span> </span>&#123;  userService.save(userRegisterRequest);  <span class="hljs-keyword">return</span> ResponseEntity.ok().build();&#125;</code></pre><p>第二个例子</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">print</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"nick"</span>)</span> String name)</span>&#123;        System.out.println(<span class="hljs-string">"Hello，"</span> + name);        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p><img src="https://img2.jimu98.cn/blog/20200807212106.png" srcset="/img/loading.gif" alt="image-20200807212106265"></p><p><code>UserRegisterRequest</code>对象：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRegisterRequest</span> </span>&#123;    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@FullName</span>    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String fullName;&#125;</code></pre><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"userName"</span>:<span class="hljs-string">"coder"</span>,<span class="hljs-attr">"fullName"</span>:<span class="hljs-string">"shuangkou"</span>,<span class="hljs-attr">"password"</span>:<span class="hljs-string">"123456"</span>&#125;</code></pre><p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p><p>需要注意的是：<strong>一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code></strong>。 如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p><h3 id="JSR注解"><a href="#JSR注解" class="headerlink" title="JSR注解"></a>JSR注解</h3><pre><code class="hljs java"><span class="hljs-meta">@NotEmpty</span> <span class="hljs-comment">//被注释的字符串的不能为 null 也不能为空</span><span class="hljs-meta">@NotBlank</span> <span class="hljs-comment">//被注释的字符串非 null，并且必须包含一个非空白字符</span><span class="hljs-meta">@Null</span> <span class="hljs-comment">//被注释的元素必须为 null</span><span class="hljs-meta">@NotNull</span> <span class="hljs-comment">//被注释的元素必须不为 null</span><span class="hljs-meta">@AssertTrue</span> <span class="hljs-comment">//被注释的元素必须为 true</span><span class="hljs-meta">@AssertFalse</span> <span class="hljs-comment">//被注释的元素必须为 false</span><span class="hljs-meta">@Pattern</span>(regex=,flag=)  <span class="hljs-comment">//被注释的元素必须符合指定的正则表达式</span><span class="hljs-meta">@Email</span> <span class="hljs-comment">//被注释的元素必须是 Email 格式。</span><span class="hljs-meta">@Min</span>(value)  <span class="hljs-comment">//被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><span class="hljs-meta">@Max</span>(value)  <span class="hljs-comment">//被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><span class="hljs-meta">@DecimalMin</span>(value)  <span class="hljs-comment">//被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><span class="hljs-meta">@DecimalMax</span>(value)  <span class="hljs-comment">//被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><span class="hljs-meta">@Size</span>(max=, min=)  <span class="hljs-comment">//被注释的元素的大小必须在指定的范围内</span><span class="hljs-meta">@Digits</span> (integer, fraction)  <span class="hljs-comment">//被注释的元素必须是一个数字，其值必须在可接受的范围内</span><span class="hljs-meta">@Past</span>  <span class="hljs-comment">//被注释的元素必须是一个过去的日期</span><span class="hljs-meta">@Future</span>   <span class="hljs-comment">//被注释的元素必须是一个将来的日期</span></code></pre><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p><code>@Entity</code>声明一个类对应一个数据库实体。</p><p><code>@Table</code> 设置表明</p><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"role"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;&#125;</code></pre><h4 id="创建主键"><a href="#创建主键" class="headerlink" title="创建主键"></a>创建主键</h4><p><code>@Id</code> ：声明一个字段为主键。</p><p>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。</p><p><strong>1.通过</strong> <strong><code>@GeneratedValue</code>直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Id</span><span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="hljs-keyword">private</span> Long id;</code></pre><p><strong>2.通过</strong> <strong><code>@GenericGenerator</code>声明一个主键策略，然后</strong> <strong><code>@GeneratedValue</code>使用这个策略</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Id</span><span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"IdentityIdGenerator"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"IdentityIdGenerator"</span>, strategy = <span class="hljs-string">"identity"</span>)<span class="hljs-keyword">private</span> Long id;</code></pre><p>等价于：</p><pre><code class="hljs java"><span class="hljs-meta">@Id</span><span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="hljs-keyword">private</span> Long id;</code></pre><h4 id="设置字段类型"><a href="#设置字段类型" class="headerlink" title="设置字段类型"></a>设置字段类型</h4><p><code>@Column</code> 声明字段。</p><p><strong>示例：</strong></p><p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p><pre><code class="hljs java"><span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"user_name"</span>, nullable = <span class="hljs-keyword">false</span>, length=<span class="hljs-number">32</span>)<span class="hljs-keyword">private</span> String userName;</code></pre><p>设置字段类型并且加默认值，这个还是挺常用的。</p><pre><code class="hljs java">Column(columnDefinition = <span class="hljs-string">"tinyint(1) default 1"</span>)<span class="hljs-keyword">private</span> Boolean enabled;</code></pre><h4 id="指定不持久化特定字段"><a href="#指定不持久化特定字段" class="headerlink" title="指定不持久化特定字段"></a>指定不持久化特定字段</h4><p><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</p><p>如果我们想让<code>secrect</code> 这个字段不被持久化，可以使用 <code>@Transient</code>关键字声明。</p><pre><code class="hljs java">Entity(name=<span class="hljs-string">"USER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    ......    <span class="hljs-meta">@Transient</span>    <span class="hljs-keyword">private</span> String secrect; <span class="hljs-comment">// not persistent because of @Transient</span>&#125;</code></pre><p>除了 <code>@Transient</code>关键字声明， 还可以采用下面几种方法：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> String secrect; <span class="hljs-comment">// not persistent because of static</span><span class="hljs-keyword">final</span> String secrect = “Satish”; <span class="hljs-comment">// not persistent because of final</span><span class="hljs-keyword">transient</span> String secrect; <span class="hljs-comment">// not persistent because of transient</span></code></pre><p>一般使用注解的方式比较多。</p><h4 id="声明大字段"><a href="#声明大字段" class="headerlink" title="声明大字段"></a>声明大字段</h4><p><code>@Lob</code>:声明某个字段为大字段。</p><pre><code class="hljs java"><span class="hljs-meta">@Lob</span><span class="hljs-keyword">private</span> String content;</code></pre><p>更详细的声明：</p><pre><code class="hljs java"><span class="hljs-meta">@Lob</span><span class="hljs-comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟 加载，而 FetchType. LAZY 表示延迟加载 ；</span><span class="hljs-meta">@Basic</span>(fetch = FetchType.EAGER)<span class="hljs-comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span><span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"content"</span>, columnDefinition = <span class="hljs-string">"LONGTEXT NOT NULL"</span>)<span class="hljs-keyword">private</span> String content;</code></pre><h4 id="创建枚举类型的字段"><a href="#创建枚举类型的字段" class="headerlink" title="创建枚举类型的字段"></a>创建枚举类型的字段</h4><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Gender &#123;    MALE(<span class="hljs-string">"男性"</span>),    FEMALE(<span class="hljs-string">"女性"</span>);    <span class="hljs-keyword">private</span> String value;    Gender(String str)&#123;        value=str;    &#125;&#125;<span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"role"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-meta">@Enumerated</span>(EnumType.STRING)    <span class="hljs-keyword">private</span> Gender gender;    省略getter/setter......&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>RESTful</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】框架之SpringBoot</title>
    <link href="/posts/39778/"/>
    <url>/posts/39778/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】框架之SpringBoot"><a href="#【java总结】框架之SpringBoot" class="headerlink" title="【java总结】框架之SpringBoot"></a>【java总结】框架之SpringBoot</h1><h1 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h1><h2 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h2><p>传统的 SSM/SSH 框架组合配置繁琐臃肿，不同项目有很多重复、模板化的配置，严重降低了 Java 工程师的开发效率，而 Spring Boot 可以轻松创建基于 Spring 的、可以独立运行的、生产级的应用程序。通过对 Spring 家族和一些第三方库提供一系列自动化配置的 Starter，来使得开发快速搭建一个基于 Spring 的应用程序。</p><p>Spring Boot 让日益臃肿的 Java 代码又重回简洁。在配合 Spring Cloud 使用时，还可以发挥更大的威力。</p><h2 id="Spring-Boot有哪些优点？"><a href="#Spring-Boot有哪些优点？" class="headerlink" title="Spring Boot有哪些优点？"></a>Spring Boot有哪些优点？</h2><blockquote><ul><li>配置简单</li><li>独立运行</li><li>自动装配</li><li>无代码生成和 xml 配置</li><li>提供应用监控</li><li>易上手</li><li>提升开发效率</li><li>内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等</li></ul></blockquote><h2 id="spring-boot-核心配置文件是什么？"><a href="#spring-boot-核心配置文件是什么？" class="headerlink" title="spring boot 核心配置文件是什么？"></a>spring boot 核心配置文件是什么？</h2><p>spring boot 配置文件有两种类型，它们主要的区别是书法风格不同。</p><blockquote><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li></ul></blockquote><h2 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯 Java 方法。因此 它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><blockquote><ul><li>面向对象的配置。由于配置在JavaConfig中定义为类，因此用户可以充分利用Java中面向对象的功能。一个配置类可以子类化另一个，覆盖其@Bean方法等。</li><li>减少或消除XML配置。已经证明了基于依赖注入原理的外部化配置的好处。但是，许多开发人员不希望在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯Java方法来配置Spring容器，该容器在概念上类似于XML配置。在技术上可以仅使用JavaConfig配置类来配置容器，但是在实践中，许多人发现将JavaConfig与XML混合匹配是理想的。</li><li>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0支持泛型，现在可以按类型而不是按名称检索bean，而不需要任何强制转换或基于字符串的查找。</li></ul></blockquote><h2 id="spring-boot-有哪些方式可以实现热部署？"><a href="#spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="spring boot 有哪些方式可以实现热部署？"></a>spring boot 有哪些方式可以实现热部署？</h2><p>Spring Boot 实现热部署其实很容易，引入 devtools 依赖即可，这样当编译文件发生变化时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。</p><p>如果仅仅只是页面模板发生变化，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 LiveReload 插件就可以轻松实现热部署。</p><h2 id="什么是Spring-Profiles？"><a href="#什么是Spring-Profiles？" class="headerlink" title="什么是Spring Profiles？"></a>什么是Spring Profiles？</h2><p>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，</p><p>只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，</p><p>并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。</p><h2 id="什么是Spring-Batch？"><a href="#什么是Spring-Batch？" class="headerlink" title="什么是Spring Batch？"></a>什么是Spring Batch？</h2><p>Spring Boot Batch提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，</p><p>作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。</p><p>简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务?"></a>Spring Boot 中如何实现定时任务?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><h2 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h2><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><ol><li>SpringData 项目支持 NoSQL 存储：</li><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li>JDBC</li><li>JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h1 id="SpringBoot使用"><a href="#SpringBoot使用" class="headerlink" title="SpringBoot使用"></a>SpringBoot使用</h1><h2 id="⭐⭐⭐常用注解"><a href="#⭐⭐⭐常用注解" class="headerlink" title="⭐⭐⭐常用注解"></a>⭐⭐⭐常用注解</h2><blockquote><p>先把注解都写到前面，方便统一复习</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//Sprnig Boot项目的核心注解，目的是开启自动配置，也是下面三个的总和</span><span class="hljs-meta">@EnableAutoConfiguration</span>  <span class="hljs-comment">//启用 SpringBoot 的自动配置机制</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//表示这是一个配置类，类似xml的配置文件</span><span class="hljs-meta">@ComponentScan</span>  <span class="hljs-comment">//表示配置包扫描，里面的属性和xml的属性一一对应</span><span class="hljs-meta">@Autowired</span>  <span class="hljs-comment">//自动根据类型注入</span><span class="hljs-meta">@Qualifier</span>(“名称”)  <span class="hljs-comment">//指定自动注入的id名称</span><span class="hljs-meta">@Resource</span>(“名称”)  <span class="hljs-comment">//和autowired类似，这个注解属于J2EE的</span><span class="hljs-meta">@PostConstruct</span>  <span class="hljs-comment">//被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行</span><span class="hljs-meta">@PreDestroy</span>  <span class="hljs-comment">//被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行</span><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//所有要让spring管理的bean都要标注这个注解，一般标注在pojo类</span><span class="hljs-comment">//但是在web开发中，又衍生出了三个类，他们功能一样</span><span class="hljs-meta">@Repository</span>(“名称”) <span class="hljs-comment">//dao层</span><span class="hljs-meta">@Service</span>(“名称”) <span class="hljs-comment">//service层</span><span class="hljs-meta">@Controller</span>(“名称”) <span class="hljs-comment">//web层</span><span class="hljs-meta">@Scope</span>  <span class="hljs-comment">//声明 Spring Bean 的作用域</span><span class="hljs-comment">//-------singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</span><span class="hljs-comment">//-------prototype : 每次请求都会创建一个新的 bean 实例。</span><span class="hljs-comment">//-------request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</span><span class="hljs-comment">//-------session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//一般用来声明配置类，可以使用 @Component注解替代，不过使用Configuration注解声明配置类更加语义化。</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:user.properties"</span>)  <span class="hljs-comment">//在pojo类中引入配置文件</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"user"</span>)  <span class="hljs-comment">//在顶部注解后可以自动引入</span><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.id&#125;"</span>)<span class="hljs-comment">//手动引入</span><span class="hljs-meta">@ControllerAdvice</span>  <span class="hljs-comment">//全局异常处理，全局数据绑定，全局数据预处理</span><span class="hljs-meta">@ExceptionHandler</span>()  <span class="hljs-comment">//全局异常处理，符合就近原则</span><span class="hljs-meta">@ExceptionHandler</span>(NumberFormatException<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //或者指定异常</span><span class="hljs-class">//------------<span class="hljs-title">web</span>注解----------------</span><span class="hljs-class">@<span class="hljs-title">RestController</span>  //@<span class="hljs-title">Controller</span>和 @<span class="hljs-title">ResponseBody</span> 的合集，<span class="hljs-title">REST</span>风格的控制器</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span>  //将<span class="hljs-title">java</span>对象转为<span class="hljs-title">json</span>格式的数据。</span><span class="hljs-class"></span>@GetMapping("users") //等价于 @RequestMapping(value="/users",method=RequestMethod.GET)<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"users"</span>) <span class="hljs-comment">//等价于@RequestMapping(value="/users",method=RequestMethod.POST)</span><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/users/&#123;userId&#125;"</span>) <span class="hljs-comment">//等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.PUT)</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/users/&#123;userId&#125;"</span>)  <span class="hljs-comment">//等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.DELETE)</span><span class="hljs-meta">@PatchMapping</span>(<span class="hljs-string">"/profile"</span>)  <span class="hljs-comment">//一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</span><span class="hljs-comment">//----------前后端传值---------------</span><span class="hljs-meta">@PathVariable</span>  <span class="hljs-comment">//用于获取路径参数</span><span class="hljs-meta">@RequestParam</span>  <span class="hljs-comment">//用于获取查询参数。</span><span class="hljs-meta">@RequestBody</span>  <span class="hljs-comment">//用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且Content-Type 为 application/json 格式的数据</span><span class="hljs-meta">@Valid</span>  <span class="hljs-comment">//用于验证接收参数是否符合pojo定义的要求</span><span class="hljs-comment">//参数校验 JSR 注解见另一篇文章RESTful</span><span class="hljs-meta">@Entity</span>  <span class="hljs-comment">//声明一个类对应一个数据库实体。</span><span class="hljs-meta">@Table</span>  <span class="hljs-comment">//设置表名</span><span class="hljs-meta">@Id</span>  <span class="hljs-comment">//声明主键</span><span class="hljs-meta">@GeneratedValue</span>  <span class="hljs-comment">//指定主键生成策略。</span><span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"user_name"</span>, nullable = <span class="hljs-keyword">false</span>, length=<span class="hljs-number">32</span>)  <span class="hljs-comment">//声明字段。</span><span class="hljs-meta">@Column</span>(columnDefinition = <span class="hljs-string">"tinyint(1) default 1"</span>) <span class="hljs-comment">//设置字段类型并且加默认值</span><span class="hljs-meta">@Transient</span>  <span class="hljs-comment">//指定不持久化特定字段</span><span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//在要开启事务的方法上使用@Transactional注解即可!</span></code></pre><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><blockquote><p>其实 Spring Boot 工程本质上就是一个 Maven 工程</p></blockquote><h4 id="在线创建"><a href="#在线创建" class="headerlink" title="在线创建"></a>在线创建</h4><p>首先打开 <code>https://start.spring.io</code> 这个网站，如下：</p><p><img src="https://img2.jimu98.cn/blog/20200807153507.png" srcset="/img/loading.gif" alt="image-20200807153507433"></p><p>打不开也可以使用阿里<code>https://start.aliyun.com/</code></p><p><img src="https://img2.jimu98.cn/blog/20200807153633.png" srcset="/img/loading.gif" alt="image-20200807153633634"></p><h4 id="使用开发工具创建"><a href="#使用开发工具创建" class="headerlink" title="使用开发工具创建"></a>使用开发工具创建</h4><p>可以使用 IDE 来创建，在创建项目时选择 Spring Initializr</p><p><img src="https://img2.jimu98.cn/blog/20200807154052.png" srcset="/img/loading.gif" alt="image-20200807154052615"></p><h4 id="Maven-创建"><a href="#Maven-创建" class="headerlink" title="Maven 创建"></a>Maven 创建</h4><p><img src="https://img2.jimu98.cn/blog/20200807154138.png" srcset="/img/loading.gif" alt="image-20200807154138590"></p><blockquote><p>直接next下一步</p><p>然后手动添加依赖</p><p>然后创建主启动，添加@SpringBootApplication注解</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SpringApplication.run(SpringbootDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;</code></pre><h3 id="配置文件-application-properties"><a href="#配置文件-application-properties" class="headerlink" title="配置文件 application.properties"></a>配置文件 application.properties</h3><h4 id="位置问题"><a href="#位置问题" class="headerlink" title="位置问题"></a>位置问题</h4><p>首先，当我们创建一个 Spring Boot 工程时，默认 resources 目录下就有一个 application.properties 文件，可以在 application.properties 文件中进行项目配置，但是这个文件并非唯一的配置文件，在 Spring Boot 中，一共有 4 个地方可以存放 application.properties 文件。</p><blockquote><p>当前项目根目录下的 config 目录下</p><p>当前项目的根目录下</p><p>resources 目录下的 config 目录下</p><p>resources 目录下</p></blockquote><p>按如上顺序，四个配置文件的优先级依次降低。如下：</p><p><img src="https://img2.jimu98.cn/blog/20200807160528.png" srcset="/img/loading.gif" alt="image-20200807160528249"></p><h4 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h4><p>对于 application.properties 而言，它不一定非要叫 application ，但是项目默认是去加载名为 application 的配置文件，如果我们的配置文件不叫 application ，也是可以的，但是，需要明确指定配置文件的文件名。</p><p>方式和指定路径一致，只不过此时的 key 是 spring.config.name 。</p><p>指定完配置文件名之后，再次启动项目，此时系统会自动去默认的四个位置下面分别查找名为 app.properties 的配置文件。当然，允许自定义文件名的配置文件不放在四个默认位置，而是放在自定义目录下，此时就需要明确指定 spring.config.location 。</p><p>配置文件位置和文件名称可以同时自定义。</p><h4 id="普通的属性注入"><a href="#普通的属性注入" class="headerlink" title="普通的属性注入"></a>普通的属性注入</h4><p>在配置文件中写的配置，可以通过@Value获取到，但是要使用 ${}</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;book.id&#125;"</span>)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;book.name&#125;"</span>)    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><p>如果配置文件名称不是 <strong>application.properties</strong> 的话</p><p>这时候做完了，项目启动并不会自动的加载该配置文件，如果是在 XML 配置中，可以通过如下方式引用该 properties 文件：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:user.properties"</span>/&gt;</span></code></pre><p>如果是在 Java 配置中，可以通过 @PropertySource 来引入配置：</p><pre><code class="hljs java"><span class="hljs-comment">//在pojo文件中引入配置</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:user.properties"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.userName&#125;"</span>)    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.isAdmin&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAdmin;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.regTime&#125;"</span>)    <span class="hljs-keyword">private</span> Date regTime;&#125;</code></pre><p>还可以这样玩：</p><pre><code class="hljs java"><span class="hljs-comment">//在pojo文件中引入配置</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:user.properties"</span>)<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAdmin;    <span class="hljs-keyword">private</span> Date regTime;&#125;</code></pre><h3 id="Spring-Boot-整合-Thymeleaf"><a href="#Spring-Boot-整合-Thymeleaf" class="headerlink" title="Spring Boot 整合 Thymeleaf"></a>Spring Boot 整合 Thymeleaf</h3><p>Spring Boot 中整合 Thymeleaf 非常容易，只需要创建项目时添加 Thymeleaf 即可：</p><p><img src="https://img2.jimu98.cn/blog/20200807170742.png" srcset="/img/loading.gif" alt="image-20200807170742684"></p><p>创建 Controller</p><p><img src="https://img2.jimu98.cn/blog/20200807174356.png" srcset="/img/loading.gif" alt="image-20200807174356694"></p><p>创建 Thymeleaf</p><p><img src="https://img2.jimu98.cn/blog/20200807175950.png" srcset="/img/loading.gif" alt="image-20200807175950564"></p><p>在 <code>Thymeleaf</code> 中，通过 <code>th:each</code> 指令来遍历一个集合，数据的展示通过 <code>th:text</code> 指令来实现，</p><p>注意 <code>index.html</code> 最上面要引入 <code>thymeleaf</code> 名称空间。</p><p>配置完成后，就可以启动项目了，访问 /index 接口，就能看到集合中的数据了：</p><p><img src="https://img2.jimu98.cn/blog/20200807180007.png" srcset="/img/loading.gif" alt="image-20200807180007292"></p><h3 id="Spring-Boot-整合-Freemarker"><a href="#Spring-Boot-整合-Freemarker" class="headerlink" title="Spring Boot 整合 Freemarker"></a>Spring Boot 整合 Freemarker</h3><p><img src="https://img2.jimu98.cn/blog/20200807180134.png" srcset="/img/loading.gif" alt="image-20200807180134331"></p><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p><pre><code class="hljs pgsql">spring.freemarker.allow-request-override=falsespring.freemarker.allow-<span class="hljs-keyword">session</span>-override=falsespring.freemarker.<span class="hljs-keyword">cache</span>=falsespring.freemarker.charset=UTF<span class="hljs-number">-8</span>spring.freemarker.<span class="hljs-keyword">check</span>-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">location</span>=truespring.freemarker.content-<span class="hljs-keyword">type</span>=<span class="hljs-type">text</span>/htmlspring.freemarker.expose-request-attributes=falsespring.freemarker.expose-<span class="hljs-keyword">session</span>-attributes=falsespring.freemarker.suffix=.ftlspring.freemarker.<span class="hljs-keyword">template</span>-loader-<span class="hljs-type">path</span>=classpath:/templates/</code></pre><p>配置文件按照顺序依次解释如下：</p><ol><li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li><li>HttpSession的属性是否可以覆盖controller中model的同名项</li><li>是否开启缓存</li><li>模板文件编码</li><li>是否检查模板位置</li><li>Content-Type的值</li><li>是否将HttpServletRequest中的属性添加到Model中</li><li>是否将HttpSession中的属性添加到Model中</li><li>模板文件后缀</li><li>模板文件位置</li></ol><h3 id="整合-Web-开发"><a href="#整合-Web-开发" class="headerlink" title="整合 Web 开发"></a>整合 Web 开发</h3><h4 id="Spring-Boot-中的静态资源到底要放在哪里？"><a href="#Spring-Boot-中的静态资源到底要放在哪里？" class="headerlink" title="Spring Boot 中的静态资源到底要放在哪里？"></a>Spring Boot 中的静态资源到底要放在哪里？</h4><p>在 Spring Boot 中，如果我们是从 <code>https://start.spring.io</code> 这个网站上创建的项目，或者使用 IntelliJ IDEA 中的 Spring Boot 初始化工具创建的项目，默认都会存在 <code>resources/static</code> 目录，很多小伙伴也知道静态资源只要放到这个目录下，就可以直接访问</p><p>在 Spring Boot 中，默认情况下，一共有 5 个位置可以放静态资源，五个路径分别是如下 5 个：</p><ol><li><code>classpath:/META-INF/resources/</code></li><li><code>classpath:/resources/</code></li><li><code>classpath:/static/</code></li><li><code>classpath:/public/</code></li><li><code>/</code></li></ol><p>这里第 5 个 <code>/</code> 其实就是表示 webapp 目录中的静态资源也不被拦截。</p><p>如果我们也可以自定义静态资源位置和映射，自定义的方式也有两种，可以通过 application.properties 来定义，也可以在 Java 代码中来定义，下面分别来看。</p><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><p>在配置文件中定义的方式比较简单，如下：</p><pre><code class="hljs ini"><span class="hljs-attr">spring.resources.static-locations</span>=classpath:/<span class="hljs-attr">spring.mvc.static-path-pattern</span>=/**</code></pre><p>第一行配置表示定义资源位置，第二行配置表示定义请求 URL 规则。以上文的配置为例，如果我们这样定义了，表示可以将静态资源放在 resources 目录下的任意地方，我们访问的时候当然也需要写完整的路径，例如在 <code>resources/static</code> 目录下有一张名为 1.png 的图片，那么访问路径就是 <code>http://localhost:8080/static/1.png</code> ,注意此时的 <code>static</code> 不能省略。</p><h5 id="Java-代码定义"><a href="#Java-代码定义" class="headerlink" title="Java 代码定义"></a>Java 代码定义</h5><p>当然，在 Spring Boot 中我们也可以通过 Java 代码来自定义，方式和 Java 配置的 SSM 比较类似，如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;        registry.addResourceHandler(<span class="hljs-string">"/**"</span>).addResourceLocations(<span class="hljs-string">"classpath:/aaa/"</span>);    &#125;&#125;</code></pre><h4 id="CORS-解决跨域问题"><a href="#CORS-解决跨域问题" class="headerlink" title="CORS 解决跨域问题"></a>CORS 解决跨域问题</h4><p>首先可以通过 <code>@CrossOrigin</code> 注解配置某一个方法接受某一个域的请求</p><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span>(value = <span class="hljs-string">"http://localhost:8081"</span>)  <span class="hljs-comment">//表示服务端愿意接收来自 http://localhost:8081 的请求</span></code></pre><p>provider 上，每一个方法上都去加注解未免太麻烦了，有的小伙伴想到可以讲注解直接加在 Controller 上，不过每个 Controller 都要加还是麻烦，在 Spring Boot 中，还可以通过全局配置一次性解决这个问题，全局配置只需要在 SpringMVC 的配置类中重写 addCorsMappings 方法即可，如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;        registry.addMapping(<span class="hljs-string">"/**"</span>)        .allowedOrigins(<span class="hljs-string">"http://localhost:8081"</span>)        .allowedMethods(<span class="hljs-string">"*"</span>)        .allowedHeaders(<span class="hljs-string">"*"</span>);    &#125;&#125;</code></pre><p><code>/**</code> 表示本应用的所有方法都会去处理跨域请求，allowedMethods 表示允许通过的请求数，allowedHeaders 则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。</p><h4 id="定义系统启动任务的两种方式"><a href="#定义系统启动任务的两种方式" class="headerlink" title="定义系统启动任务的两种方式"></a>定义系统启动任务的两种方式</h4><h5 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h5><p>使用 CommandLineRunner 时，首先自定义 MyCommandLineRunner1 并且实现 CommandLineRunner 接口：</p><pre><code class="hljs less"><span class="hljs-variable">@Component</span><span class="hljs-variable">@Order</span>(<span class="hljs-number">100</span>)public class MyCommandLineRunner1 implements CommandLineRunner &#123;    <span class="hljs-variable">@Override</span>    public void run(String... args) throws Exception &#123;    &#125;&#125;</code></pre><p>关于这段代码，我做如下解释：</p><ol><li>首先通过 @Compoent 注解将 MyCommandLineRunner1 注册为Spring容器中的一个 Bean。</li><li>添加 @Order注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。@Order 注解中，数字越小，优先级越大，默认情况下，优先级的值为 Integer.MAX_VALUE，表示优先级最低。</li><li>在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。</li><li>run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。</li></ol><p>此时启动项目，run方法就会被执行，至于参数，可以通过两种方式来传递，如果是在 IDEA 中，可以通过如下方式来配置参数：</p><p>另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下：</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">devtools-0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1-SNAPSHOT</span><span class="hljs-selector-class">.jar</span> 三国演义 西游记</code></pre><p>注意，这里参数传递时没有 key，直接写 value 即可，执行结果如下：</p><p><img src="https://img2.jimu98.cn/blog/20200807183137.png" srcset="/img/loading.gif" alt="image-20200807183137659"></p><h5 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h5><p>ApplicationRunner 和 CommandLineRunner 功能一致，用法也基本一致，唯一的区别主要体现在对参数的处理上，ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key/value 形式的参数）。</p><p>使用 ApplicationRunner ，自定义类实现 ApplicationRunner 接口即可，组件注册以及组件优先级的配置都和 CommandLineRunner 一致，如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order</span>(<span class="hljs-number">98</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();        System.out.println(<span class="hljs-string">"MyApplicationRunner1&gt;&gt;&gt;"</span>+nonOptionArgs);        Set&lt;String&gt; optionNames = args.getOptionNames();        <span class="hljs-keyword">for</span> (String key : optionNames) &#123;            System.out.println(<span class="hljs-string">"MyApplicationRunner1&gt;&gt;&gt;"</span>+key + <span class="hljs-string">":"</span> + args.getOptionValues(key));        &#125;        String[] sourceArgs = args.getSourceArgs();        System.out.println(<span class="hljs-string">"MyApplicationRunner1&gt;&gt;&gt;"</span>+Arrays.toString(sourceArgs));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】框架之Spring</title>
    <link href="/posts/50319/"/>
    <url>/posts/50319/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】框架之Spring"><a href="#【java总结】框架之Spring" class="headerlink" title="【java总结】框架之Spring"></a>【java总结】框架之Spring</h1><h1 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h1><h2 id="什么是Spring？"><a href="#什么是Spring？" class="headerlink" title="什么是Spring？"></a>什么是Spring？</h2><blockquote><ul><li>Spring是一个开源的免费的框架（容器）</li><li>Spring是一个轻量级的，非入侵式的框架</li><li>两个特性：控制反转（IOC）面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul></blockquote><h2 id="使用Spring的好处"><a href="#使用Spring的好处" class="headerlink" title="使用Spring的好处"></a>使用Spring的好处</h2><blockquote><p>方便解耦——Spring提供的IoC容器实现了对象依赖关系的管理，避免了硬编码导致的耦合。</p><p>支持AOP——Spring提供的AOP功能，方便进行面向切面编程。</p><p>声明式事物——Spring提供了通过声明的方式灵活的进行事务管理。</p><p>方便程序测试——可以用非容器以来的编程方式进行几乎所有的测试工作。</p><p>集成了多种优秀框架——Spring提供了对各种优秀框架（如Struts、Hibernate、Hessian、Quartz等）的直接支持。</p><p>降低Java EE API的使用难度——Spring对很多难用的Java EE API（如JDBC、JavaMail、远程调用等）提供了一个薄薄的封装层，使得这些Java EE API的使用难度大为降低。</p><p>Java源码是经典学习范例——Spring的源码设计精妙、结构清晰，是Java技术的最佳实践的范例。</p><p>事务管理：Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务 （JTA）。</p><p>异常处理：Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛 出的）转化为一致的unchecked异常。</p></blockquote><h2 id="Spring组成"><a href="#Spring组成" class="headerlink" title="Spring组成"></a>Spring组成</h2><p><img src="https://api2.mubu.com/v3/document_image/ab0627d0-6e19-4574-8e46-23b209819804-1015484.jpg" srcset="/img/loading.gif" alt="image"></p><ul><li><p><strong>核心容器</strong> ：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <code>BeanFactory</code>，它是工厂模式的实现。 <code>BeanFactory</code> 使用 <em>控制反转</em> （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring框架建立在此模块之上，它使Spring成为一个容器。</p></li><li><p><strong>Spring 上下文</strong> ：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p></li><li><p><strong>Spring AOP</strong> ：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p></li><li><p><strong>Spring DAO</strong> ：</p><blockquote><p>DAO（Data Access Object）是用于访问数据的对象，虽然在大多数情况下将数存在数据库中，但这并不是唯一的选择，也可以将数据存储到文件中或LDAP中。DAO不但屏蔽了数据存储的最终介质的不同，也屏蔽了具体的实现技术的不同。</p><p>JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p></blockquote></li><li><p><strong>Spring ORM</strong> ：Spring 框架插入了若干个 ORM 框架，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p></li><li><p><strong>Spring Web 模块</strong> ：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p></li><li><p><strong>Spring MVC 框架</strong> ：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p></li></ul><h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便 在接收到客户端请求时将对应的bean实例化。</p><p>最常用的BeanFactory实现是XmlBeanFactory类。</p><blockquote><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中的 定义加载beans。该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应 用。</p></blockquote><p>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端 的配置中解放出来。BeanFactory还包含 了bean生命周期的控制，调用客户端的初始化方法 （initialization methods）和销毁方法（destruction methods）。</p><p>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设 置，根据请求分发bean的功能。但applicationcontext在此基础上还提供了其他的功能。</p><blockquote><p>1.提供了支持国际化的文本消息 </p><p>2.统一的资源文件读取方式 </p><p>3.已在监听器中注册的bean的事件</p></blockquote><p>以下是三种较常见的 ApplicationContext 实现方式：</p><blockquote><p>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上 下文定义。应用程序上下文从程序环境变量中 ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p><p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。</p><p>4.AnnotationConigApplicationContext(基于Java配置启动容器)</p></blockquote><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="控制反转IoC"><a href="#控制反转IoC" class="headerlink" title="控制反转IoC"></a>控制反转IoC</h4><p>IoC的字面意思是控制反转，它包括两部分的内容：</p><ul><li>控制：在上述案例中，控制就是选择套餐中汉堡和饮品的控制权。</li><li>反转：反转就是把该控制权从套餐本身中移除，放到专门的服务员手中。</li></ul><p>对于Spring来说，我们通过Spring容器管理来管理和控制Bean的装配。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>由于IoC这个重要的概念比较晦涩隐讳，Martin Fowler提出了DI（Dependency Injection，依赖注入）的概念用以代替IoC，即让调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。</p><p>Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述，由IoC容器负责类的创建，管理，获取等工作。让开发者可以从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注于更有意义的业务逻辑开发。</p><blockquote><p>BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。</p><p>Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化、Bean生命周期控制、框架事件体系、资源加载透明化等功能；还提供了众多企业级服务的支持，如邮件服务、任务调度、JNDI、EJB、远程访问等。ApplicationContext是Context模块的核心接口。</p><p>表达式语言（Expression Language）是统一表达式语言的一个扩展，用于查询和管理运行期的对象，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。</p></blockquote><h4 id="什么是SpringIOC容器？"><a href="#什么是SpringIOC容器？" class="headerlink" title="什么是SpringIOC容器？"></a>什么是SpringIOC容器？</h4><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管 理这些对象的整个生命周期。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect Oriented Programing）即面向切面编程，适用于那些具有横切逻辑的应用场合，是OOP的重要补充。通过 spring 的 AOP 技术，就可以在不修改 代码的情况下完成需求。</p><p>AOP有几个重要的概念：</p><ol><li>连接点（Joinpoint）：一段代码中一些具有边界性质的点，如类开始初始化前、类初始化后、方法调用前后、方法抛出异常。Spring仅支持方法的连接点。</li><li>切点（Pointcut）：AOP通过切点定位连接点，相当于是连接点的定位条件。在Spring中，切点通过<code>org.springframework.aop.Pointcut</code>接口进行描述。</li><li>增强（Advice）：增强是指在目标连接点上织入一段程序代码。</li><li>目标类（Target）：织入增强逻辑的目标类。</li><li>引介（Introduction）： 引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</li><li>织入（Weaving）：是将增强添加对目标类具体连接点上的过程。根据不同的实现技术，AOP有三种织入的方式（Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入）：<br> a. 编译期织入，这要求使用特殊的Java编译器。<br> b. 类装载期织入，这要求使用特殊的类装载器。<br> c. 动态代理织入，在运行期为目标类添加增强生成子类的方式。</li><li>代理（Proxy）：一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。</li><li>切面（Aspect）：切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</li></ol><h4 id="Spring-AOP-实现原理"><a href="#Spring-AOP-实现原理" class="headerlink" title="Spring AOP 实现原理"></a>Spring AOP 实现原理</h4><blockquote><p>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。JDK 动态代 理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h3><blockquote><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置它们，以及如何相 互调用。</p></blockquote><h3 id="什么是SpringIOC容器？-1"><a href="#什么是SpringIOC容器？-1" class="headerlink" title="什么是SpringIOC容器？"></a>什么是SpringIOC容器？</h3><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管 理这些对象的整个生命周期。</p><h3 id="什么是Spring-inner-beans？"><a href="#什么是Spring-inner-beans？" class="headerlink" title="什么是Spring inner beans？"></a>什么是Spring inner beans？</h3><h2 id="其他介绍"><a href="#其他介绍" class="headerlink" title="其他介绍"></a>其他介绍</h2><h3 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h3><p>用来形容它用来存储单例的bean对象这个特性。</p><h3 id="Spring-Bean的生命周期？"><a href="#Spring-Bean的生命周期？" class="headerlink" title="Spring Bean的生命周期？"></a>Spring Bean的生命周期？</h3><blockquote><p>① Spring IoC容器找到关于Bean的定义并实例化该Bean。<br> ② Spring IoC容器对Bean进行依赖注入。<br> ③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。<br> ④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。<br> ⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。<br> ⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。<br> ⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。<br> ⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200806223614.png" srcset="/img/loading.gif" alt="image-20200806223614200"></p><h3 id="哪些是重要的bean生命周期方法？你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？你能重载它们吗？"></a>哪些是重要的bean生命周期方法？你能重载它们吗？</h3><p>有两个重要的bean生命周期方法，第一个是setup，它是在容器加载bean的时候被调用。第 二个方法是teardown它是在容器卸载类的时候被调用。 Thebean标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制 初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><h3 id="可以在Spring中注入一个null和一个空字符串吗？"><a href="#可以在Spring中注入一个null和一个空字符串吗？" class="headerlink" title="可以在Spring中注入一个null和一个空字符串吗？"></a>可以在Spring中注入一个null和一个空字符串吗？</h3><p>可以</p><h1 id="Spring使用"><a href="#Spring使用" class="headerlink" title="Spring使用"></a>Spring使用</h1><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>首先编写pojo类，工厂</p><pre><code class="hljs java"><span class="hljs-comment">//定义一个宠物接口类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pet</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPet</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//定义两个宠物实现类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pet</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPet</span><span class="hljs-params">()</span> </span>&#123;System.out.println(name+<span class="hljs-string">"：狗喜欢吃骨头！"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pet</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPet</span><span class="hljs-params">()</span> </span>&#123;System.out.println(name+<span class="hljs-string">"：猫喜欢吃鱼！"</span>);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//定义一个静态工厂类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetFactory</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pet <span class="hljs-title">getPet</span><span class="hljs-params">(String arg)</span></span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-string">"dog"</span>.equals(arg))&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cat();&#125;&#125;&#125;</code></pre><h3 id="一、创建applicationContext-xml文件"><a href="#一、创建applicationContext-xml文件" class="headerlink" title="一、创建applicationContext.xml文件"></a>一、创建applicationContext.xml文件</h3><p>在这个文件中托管bean</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"dog"</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"cn.jimu98.factory.PetFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getPet"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"dog"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"旺财"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"cat"</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"cn.jimu98.factory.PetFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getPet"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cat"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"咪咪"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><blockquote><p>class属性就是指定的静态工厂类，factory-method指定工厂的静态方法。如果factory-method需要参数，则需要使用constructor-arg元素传入。</p></blockquote><h3 id="二、初始化容器"><a href="#二、初始化容器" class="headerlink" title="二、初始化容器"></a>二、初始化容器</h3><blockquote><p>ApplicationContext ac = new ClassPathXmlApplicationContext(“ApplicationContext.xml”); //获取Spring 的上下文对象 也可以说拿到了容器</p></blockquote><h3 id="三、获取对象-getBean-“”"><a href="#三、获取对象-getBean-“”" class="headerlink" title="三、获取对象 getBean(“”)"></a>三、获取对象 getBean(“”)</h3><pre><code class="hljs java"><span class="hljs-comment">//测试方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"appicationContext.xml"</span>);Pet p1 = ac.getBean(<span class="hljs-string">"dog"</span>, Pet<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;p1.testPet();Pet p2 = ac.getBean(<span class="hljs-string">"cat"</span>, Pet<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;p2.testPet();&#125;&#125;</code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><blockquote><p>是指在实体类种通过无参构造器构造的bean</p></blockquote><h5 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h5><blockquote><p>ac.getBean(“dog”, Pet.class);</p></blockquote><h5 id="通过注解方式实现"><a href="#通过注解方式实现" class="headerlink" title="通过注解方式实现"></a>通过注解方式实现</h5><p>在类上添加@Service注解</p><p>@Component：在Bean的实现类上直接标注，可以被Spring容器识别<br> @Repository：用于对DAO实现类进行标柱<br> @Service：用于对Service实现类进行标注<br> @Controller：用于对Controller实现类进行标注</p><p>—————————–分割线</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>其实xml配置文件分类可多 细细道来</p></blockquote><h4 id="调用实例工厂方法创建Bean"><a href="#调用实例工厂方法创建Bean" class="headerlink" title="调用实例工厂方法创建Bean"></a>调用实例工厂方法创建Bean</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"petFactory"</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"cn.jimu98.factory.PetOneFactory"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"dog"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"petFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getPet"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"dog"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"旺财"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><blockquote><p>调用静态工厂方法只需要工厂类即可，而调用实例工厂方法则需要工厂实例。所以配置实例工厂方法与配置静态工厂方法基本相似，只有一点区别：配置静态工厂方法使用class指定静态工厂类，而配置实例工厂方法则使用factory-bean指定工厂实例。</p></blockquote><h4 id="抽象Bean与子Bean"><a href="#抽象Bean与子Bean" class="headerlink" title="抽象Bean与子Bean"></a>抽象Bean与子Bean</h4><blockquote><p>在实际开发中，有可能会出现这样的情况：随着项目越来越大，Spring配置文件出现了多个bean，配置具有大致相同的配置信息，只有少量信息不同，为了解决上面问题，可以考虑把多个bean配置中相同的信息提取出来，集中成配置模板——这个配置模板并不是真正的Bean。因此Spring不应该创建该配置模板，于是需要为该bean配置增加abstract属性值为true表示这是个抽象Bean。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”steelAxe”</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”cn.jimu98.impl.SteelAxe”</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”personTemplete”</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">”true”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”name”</span> <span class="hljs-attr">value</span>=<span class="hljs-string">”zhangsan”</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”axe”</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">”steelAxe”</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”chinese”</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”cn.jimu98.impl.Chinese”</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">”personTemplete”/</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”american”</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”cn.jimu98.impl.American”</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">”personTemplete”/</span>&gt;</span></code></pre><p>Java中Bean的继承与Java中的继承有如下区别：</p><blockquote><p>Spring中的子Bean和父Bean可以是不同类型，但Java中的继承则可保证子类是一种特殊的父类。<br>Spring中Bean的继承是实例之间的关系，因此主要表现为参数值的延续；而Java中的继承是类之间的关系，主要表现为方法、属性的延续。<br>Spring中的子Bean不可作为父Bean使用，不具备多态性；Java中的子类实例完全可以当成父类实例使用。</p></blockquote><h4 id="Bean类的配置项"><a href="#Bean类的配置项" class="headerlink" title="Bean类的配置项"></a>Bean类的配置项</h4><blockquote><p>① class</p><p>该配置项是强制项，用于指定创建Bean实例的Bean类的路径。</p><p>② name</p><p>该配置项是强制项，用于指定Bean唯一的标识符，在基于 XML 的配置项中，可以使用 id和或 name 属性来指定 Bean唯一 标识符。</p><p>③ scope</p><p>该配置项是可选项，用于设定创建Bean对象的作用域。</p><p>④ constructor-arg</p><p>该配置项是可选项，用于指定通过构造函数注入依赖数据到Bean。</p><p>⑤ properties</p><p>该配置项是可选项，用于指定通过set方法注入依赖数据到Bean。</p><p>⑥ autowiring mode</p><p>该配置项是可选项，用于指定通过自动依赖方法注入依赖数据到Bean。</p><p>⑦ lazy-initialization mode</p><p>该配置项是可选项，用于指定IOC容器延迟创建Bean，在用户请求时创建Bean，而不要在启动时就创建Bean。</p><p>⑧ initialization</p><p>该配置项是可选项，用于指定IOC容器完成Bean必要的创建后，调用Bean类提供的回调方法对Bean实例进一步处理。</p><p>⑨ destruction</p><p>该配置项是可选项，用于指定IOC容器在销毁Bean时，调用Bean类提供的回调方法。</p></blockquote><h5 id="自动装配autowire"><a href="#自动装配autowire" class="headerlink" title="自动装配autowire"></a>自动装配autowire</h5><p><beans>元素提供了一个default-autowire属性可以全局自动匹配，默认为no。<bean>元素提供了一个指定自动装配类型的autowire属性，可以覆盖<beans>元素的default-autowire属性，该属性有如下选项：</p><table><thead><tr><th>自动装配类型</th><th>说明</th></tr></thead><tbody><tr><td>no</td><td>显式指定不使用自动装配。</td></tr><tr><td>byName</td><td>如果存在一个和当前属性名字一致的 Bean，则使用该 Bean 进行注入。如果名称匹配但是类型不匹配，则抛出异常。如果没有匹配的类型，则什么也不做。</td></tr><tr><td>byType</td><td>如果存在一个和当前属性类型一致的 Bean ( 相同类型或者子类型 )，则使用该 Bean 进行注入。byType 能够识别工厂方法，即能够识别 factory-method 的返回类型。如果存在多个类型一致的 Bean，则抛出异常。如果没有匹配的类型，则什么也不做。</td></tr><tr><td>constructor</td><td>与 byType 类似，只不过它是针对构造函数注入而言的。如果当前没有与构造函数的参数类型匹配的 Bean，则抛出异常。使用该种装配模式时，优先匹配参数最多的构造函数。</td></tr><tr><td>default</td><td>根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配。如果 Bean 提供了默认的构造函数，则采用 byType；否则采用 constructor 进行自动装配。</td></tr></tbody></table><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，当IoC容器一创建就会创建bean的实例，Bean以单实例的方式存在</td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都返回一个新的实例</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>session</td><td>同一个HTTP session共享一个Bean，不同的HTTP session使用不同的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>globalSession</td><td>该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。</td></tr></tbody></table><h4 id="扫描注解定义对Bean"><a href="#扫描注解定义对Bean" class="headerlink" title="扫描注解定义对Bean"></a>扫描注解定义对Bean</h4><p>Spring提供了一个context命名空间，用于扫描以注解定义Bean的类。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--生命context命名空间--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context </span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.jimu98.spring"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h5 id="base-package属性"><a href="#base-package属性" class="headerlink" title="base-package属性"></a>base-package属性</h5><ul><li>指定一个需要扫描的基类包，Spring容器会扫描这个包下的所有类，并提取标注了相关注解的Bean。</li></ul><h5 id="resource-pattern属性"><a href="#resource-pattern属性" class="headerlink" title="resource-pattern属性"></a>resource-pattern属性</h5><ul><li>如果不希望扫描base-package下的所有类，可以使用该属性提供过滤</li><li>该属性默认是<code>**/*.class</code>，即基包下的所有类</li></ul><h5 id="context-exclude-filter与context-include-filter"><a href="#context-exclude-filter与context-include-filter" class="headerlink" title="context:exclude-filter与context:include-filter"></a><a href="context:exclude-filter">context:exclude-filter</a>与<a href="context:include-filter">context:include-filter</a></h5><ul><li><a href="context:exclude-filter">context:exclude-filter</a>：表示要排除的目标类</li><li><a href="context:include-filter">context:include-filter</a>：表示要包含的目标类</li><li><a href="context:component-scan">context:component-scan</a>可以有多个上述两个子元素；首先根据exclude-filter列出需要排除的黑名单，然后再根据include-filter流出需要包含的白名单。</li></ul><table><thead><tr><th>类别</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>annotation</td><td>com.ankeetc.XxxAnnotation</td><td>所有标注了XxxAnnotation的类。该类型采用目标类是否<strong>标志了某个注解</strong>进行过滤。</td></tr><tr><td>assignable</td><td>com.ankeetc.XxService</td><td>所有继承或扩展XXXService的类。该类型采用目标类是否<strong>继承或者扩展了某个特定类</strong>进行过滤</td></tr><tr><td>aspectj</td><td>com.ankeetc..*Service+</td><td>所有类名以Service结束的类及继承或者扩展他们的类。该类型采用AspectJ表达式进行过滤</td></tr><tr><td>regex</td><td>com.ankeetc.auto..*</td><td>所有com.ankeetc.auto类包下的类。该类型采用正则表达式根据目标类的类名进行过滤</td></tr><tr><td>custom</td><td>com.ankeetc.XxxTypeFilter</td><td>采用XxxTypeFilter代码方式实现过滤规则，该类必须实现org.springframework.core.type.TypeFilter接口</td></tr></tbody></table><h5 id="use-default-filters属性"><a href="#use-default-filters属性" class="headerlink" title="use-default-filters属性"></a>use-default-filters属性</h5><ul><li>use-default-filters属性默认值为true，表示会对标注@Component、@Controller、@Service、@Reposity的Bean进行扫描。</li><li>如果想仅扫描一部分的注解，需要将该属性设置为false。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 仅扫描标注了@Controller注解的类--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.ankeetc.spring"</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"annotation"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"org.springframework.stereotype.Controller"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><h5 id="方式一：通过xml文件实现自动装配"><a href="#方式一：通过xml文件实现自动装配" class="headerlink" title="方式一：通过xml文件实现自动装配"></a>方式一：通过xml文件实现自动装配</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"people"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.jimu98.pojo.Peopel"</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byName"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"张三"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p> 使用autowire关键字声明bean的自动装配方式。其可选值为<strong>byName、byType、constructor，default，no</strong>；这里讲前边两个。</p><h6 id="1-byName"><a href="#1-byName" class="headerlink" title="1.byName"></a>1.byName</h6><p>设置autowire属性为byName，那么Spring会根据class属性找到实体类，然后查询实体类中所有setter方法的名字，根据setter方法后面的名字（例如SetDog，则setter方法后面的名字为dog）再到配置文件中寻找一个与该名字相同id的Bean，注入进来。如图：</p><p><img src="https://img2.jimu98.cn/blog/20200806213044.png" srcset="/img/loading.gif" alt="image-20200806213043989"></p><h6 id="2-byType"><a href="#2-byType" class="headerlink" title="2.byType"></a>2.byType</h6><p>设置autowire属性为byType，那么Spring会自动寻找一个与该属性类型相同的Bean，注入进来。</p><p><img src="https://img2.jimu98.cn/blog/20200806213100.png" srcset="/img/loading.gif" alt="image-20200806213100822"></p><p>注意：使用byType这种方式，必须保证配置文件中所有bean的class属性的值是唯一的，否则就会报错</p><p>例如：下边这种方式是错误的，因为两个bean中的class属性的值重复了，会报错</p><p><img src="https://img2.jimu98.cn/blog/20200806213136.png" srcset="/img/loading.gif" alt="image-20200806213136630"></p><h5 id="方式二：通过注解实现自动装配"><a href="#方式二：通过注解实现自动装配" class="headerlink" title="方式二：通过注解实现自动装配"></a>方式二：通过注解实现自动装配</h5><p>注解是通过反射来实现的。</p><p><strong>1.使用注解前的准备：</strong></p><p>要使用注解，xml文件要使用如下的文件头：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>注意：<br>&lt;context:annotation-config/&gt;  必须要写在xml中，这是用来开启注解的支持，如果不加上注解就无效。</p><p>2.1  Autowired注解【常用】<br>首先xml配置文件如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cat"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kuang.pojo.Cat"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dog"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kuang.pojo.Dog"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"people"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kuang.pojo.Peopel"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"张三"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>然后在实体类的对应属性上添加@Autowired注解（也可以把注解放到对应属性的setter上），people类中依赖Dog类和Cat类。所以在people类中的dog和cat属性上要加上@Autowired，实现自动装配。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Peopel</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Cat cat;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Dog dog;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> Cat <span class="hljs-title">getCat</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cat;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCat</span><span class="hljs-params">(Cat cat)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cat = cat;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Dog <span class="hljs-title">getDog</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dog;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDog</span><span class="hljs-params">(Dog dog)</span> </span>&#123;        <span class="hljs-keyword">this</span>.dog = dog;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Peopel&#123;"</span> +                <span class="hljs-string">"cat="</span> + cat +                <span class="hljs-string">", dog="</span> + dog +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>重点：</p><p>（1）注解方法装配属性的过程：spring会默认优先根据（被注解修饰的）属性类型去容器中找对应的组件（bean），找到就赋值；若找到多个相同类型的组件，再将属性的名称作为组件（bean）的id去容器中查找。</p><p> （2）@Qualifier注解可以和使用Autowired搭配使用：@Qualifier指定需要装配的组件的id，而不是使用属性名。例如下边例子，spring就会优先在容器中查找id为“abcd”的组件。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Peopel</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier</span>(value = <span class="hljs-string">"cat"</span>)    <span class="hljs-keyword">private</span> Cat cat;&#125;</code></pre><p>什么情况会使用到@Qualifier注解：当ioc容器根据属性类型去容器中找找到多个相同类型的组件，再将属性的名称作为组件（bean）的id去容器中查找找不到时就是用这两个注解搭配，指定需要装配的bean的id。</p><p>（3）在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用@Autowired(required= false)。这等于告诉 Spring：在找不到匹配 Bean 时也不报错。</p><p><strong>2.2. Resource注解【不常用】</strong></p><p>@Resource:可以和@Autowired一样实现自动装配功能，但是跟@Autowired不一样的是，它默认是按照组件名称进行装配的，按照组件名称找不到在根据属性类型去查找，再找不到就报错；他们另一个不同的地方就是@Autowired是Spring定义的； @Resource是java规范。</p><h4 id="什么是Spring-inner-beans？-1"><a href="#什么是Spring-inner-beans？-1" class="headerlink" title="什么是Spring inner beans？"></a>什么是Spring inner beans？</h4><p>在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这 个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。 比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建 一个Person的实例，然后在Customer内部使用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>&#123; <span class="hljs-keyword">private</span> Person person; <span class="hljs-comment">//Setters and Getters</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123; <span class="hljs-keyword">private</span> String name; <span class="hljs-keyword">private</span> String address; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//Setters and Getters</span>&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"CustomerBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.somnus.common.Customer"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"person"</span>&gt;</span> <span class="hljs-comment">&lt;!-- This is inner bean --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.howtodoinjava.common.Person"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lokesh"</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"India"</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"34"</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><blockquote><p>pring框架中的单例bean不是线程安全的。</p></blockquote><h4 id="请举例说明-Qualiier注解？"><a href="#请举例说明-Qualiier注解？" class="headerlink" title="请举例说明@Qualiier注解？"></a>请举例说明@Qualiier注解？</h4><blockquote><p>@Qualiier注解意味着可以在被标注bean的字段上可以自动装配。Qualiier注解可以用来取 消Spring不能取消的bean应用。 下面的示例将会在Customer的person属性中自动装配 person的值。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"customer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.jimu98.common.Customer"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"personA"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.jimu98.common.Person"</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lokesh"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"personB"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.jimu98.common.Person"</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"alex"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>&#123; <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> Person person;&#125;</code></pre><p>//这样就会报错，因为不知道该使用哪个bean</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>&#123; <span class="hljs-meta">@Autowired</span> <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"personA"</span>) <span class="hljs-keyword">private</span> Person person;&#125;</code></pre><p>//使用@Qualiier注解就ok了</p><h4 id="IOC-1"><a href="#IOC-1" class="headerlink" title="IOC"></a>IOC</h4><p>从注入方法上看，IoC可以分为：构造函数注入、属性注入、接口注入</p><h5 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h5><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KFCCombo</span> </span>&#123;    <span class="hljs-keyword">private</span> Burger burger;    <span class="hljs-keyword">private</span> Drink drink;    <span class="hljs-comment">// 在此注入对应的内容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KFCCombo</span><span class="hljs-params">(Burger burger, Drink drink)</span> </span>&#123;        <span class="hljs-keyword">this</span>.burger = burger;        <span class="hljs-keyword">this</span>.drink = drink;    &#125;&#125;</code></pre><h5 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h5><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KFCCombo</span> </span>&#123;    <span class="hljs-keyword">private</span> Burger burger;    <span class="hljs-keyword">private</span> Drink drink;    <span class="hljs-comment">// 在此注入对应的内容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBurger</span><span class="hljs-params">(Burger burger)</span> </span>&#123;        <span class="hljs-keyword">this</span>.burger = burger;    &#125;    <span class="hljs-comment">// 在此注入对应的内容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDrink</span><span class="hljs-params">(Drink drink)</span> </span>&#123;        <span class="hljs-keyword">this</span>.drink = drink;    &#125;&#125;</code></pre><h5 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h5><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InjectFood</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">injectBurger</span><span class="hljs-params">(Burger burger)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">injectDrink</span><span class="hljs-params">(Drink drink)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KFCCombo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InjectFood</span> </span>&#123;    <span class="hljs-keyword">private</span> Burger burger;    <span class="hljs-keyword">private</span> Drink drink;        <span class="hljs-comment">// 在此注入对应的内容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectBurger</span><span class="hljs-params">(Burger burger)</span> </span>&#123;        <span class="hljs-keyword">this</span>.burger = burger;     &#125;    <span class="hljs-comment">// 在此注入对应的内容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectDrink</span><span class="hljs-params">(Drink drink)</span> </span>&#123;        <span class="hljs-keyword">this</span>.drink = drink;    &#125;&#125;</code></pre><p>接口注入和属性注入并无本质的区别，而且还增加了一个额外的接口导致代码增加，因此不推荐该方式。</p><h4 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h4><h5 id="classpath-与classpath"><a href="#classpath-与classpath" class="headerlink" title="classpath:与classpath*:"></a>classpath:与classpath*:</h5><p>假设有多个Jar包或者文件系统类路径下拥有一个相同包名（如com.ankeetc）：</p><ul><li>classpath：只会在第一个加载的com.ankeetc包的类路径下查找</li><li>classpath*：会扫描到所有的这些JAR包及类路径下出现的com.ankeetc类路径。</li></ul><p>这对于分模块打包的应用非常有用，假设一个应用分为2个模块，每一个模块对应一个配置文件，分别为module1.yaml 、module2.yaml，都放在了com.ankeetc的目录下，每个模块单独打成JAR包。可以使用 <code>classpath*:cn/jimu98/module*.xml</code>加载所有模块的配置文件。</p><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><h3 id="Spring有几种配置方式？"><a href="#Spring有几种配置方式？" class="headerlink" title="Spring有几种配置方式？"></a>Spring有几种配置方式？</h3><p>将Spring配置到应用开发中有以下三种方式： </p><blockquote><p>1.基于XML的配置</p><p>2.基于注解的配置 </p><p>3.基于Java的配置</p></blockquote><h4 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h4><h4 id="如何用基于Java配置的方式配置Spring？"><a href="#如何用基于Java配置的方式配置Spring？" class="headerlink" title="如何用基于Java配置的方式配置Spring？"></a>如何用基于Java配置的方式配置Spring？</h4><p>定义一个配置类</p><h4 id="怎样用注解的方式配置Spring？"><a href="#怎样用注解的方式配置Spring？" class="headerlink" title="怎样用注解的方式配置Spring？"></a>怎样用注解的方式配置Spring？</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringIdolConfig</span> </span>&#123;<span class="hljs-comment">// Bean declaration methods go here</span>&#125;</code></pre><p>声明一个简单的Bean</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Performer <span class="hljs-title">duke</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Juggler();&#125;</code></pre><p>使用Spring的基于java的配置进行注入。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Performer <span class="hljs-title">duke15</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Juggler(<span class="hljs-number">15</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Performer <span class="hljs-title">kenny</span><span class="hljs-params">()</span> </span>&#123;    Instrumentalist kenny = <span class="hljs-keyword">new</span> Instrumentalist();    kenny.setSong(<span class="hljs-string">"Jingle Bells"</span>);    <span class="hljs-keyword">return</span> kenny;&#125;</code></pre><h1 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h1><h2 id="Spring支持的常用数据库事务传播属性和事务隔离级别？"><a href="#Spring支持的常用数据库事务传播属性和事务隔离级别？" class="headerlink" title="Spring支持的常用数据库事务传播属性和事务隔离级别？"></a>Spring支持的常用数据库事务传播属性和事务隔离级别？</h2><blockquote><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p></blockquote><h3 id="Spring中的隔离级别"><a href="#Spring中的隔离级别" class="headerlink" title="Spring中的隔离级别"></a>Spring中的隔离级别</h3><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</td></tr></tbody></table><h3 id="Spring-事务的传播属性"><a href="#Spring-事务的传播属性" class="headerlink" title="Spring 事务的传播属性"></a>Spring 事务的传播属性</h3><p>所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表：</p><table><thead><tr><th>常量名称</th><th>常量解释</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>支持当前事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td></tr></tbody></table><h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持两种类型的事务管理： </p><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维 护。 </p><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置 来管理事务。</p><h3 id="Spring事务隔离级别与Mysql-InnoDB事务隔离级别冲突了怎么办"><a href="#Spring事务隔离级别与Mysql-InnoDB事务隔离级别冲突了怎么办" class="headerlink" title="Spring事务隔离级别与Mysql InnoDB事务隔离级别冲突了怎么办"></a>Spring事务隔离级别与Mysql InnoDB事务隔离级别冲突了怎么办</h3><ul><li>Spring会在事务开始时，根据你程序中设置的隔离级别，调整数据库隔离级别与你的设置一致。</li><li>当使用<code>Serializable</code>级别时，Mysql在执行SQL时会自动修改为<code>select .... lock in share mode</code>, 即使用共享锁。此时<strong>允许同时读，但只允许一个事务写，且锁的是行而不是整张表</strong>。</li></ul><p>这意味着:</p><ul><li>如果数据库不支持某种隔离级别，那么Spring设置了也无效。</li><li>当使用<code>Serializable</code>级别时，如果两个事务读写的不是同一行，那么它们是互不影响的。如果操作同一行记录，那么允许同时读，但如果出现一个对此行的写操作，则在写事务没有提交之前，所有的读事务都会被block。</li></ul><h2 id="Spring-框架中用到了哪些设计模式"><a href="#Spring-框架中用到了哪些设计模式" class="headerlink" title="Spring 框架中用到了哪些设计模式?"></a>Spring 框架中用到了哪些设计模式?</h2><blockquote><p>代理模式—在 AOP 和 remoting 中被用的比较多。<br>单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。<br>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>前端控制器：Spring 提供了 DispatcherServlet 来对请求进行分发。<br>视图帮助(View Helper )：Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码 整合在视图里。<br>依赖注入：贯穿于 BeanFactory / ApplicationContext 接口的核心理念。<br>工厂模式：BeanFactory 用来创建对象的实例。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】Docker总结</title>
    <link href="/posts/17947/"/>
    <url>/posts/17947/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】Docker总结"><a href="#【java总结】Docker总结" class="headerlink" title="【java总结】Docker总结"></a>【java总结】Docker总结</h1><h2 id="docker基础"><a href="#docker基础" class="headerlink" title="docker基础"></a>docker基础</h2><h3 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h3><blockquote><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。使用Go语言进行开发实现，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于LXC（Linux Container）。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></blockquote><h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><p><strong>Docker解决了运行环境和配置问题，方便发布，也就方便做持续集成</strong>。</p><h3 id="Docker与虚拟机有何不同"><a href="#Docker与虚拟机有何不同" class="headerlink" title="Docker与虚拟机有何不同?"></a>Docker与虚拟机有何不同?</h3><blockquote><p>docker可以将应用程序封装在不同的容器中执行，并为每个容器提供单独的运行环境，每个容器内部都可以视为一个完整的主机环境，其功能类似于虚拟机，但和虚拟机相比容器更加轻量。</p><p>虚拟机和主机操作系统的关系是相互独立的，它们共享主机硬件但虚拟机之间以及和主机操作系统之间内核是相互隔离的，虚拟机拥有<strong>完整的系统内核</strong>。容器是运行在主机操作系统之上的，容器以及主机其他程序<strong>共享系统内核</strong>，但每个容器拥有自己独立的运行库以及其他运行环境</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200804230431.png" srcset="/img/loading.gif" alt="image-20200804230431186"></p><h3 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h3><blockquote><p>镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是 Docker 的核心。</p></blockquote><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义：</p><p><img src="https://img2.jimu98.cn/blog/20200804231333.png" srcset="/img/loading.gif" alt="image-20200804231333267"></p><p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其他层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够在主机的文件系统上访问到。</p><p>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。</p><p>这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器（Container）的定义和镜像（Image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><p><img src="https://img2.jimu98.cn/blog/20200804231406.png" srcset="/img/loading.gif" alt="image-20200804231406804"></p><p>由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行。</p><p>但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry（仓库注册服务器）就是这样的服务。</p><p>有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，并不严格区分。</p><p>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><p>实际上，一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应着一个镜像。</p><p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。</p><p>仓库又可以分为两种形式：</p><ul><li>Public（公有仓库）</li><li>Private（私有仓库）</li></ul><p>Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p><p>当用户创建了自己的镜像之后就可以使用 Push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 Pull 下来就可以了。</p><p>我们主要把 Docker 的一些常见概念如 Image，Container，Repository 做了详细的阐述，也从传统虚拟化方式的角度阐述了 Docker 的优势。</p><p>我们从下图可以直观地看到 Docker 的架构：</p><p><img src="https://img2.jimu98.cn/blog/20200804231628.png" srcset="/img/loading.gif" alt="image-20200804231628184"></p><p>Docker 使用 C/S 结构，即客户端/服务器体系结构。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。</p><p>Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 Stock 或网络接口与远程 Docker 服务端进行通信。</p><p><img src="https://img2.jimu98.cn/blog/20200804231652.png" srcset="/img/loading.gif" alt="image-20200804231651989"></p><p>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下 Docker 会在 Docker 中央仓库寻找镜像文件。</p><p>这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p><h3 id="Dokcer-组成原理"><a href="#Dokcer-组成原理" class="headerlink" title="Dokcer 组成原理"></a>Dokcer 组成原理</h3><p><img src="https://img2.jimu98.cn/blog/20200804224851.png" srcset="/img/loading.gif" alt="image-20200804224851934"></p><p>所有 Docker 容器都共享主机系统的 bootfs 即 Linux 内核</p><p>每个容器有自己的 rootfs，它来自不同的 Linux 发行版的基础镜像，包括 Ubuntu，Debian 和 SUSE 等</p><p>所有基于一种基础镜像的容器都共享这种 rootfs</p><p><img src="https://img2.jimu98.cn/blog/20200806155128.png" srcset="/img/loading.gif" alt="image-20200806155128497"></p><h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><ul><li><strong>1、简化程序：</strong><br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。</li><li><strong>2、避免选择恐惧症：</strong><br>如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</li><li><strong>3、节省开支：</strong><br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li></ul><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><blockquote><p>yum install docker-io</p><p> /etc/init.d/docker start启动docker。</p></blockquote><h3 id="制作自己的Docker镜像"><a href="#制作自己的Docker镜像" class="headerlink" title="制作自己的Docker镜像"></a>制作自己的Docker镜像</h3><p>这里先配置下Docker的镜像加速</p><blockquote><p><a href="https://aw7s5l76.mirror.aliyuncs.com" target="_blank" rel="noopener">https://aw7s5l76.mirror.aliyuncs.com</a></p></blockquote><p>可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器,大家最好使用自己的加速地址</p><pre><code class="hljs json">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;  <span class="hljs-attr">"registry-mirrors"</span>: [<span class="hljs-string">"https://aw7s5l76.mirror.aliyuncs.com"</span>]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>自己制作的docker我都推送到了阿里云docker管理平台了，而不是推送到docker官方的管理平台。下面首先介绍一下使用阿里云docker管理平台创建自己的仓库。</p><p><img src="https://img2.jimu98.cn/blog/20200804232409.png" srcset="/img/loading.gif" alt="image-20200804232408934"></p><p>创建完成后登录阿里云docker</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username=  registry.cn-beijing.aliyuncs.com</span></code></pre><p>登录registry的用户名是您的阿里云账号全名，密码是您开通服务时设置的密码。</p><p>你可以在镜像管理首页点击右上角按钮修改docker login密码。</p><p>从registry中拉取镜像：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker pull registry.cn-beijing.aliyuncs.com/spencer_docker/django2:[镜像版本号]</span></code></pre><p>将镜像推送到registry：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username= registry.cn-beijing.aliyuncs.com</span><span class="hljs-meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-beijing.aliyuncs.com/spencer_docker/django2:[镜像版本号]</span><span class="hljs-meta">$</span><span class="bash"> sudo docker push registry.cn-beijing.aliyuncs.com/spencer_docker/django2:[镜像版本号]</span></code></pre><p>其中[ImageId],[镜像版本号]请你根据自己的镜像信息进行填写。</p><p> ① -m是对提交的描述，author是作者(选填)，后面的c28e5976a6ab是修改容器的id，后面的是新镜像名字和标签(tag)。</p><p>② 成功之后，会生成新的镜像id</p><p>③ 输入docker images 查看镜像，会发现新的名为spencer/django，标签为v1的镜像已经存在。</p><p>4）推送到阿里云docker管理平台，命令参考上面将镜像推送到阿里云registry</p><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><blockquote><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><p><strong>docker kill</strong> :杀掉一个运行中的容器</p><p><strong>docker rm ：</strong>删除一个或多少容器</p><p><strong>docker pause</strong> :暂停容器中所有的进程</p><p><strong>docker unpause</strong> :恢复容器中所有的进程</p><p><strong>docker create ：</strong>创建一个新的容器但不启动它</p><p><strong>docker exec ：</strong>在运行的容器中执行命令</p></blockquote><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><blockquote><p><strong>docker ps :</strong> 列出容器</p><p><strong>docker inspect :</strong> 获取容器/镜像的元数据</p><p><strong>docker top :</strong>查看容器中运行的进程信息，支持 ps 命令参数</p><p><strong>docker attach :</strong>连接到正在运行中的容器</p><p><strong>docker events :</strong> 从服务器获取实时事件</p><p><strong>docker logs :</strong> 获取容器的日志</p><p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码</p><p><strong>docker export :</strong>将文件系统作为一个tar归档文件导出到STDOUT</p><p><strong>docker port :</strong>列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</p><p>docker ps -a | awk ‘{print $1}’     查询</p><p>docker ps -a | awk ‘{print $1}’|xargs docker stop      批量停止</p><p>docker ps -a | awk ‘{print $1}’|xargs docker rm  删除</p></blockquote><h3 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h3><blockquote><p><strong>docker commit :</strong>从容器创建一个新的镜像（提交镜像）</p><p><strong>docker cp :</strong>用于容器与主机之间的数据拷贝</p><p><strong>docker diff :</strong> 检查容器里文件结构的更改</p></blockquote><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><blockquote><p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像(下载镜像)</p><p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><p><strong>docker search :</strong> 从Docker Hub查找镜像</p></blockquote><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><blockquote><p><strong>docker images :</strong> 列出本地镜像</p><p><strong>docker rmi :</strong> 删除本地一个或多少镜像</p><p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库</p><p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像</p><p><strong>docker history :</strong> 查看指定镜像的创建历史</p><p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件</p><p><strong>docker import :</strong> 从归档文件中创建镜像</p></blockquote><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><blockquote><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><p>docker version :显示 Docker 版本信息</p></blockquote><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>dockerfile是一个包含构建镜像所需命令的文本文件，docker可以根据dockerfile文件构建镜像<br>dockerfile以<code>from</code>开始，表示使用另一个镜像作为生成当前镜像的基础，新创建的镜像会包含基础镜像的内容。dockerfile中包含了构建镜像所需的全部命令。</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用python的运行环境作为parent image</span><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">2.7</span>-slim<span class="hljs-comment"># 设置工作路径</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-comment"># 将当前目录的内容复制到相应路径下</span><span class="hljs-keyword">COPY</span><span class="bash"> . /app</span><span class="hljs-comment"># 下载requirements.txt中要求的包</span><span class="hljs-keyword">RUN</span><span class="bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span><span class="hljs-comment"># 暴露容器的80端口</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><span class="hljs-comment"># 定义环境变量</span><span class="hljs-keyword">ENV</span> NAME World<span class="hljs-comment">#当docker开始运行时执行文件</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"python"</span>, <span class="hljs-string">"app.py"</span>]</span></code></pre><h2 id="Docker场景题"><a href="#Docker场景题" class="headerlink" title="Docker场景题"></a>Docker场景题</h2><h3 id="Docker是如何实现隔离的？"><a href="#Docker是如何实现隔离的？" class="headerlink" title="Docker是如何实现隔离的？"></a>Docker是如何实现隔离的？</h3><p>Docker的隔离性<strong>主要运用Namespace 技术</strong>。传统上Linux中的PID是唯一且独立的，在正常情况下，用户不会看见重复的PID。然而在Docker采用了Namespace，从而令相同的PID可于不同的Namespace中独立存在。如，A Container 之中PID=1是A程序，而B Container之中的PID=1同样可以是A程序。虽然Docker可透过Namespace的方式分隔出看似是独立的空间，然而Linux内核（Kernel）却不能Namespace，所以即使有多个Container，所有的system call其实都是通过主机的内核处理，这便为Docker留下了不可否认的安全问题。</p><p><strong>namespace（命名空间）可以隔离哪些</strong></p><ul><li>文件系统需要是被隔离的</li><li>网络也是需要被隔离的</li><li>进程间的通信也要被隔离</li><li>针对权限，用户和用户组也需要隔离</li><li>进程内的PID也需要与宿主机中的PID进行隔离</li><li>容器也要有自己的主机名</li><li>有了以上的隔离，我们认为一个容器可以与宿主机和其他容器是隔离开的。</li><li>恰巧Linux 的namespace可以做到这些。</li></ul><p><strong>使用Namespace进行容器的隔离有什么缺点呢？</strong><br>　　最大的缺点就是隔离不彻底<br>　　1）容器知识运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核<br>　　2）在Linux内核中，有很多资源和对象是不能被Namespace化的，最典型的例子是：时间即如果某个容器修改了时间，那整个宿主机的时间都会随之修改<br>　　3）容器给应用暴露出来的攻击面比较大，在生产环境中，没有人敢把运行在物理机上的Linux容器暴露在公网上</p><p><strong>Linux的 cgroups</strong><br><strong>强大内核工具cgroups</strong><br>cgroups是Linux的另外一个强大的内核工具，有了cgroups，不仅可以限制被namespace隔离起来的资源，还可以为资源设置权重、计算使用量、操控任务（进程或县城）启停等。说白了就是：cgroups可以限制、记录任务组所使用的物理资源（包括CPU，Memory，IO等），是构建Docker等一系列虚拟化管理工具的基石。</p><p><strong>cgroups 的作用</strong><br>　　cgroups 为不同用户层面的资源管理提供了一个统一接口，从单个的资源控制到操作系统层面的虚拟化，cgroups提供了4大功能。</p><ul><li>资源限制</li></ul><p>cgroups可以对任务使用的资源总额进行限制。<br>如 设定应用运行时使用的内存上限，一旦超过配额就发出OOM提示</p><ul><li>优先级分配</li></ul><p>通过分配的CPU时间片数量以及磁盘IO带宽大小，实际上就相当于控制了任务运行的优先级</p><ul><li>资源统计</li></ul><p>cgroups可以统计系统的资源使用量<br>如CPU使用时长，内存用量等，这个功能非常适用于计费</p><ul><li>任务控制</li></ul><p>cgroups 可以对任务进行挂起、恢复等操作</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】数据库-Redis</title>
    <link href="/posts/10392/"/>
    <url>/posts/10392/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】数据库-Redis"><a href="#【java总结】数据库-Redis" class="headerlink" title="【java总结】数据库-Redis"></a>【java总结】数据库-Redis</h1><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis?"></a>什么是 Redis?</h3><p>Redis 是一款非常受欢迎的NoSQL数据库，他是使用C语言编写而成的 开源免费的，一个高性能的 key-value 数据库。整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘 上进行保存。</p><p>缺点：由于他受到物理内存的限制，因此无法用作海量数据的高性能读写</p><h3 id="为什么-Redis-需要把所有数据放到内存中？"><a href="#为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中？"></a>为什么 Redis 需要把所有数据放到内存中？</h3><ul><li>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，所以 Redis 具有高速读写和数据持久化的特征</li><li>如果程序直接与磁盘交互，磁盘 IO 速度会严重影响 Redis 的性能</li><li>内存的硬件成本降低，使得 Redis 更受欢迎</li></ul><h3 id="Redis-能用来做什么？"><a href="#Redis-能用来做什么？" class="headerlink" title="Redis 能用来做什么？"></a>Redis 能用来做什么？</h3><blockquote><p>会话缓存，排行榜，计数器，发布，订阅，地图信息分析（附近的人）</p></blockquote><ol><li>记录帖子的点赞数、评论数和点击数 (hash)。</li><li>记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。</li><li>记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。</li><li>记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。</li><li>缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。</li><li>记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。</li><li>如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。</li><li>收藏集和帖子之间的关系 (zset)。</li><li>记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。</li><li>缓存用户行为历史，进行恶意行为过滤 (zset,hash)。</li></ol><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p><strong>Docker 方式</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 拉取 redis 镜像</span><span class="hljs-meta">&gt;</span><span class="bash"> docker pull redis</span><span class="hljs-meta">#</span><span class="bash"> 运行 redis 容器</span><span class="hljs-meta">&gt;</span><span class="bash"> docker run --name myredis -d -p6379:6379 redis</span><span class="hljs-meta">#</span><span class="bash"> 执行容器中的 redis-cli，可以直接使用命令行操作 redis</span><span class="hljs-meta">&gt;</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it myredis redis-cli</span></code></pre><p><strong>Github 源码编译方式</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载源码</span><span class="hljs-meta">&gt;</span><span class="bash"> git <span class="hljs-built_in">clone</span> --branch 2.8 --depth 1 git@github.com:antirez/redis.git</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> redis</span><span class="hljs-meta">#</span><span class="bash"> 编译</span><span class="hljs-meta">&gt;</span><span class="bash"> make</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> src</span><span class="hljs-meta">#</span><span class="bash"> 运行服务器，daemonize表示在后台运行</span><span class="hljs-meta">&gt;</span><span class="bash"> ./redis-server --daemonize yes</span><span class="hljs-meta">#</span><span class="bash"> 运行命令行</span><span class="hljs-meta">&gt;</span><span class="bash"> ./redis-cli</span></code></pre><p><strong>直接安装方式</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mac</span><span class="hljs-meta">&gt;</span><span class="bash"> brew install redis</span><span class="hljs-meta">#</span><span class="bash"> ubuntu</span><span class="hljs-meta">&gt;</span><span class="bash"> apt-get install redis</span><span class="hljs-meta">#</span><span class="bash"> redhat</span><span class="hljs-meta">&gt;</span><span class="bash"> yum install redis</span><span class="hljs-meta">#</span><span class="bash"> 运行客户端</span><span class="hljs-meta">&gt;</span><span class="bash"> redis-cli</span></code></pre><p><a href="https://try.redis.io/" target="_blank" rel="noopener">网页直接测试</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">set</span> name jimu98   <span class="hljs-comment">#设置值</span></span><span class="hljs-meta">&gt;</span><span class="bash"> get name    <span class="hljs-comment">#获取值</span></span>"jimu98"<span class="hljs-meta">&gt;</span><span class="bash"> exists name   <span class="hljs-comment">#是否存在</span></span><span class="hljs-meta">&gt;</span><span class="bash"> del name   <span class="hljs-comment">#删除</span></span><span class="hljs-meta">&gt;</span><span class="bash"> flushdb  <span class="hljs-comment">#清除自己数据库</span></span><span class="hljs-meta">&gt;</span><span class="bash"> flushall <span class="hljs-comment">#清除所有数据库</span></span><span class="hljs-meta">&gt;</span><span class="bash"> expire name 10 <span class="hljs-comment">#10s后过期</span></span><span class="hljs-meta">&gt;</span><span class="bash"> ttl name <span class="hljs-comment">#查看剩余过期时间</span></span><span class="hljs-meta">&gt;</span><span class="bash"> PERSIST name   <span class="hljs-comment"># 移除 name 的过期时间</span></span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">type</span> name <span class="hljs-comment">#查看类型</span></span><span class="hljs-meta">&gt;</span><span class="bash"> mset name1 boy name2 girl <span class="hljs-comment">#批量设置</span></span><span class="hljs-meta">&gt;</span><span class="bash"> mget name1 name2  <span class="hljs-comment">#批量接收</span></span>其他自己百度吧。</code></pre><h3 id="Reids数据类型"><a href="#Reids数据类型" class="headerlink" title="Reids数据类型"></a>Reids数据类型</h3><blockquote><p>常用5种数据类型：string，list，set，zset，hash</p><p>一个字符串类型的值能存储最大容量是多少？512M</p></blockquote><p>三种特殊数据类型</p><p>geospatial：</p><p>（地理位置）</p><p>hyperloglog：</p><p>（基础统计，统计一个集合中不重复的数据，使用位运算的方式，但是存在0.81%错误率）</p><p>bitmap（位图，只记录0，1）</p><h3 id="Redis是单进程单线程的？"><a href="#Redis是单进程单线程的？" class="headerlink" title="Redis是单进程单线程的？"></a>Redis是单进程单线程的？</h3><p>Redis是单进程单线程的，Redis利用<strong>队列</strong>技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><p>多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。因为CPU不是Redis 的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。</p><p>单线程无法发挥多核CPU性能，不 过可以通过在单机开多个Redis实例来解决。另外在5月2号发布了全新的redis6.0，正式支持多线程</p><h3 id="Redis-数据淘汰策略"><a href="#Redis-数据淘汰策略" class="headerlink" title="Redis 数据淘汰策略"></a>Redis 数据淘汰策略</h3><p>Redis 提供 6种内存淘汰策略</p><ol><li>Volatile-lru:从设置了过期时间的数据集中，选择最近最少使用的数据释放。</li><li>Allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中),选择最近最少使用的数据释放。</li><li>Volatile-random:从设置了过期时间的数据集中，随机选择一个数据进行释放。</li><li>Allkeys-random:从数据集中(包括了设置过期时间以及未设置过期时间的数据集)随机选择一个数据进行入释放。</li><li>Volatile-ttl:从设置了过期时间的数据集中，选择马上就要过期的数据进行释放。</li><li>Noeviction:不删除任意数据(但Redis还会根据引用计数器进行释放)，这时如果内存不够时，会直接返回错误。</li></ol><h3 id="Redis单点吞吐量"><a href="#Redis单点吞吐量" class="headerlink" title="Redis单点吞吐量"></a>Redis单点吞吐量</h3><p>单点TPS（每秒钟最大能处理的请求数）达到8万/秒，QPS（每秒钟最大能接受的用户访问量）达到10万/秒，补充下TPS和QPS的概念</p><p>1.QPS: 应用系统每秒钟最大能接受的用户访问量 每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回 结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。 </p><p>2.TPS： 每秒钟最大能处理的请求数 每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理 中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。</p><h2 id="Redis配置详解"><a href="#Redis配置详解" class="headerlink" title="Redis配置详解"></a>Redis配置详解</h2><h3 id="Redis-支持的-Java-客户端都有哪些？官方推荐用哪个"><a href="#Redis-支持的-Java-客户端都有哪些？官方推荐用哪个" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？官方推荐用哪个"></a>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个</h3><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p><h3 id="Jedis-与-Redisson-对比有什么优缺点？"><a href="#Jedis-与-Redisson-对比有什么优缺点？" class="headerlink" title="Jedis 与 Redisson 对比有什么优缺点？"></a>Jedis 与 Redisson 对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；<br>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作， 不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从 而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="Redis提供了哪几种持久化方式？"><a href="#Redis提供了哪几种持久化方式？" class="headerlink" title="Redis提供了哪几种持久化方式？"></a>Redis提供了哪几种持久化方式？</h3><p>Redis主要提供了两种持久化机制：RDB和AOF；</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="https://img2.jimu98.cn/blog/20200803210747.png" srcset="/img/loading.gif" alt="image-20200803210747126"></p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><img src="https://img2.jimu98.cn/blog/20200803210817.png" srcset="/img/loading.gif" alt="image-20200803210817902"></p><h4 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h4><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li><li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li><li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><h4 id="AOF-优缺点"><a href="#AOF-优缺点" class="headerlink" title="AOF 优缺点"></a>AOF 优缺点</h4><p>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了三种同步策略，</p><blockquote><p>即每秒同步、每修改同步和不同步。</p></blockquote><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code>，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li></ul><h4 id="RDB-和-AOF-到底该如何选择"><a href="#RDB-和-AOF-到底该如何选择" class="headerlink" title="RDB 和 AOF 到底该如何选择"></a>RDB 和 AOF 到底该如何选择</h4><ul><li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li><li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li><li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li></ul><h2 id="Redis事务操作"><a href="#Redis事务操作" class="headerlink" title="Redis事务操作"></a>Redis事务操作</h2><h3 id="怎么理解-Redis-事务？"><a href="#怎么理解-Redis-事务？" class="headerlink" title="怎么理解 Redis 事务？"></a>怎么理解 Redis 事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>redis对事务的支持目前还比较简单。redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。 由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。</p><p>redis没有回滚的概念，已经执行的动作不能<code>undo</code>。当事务在<strong>执行EXEC命令之前</strong>出现错误，则redis会清空事务队列，放弃执行事务。在EXEC之后<strong>redis批量执行命令时产生的错误会被忽略，其他命令继续执行</strong>（这是全部执行的真正含义）。在执行的过程中，redis命令只会因为错误的语法而失败，因此，事务无罪。</p><h3 id="Redis事务的命令"><a href="#Redis事务的命令" class="headerlink" title="Redis事务的命令"></a>Redis事务的命令</h3><p>MULTI、EXEC、DISCARD和WATCH命令是Redis事务功能的基础。</p><h4 id="MULTI命令"><a href="#MULTI命令" class="headerlink" title="MULTI命令"></a>MULTI命令</h4><p>MULTI命令用来开启一个事务，当事务开启之后，客户端可以继续向服务器发送多条命令，<strong>这些命令会缓存在队列里面</strong>，而<strong>非执行</strong>（这点很重要，这代表着在multi开启事务以后无法根据get到的数据做逻辑判断），只有当执行EXEC命令时，这些命令才会执行。</p><h4 id="DISCARD命令"><a href="#DISCARD命令" class="headerlink" title="DISCARD命令"></a>DISCARD命令</h4><p>DISCARD命令可以清空事务队列，放弃执行事务。</p><p>如果使用了WATCH命令，DISCARD命令会将当前连接监控的所有键取消监控。</p><h4 id="EXEC命令"><a href="#EXEC命令" class="headerlink" title="EXEC命令"></a>EXEC命令</h4><p>EXEC命令会触发执行事务中的所有命令。当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。</p><h2 id="Redis内存"><a href="#Redis内存" class="headerlink" title="Redis内存"></a>Redis内存</h2><h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小， 所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用 户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的 所有信息存储到一张散列表里面.</p><h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ul><li>一个客户端运行了新的命令，添加了新的数据。</li><li>Redis检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li><li>一个新的命令被执行，等等。</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li></ul><p>Redis使用的是近似的LRU算法，通过少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。从redis3.0以后，redis改进了回收键的候选池，也就是改善了算法的性能，使得更加近似真的LRU算法。</p><h3 id="redis过期键的删除策略？"><a href="#redis过期键的删除策略？" class="headerlink" title="redis过期键的删除策略？"></a>redis过期键的删除策略？</h3><p>（1）定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。 </p><p>（2）惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过 期，如果过期的话，就删除该键;如果没有过期，就返回该键。 </p><p>（3）定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h2 id="Redis高级功能"><a href="#Redis高级功能" class="headerlink" title="Redis高级功能"></a>Redis高级功能</h2><h3 id="Redis主要有哪些功能？"><a href="#Redis主要有哪些功能？" class="headerlink" title="Redis主要有哪些功能？"></a>Redis主要有哪些功能？</h3><h4 id="哨兵（Sentinel）和复制（Replication）"><a href="#哨兵（Sentinel）和复制（Replication）" class="headerlink" title="哨兵（Sentinel）和复制（Replication）"></a>哨兵（Sentinel）和复制（Replication）</h4><p>Redis服务器毫无征兆的罢工是个麻烦事，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要哨兵和复制。</p><p>Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，Replication则是负责让一个Redis服务器可以配备多个备份的服务器。</p><p>Redis也是利用这两个功能来保证Redis的高可用的</p><p><strong>事务</strong></p><p>很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。</p><p><strong>LUA脚本</strong></p><p>在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了</p><p><strong>持久化</strong></p><p>redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。</p><p><strong>集群（Cluster）</strong></p><p>单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，这也有点类似mysql数据库的主从同步。</p><p>在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的。</p><h3 id="Pipeline-有什么好处，为什么要用-pipeline？"><a href="#Pipeline-有什么好处，为什么要用-pipeline？" class="headerlink" title="Pipeline 有什么好处，为什么要用 pipeline？"></a>Pipeline 有什么好处，为什么要用 pipeline？</h3><p>可以将多次 IO 往返的时间缩减为一次</p><h3 id="使用过-Redis-分布式锁么，它是什么回事？"><a href="#使用过-Redis-分布式锁么，它是什么回事？" class="headerlink" title="使用过 Redis 分布式锁么，它是什么回事？"></a>使用过 Redis 分布式锁么，它是什么回事？</h3><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了 释放。 </p><p>如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？ </p><p> set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！</p><h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><h3 id="Redis集群方案-1"><a href="#Redis集群方案-1" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h3><h4 id="官方cluser方案"><a href="#官方cluser方案" class="headerlink" title="官方cluser方案"></a>官方cluser方案</h4><p>从redis 3.0版本开始支持redis-cluster集群，redis-cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他节点连接。redis-cluster是一种服务端分片技术。</p><p>redis-cluster架构图</p><p><img src="https://img2.jimu98.cn/blog/20200803222701.png" srcset="/img/loading.gif" alt="image-20200803222701385"></p><p>Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点儿类pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。</p><p>Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。</p><p>Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。</p><p>为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。</p><p>Redis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为集群总线(cluster bus)。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p><p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p><h4 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h4><p>codis由3大组件构成：</p><ul><li>codis-server : 修改过源码的redis, 支持slot，扩容迁移等</li><li>codis-proxy : 支持多线程，go语言实现的内核</li><li>codis Dashboard : 集群管理工具</li></ul><p>提供web图形界面管理集群。 集群元数据存在在zookeeper或etcd。 提供独立的组件codis-ha负责redis节点主备切换。 基于proxy的codis，客户端对路由表变化无感知。客户端需要从codis dashhoard调用list proxy命令获取所有proxy列表，并根据自身的轮询策略决定访问哪个proxy节点以实现负载均衡。</p><h4 id="Redis-Sharding集群"><a href="#Redis-Sharding集群" class="headerlink" title="Redis Sharding集群"></a>Redis Sharding集群</h4><p>Sharding架构图：</p><p><img src="https://img2.jimu98.cn/blog/20200803223335.png" srcset="/img/loading.gif" alt="image-20200803223335581"></p><p>Redis 3正式推出了官方集群技术，解决了多Redis实例协同服务问题。Redis Cluster可以说是服务端Sharding分片技术的体现，即将键值按照一定算法合理分配到各个实例分片上，同时各个实例节点协调沟通，共同对外承担一致服务。</p><p>多Redis实例服务，比单Redis实例要复杂的多，这涉及到定位、协同、容错、扩容等技术难题。这里，我们介绍一种轻量级的客户端Redis Sharding技术。</p><p>Redis Sharding可以说是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。这样，客户端就知道该向哪个Redis节点操作数据。Sharding架构如图：</p><p>还有阿里的之类的</p><p>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p><p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行 分片存储。</p><h3 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h3><p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通 过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><h3 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h3><p>16384 个 </p><h3 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主 从复制模型,每个节点都会有N-1个复制品.</p><h3 id="Redis-集群会有写操作丢失吗？为什么？"><a href="#Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis 集群会有写操作丢失吗？为什么？"></a>Redis 集群会有写操作丢失吗？为什么？</h3><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 </p><h3 id="Redis-集群之间是如何复制的？"><a href="#Redis-集群之间是如何复制的？" class="headerlink" title="Redis 集群之间是如何复制的？"></a>Redis 集群之间是如何复制的？</h3><p>异步复制</p><h3 id="Redis-集群如何选择数据库？"><a href="#Redis-集群如何选择数据库？" class="headerlink" title="Redis 集群如何选择数据库？"></a>Redis 集群如何选择数据库？</h3><p> Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><h3 id="Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis 集群方案什么情况下会导致整个集群不可用？"></a>Redis 集群方案什么情况下会导致整个集群不可用？</h3><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了， 那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><h2 id="Redis场景题"><a href="#Redis场景题" class="headerlink" title="Redis场景题"></a>Redis场景题</h2><h3 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><p>如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会 有什么问题？</p><p>redis 的单线程的。keys 指令会导致线 程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时 候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但 是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间 会比直接用 keys 指令长。</p><h3 id="如果有大量的-key-需要设置同一时间过期，一般需要注意-什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意-什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意 什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意 什么？</h3><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能 会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一 些。</p><h3 id="为啥-Redis-单线程模型也能效率这么高？"><a href="#为啥-Redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 Redis 单线程模型也能效率这么高？"></a>为啥 Redis 单线程模型也能效率这么高？</h3><p>纯内存操作。<br>核心是基于非阻塞的 IO 多路复用机制。<br>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。<br>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】数据库-Mysql</title>
    <link href="/posts/46833/"/>
    <url>/posts/46833/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】数据库-Mysql"><a href="#【java总结】数据库-Mysql" class="headerlink" title="【java总结】数据库-Mysql"></a>【java总结】数据库-Mysql</h1><h1 id="mysql基础"><a href="#mysql基础" class="headerlink" title="mysql基础"></a>mysql基础</h1><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p><strong>第一范式(确保每列保持原子性)</strong></p><p><strong>第二范式(确保表中的每列都和主键相关)</strong></p><p><strong>第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></p><p>与第二范式区别在于其他非主键不依赖其他非主键<strong>消除传递依赖</strong></p><h2 id="Join七种连接"><a href="#Join七种连接" class="headerlink" title="Join七种连接"></a>Join七种连接</h2><p><img src="https://img2.jimu98.cn/blog/20200801150158.png" srcset="/img/loading.gif" alt="image-20200801150158255"></p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器，是一类由数据库操作事件(插入、删除、修改)驱动的特殊过程，一旦由某个用户定义，任何用户对该触发器指定的数据进行增删改操作时，系统将自动激活响应的触发动作，在数据库服务器上进行集中的完整性控制。触发器的定义包括两部分内容：</p><ul><li>指明触发器的触发事件</li><li>指明触发器执行的动作<br>触发器的类型：</li></ul><table><thead><tr><th>触发方式</th><th>For each statement</th><th>For each row</th></tr></thead><tbody><tr><td>before选项</td><td>语句前触发器，在执行触发语句前激活触发器一次</td><td>行前触发器，在执行触发语句所影响的每一行前，激活触发器一次</td></tr><tr><td>after选项</td><td>语句前触发器，在执行触发语句后激活触发器一次</td><td>行前触发器，在执行触发语句所影响的每一行后，激活触发器一次</td></tr></tbody></table><p>优点：</p><ul><li>安全性：可以基于数据库的值使用户具有操作数据库的某种权利。可以基于时间限制用户的操作，例如不允许下班后和节假日修改数据库数据；可以基于数据库中的数据限制用户的操作，例如不允许股票的价格的升幅一次超过10%</li><li>审计：可以跟踪用户对数据库的操作。审计用户操作数据库的语句；把用户对数据库的更新写入审计表。</li><li>实现复杂的数据完整性规则：实现非标准的数据完整性检查和约束。触发器可产生比规则更为复杂的限制。与规则不同，触发器可以引用列或数据库对象。例如，触发器可回退任何企图吃进超过自己保证金的期货。提供可变的缺省值。</li><li>同步实时地复制表中的数据。</li></ul><p>缺点：</p><ul><li>消耗资源</li><li>延长响应时间</li></ul><h1 id="MyISAM与InnoDb"><a href="#MyISAM与InnoDb" class="headerlink" title="MyISAM与InnoDb"></a>MyISAM与InnoDb</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><blockquote><p>它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。</p></blockquote><h2 id="InnoDb"><a href="#InnoDb" class="headerlink" title="InnoDb"></a>InnoDb</h2><blockquote><p>支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。</p></blockquote><h2 id="MyISAM和InnoDb的区别"><a href="#MyISAM和InnoDb的区别" class="headerlink" title="MyISAM和InnoDb的区别"></a>MyISAM和InnoDb的区别</h2><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。<br>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h3 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a>表锁差异</h3><p>MyISAM：<strong>只支持表级锁</strong>，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。也可以通过lock table命令来锁表，这样操作主要是可以模仿事务，但是消耗非常大，一般只在实验演示中使用。</p><p>InnoDb：支持事务和行级锁，是innodb的最大特色。是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只有支持WHERE的主键是有效的情况，非主键的WHERE都会锁全表。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是,InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h3 id="数据库文件差异"><a href="#数据库文件差异" class="headerlink" title="数据库文件差异"></a>数据库文件差异</h3><p>MyISAM：myisam属于堆表,每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>myisam表还支持三种不同的存储格式：</p><blockquote><p>静态表(默认，但是注意数据末尾不能有空格，会被去掉)<br>动态表<br>压缩表</p></blockquote><p> InnoDB：innodb属于索引组织表，innodb有两种存储方式，共享表空间存储和多表空间存储，两种存储方式的表结构和myisam一样，以表名开头，扩展名是.frm。</p><p>如果使用共享表空间，那么所有表的数据文件和索引文件都保存在一个表空间里，一个表空间可以有多个文件，通过innodb_data_file_path和innodb_data_home_dir参数设置共享表空间的位置和名字，一般共享表空间的名字叫ibdata1-n。</p><p>如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。</p><h3 id="关于自动增长"><a href="#关于自动增长" class="headerlink" title="关于自动增长"></a>关于自动增长</h3><p>myisam引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>innodb引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。MyISAM的2倍。</p><h3 id="关于主键"><a href="#关于主键" class="headerlink" title="关于主键"></a>关于主键</h3><p>myisam允许没有任何索引和主键的表存在，myisam的索引都是保存行的地址。</p><p>innodb引擎如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，innodb的数据是主索引的一部分，附加索引保存的是主索引的值。</p><h3 id="关于count-函数"><a href="#关于count-函数" class="headerlink" title="关于count()函数"></a>关于count()函数</h3><p>MyISAM：保存有表的总行数，如果select count(星号) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(星号) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM：支持(FULLTEXT类型的)全文索引。<br>InnoDB：不支持(FULLTEXT类型的)全文索引，Mysql5.7版本以后支持全文索引，另外innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h3 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a>可移植性、备份及恢复</h3><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h3 id="索引保存位置"><a href="#索引保存位置" class="headerlink" title="索引保存位置"></a>索引保存位置</h3><p>myisam的索引以表名+.MYI文件分别保存。</p><p>innodb的索引和数据一起保存在表空间里。</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>MyISAM：不支持。<br>InnoDB：支持。</p><h3 id="查询效率"><a href="#查询效率" class="headerlink" title="查询效率"></a>查询效率</h3><p>没有where的count(星号)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(星号)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(星号)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(星号)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li><li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li></ul><h1 id="索引原理及优化分析"><a href="#索引原理及优化分析" class="headerlink" title="索引原理及优化分析"></a>索引原理及优化分析</h1><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。是存储引擎一种用于快速查找记录的数据结构。</p><p>其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引，当然，除了B+树，还有哈希索引hash index等</p><ul><li><p>优势</p><ul><li><p>提高数据检索的效率，降低数据库的IO成本</p></li><li><p>降低数据排序的成本，降低了CPU的消耗</p></li></ul></li><li><p>劣势</p><ul><li><p>实际上索引也是一张表，所以索引列也是要占用空间的</p></li><li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert，update和delete，因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新锁带来的键值变化后的索引信息</p></li><li><p>索引只是提高效率的一个因素，如果你的MySQL又大量数据的表，就需要花时间研究建立最优秀的索引，或优化查询速度</p></li></ul></li></ul><h2 id="常见的查询算法"><a href="#常见的查询算法" class="headerlink" title="常见的查询算法"></a>常见的查询算法</h2><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），还有例如二分查找（binary search）、二叉排序树查找（binary tree search），哈希散列法(哈希表)，分块查找等。</p><h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>上面讲到了二叉树，它的搜索时间复杂度为<code>O(log2N)</code>，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p><p>B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。下图就是一个典型的B树： </p><p><img src="https://img2.jimu98.cn/blog/20200801162611.png" srcset="/img/loading.gif" alt="image-20200801162611554"></p><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。B-Tree相比，B+Tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1；</li><li>内节点不存储data，只存储key；</li><li>叶子节点不存储指针；</li></ul><p><img src="https://img2.jimu98.cn/blog/20200801163511.png" srcset="/img/loading.gif" alt="image-20200801163511789"></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h3 id="MySql索引类型"><a href="#MySql索引类型" class="headerlink" title="MySql索引类型"></a>MySql索引类型</h3><h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>哈希索引也没办法利用索引完成<strong>排序</strong></li><li>不支持<strong>最左匹配原则</strong></li><li>在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;<strong>哈希碰撞</strong>问题。</li><li><strong>不支持范围查询</strong></li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="全文索引-1"><a href="#全文索引-1" class="headerlink" title="全文索引"></a>全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="五大索引类型"><a href="#五大索引类型" class="headerlink" title="五大索引类型"></a>五大索引类型</h3><ul><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>组合索引</li><li>全文索引</li></ul><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p><h2 id="主键与唯一性索引的区别"><a href="#主键与唯一性索引的区别" class="headerlink" title="主键与唯一性索引的区别"></a>主键与唯一性索引的区别</h2><ul><li>主键一定是唯一性索引，唯一性索引并不一定就是主键</li><li>一个表中可以有多个唯一性索引，但只能有一个主键</li><li>主键列不允许空值，而唯一性索引列允许空值</li><li>主键可以被其他字段作外键引用，而索引不能作为外键引用</li></ul><h2 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h2><blockquote><ul><li>全值匹配我最爱，最左前缀要遵守；</li><li>带头大哥不能死，中间兄弟不能断；</li><li>索引列上少计算，范围之后全失效；</li><li>Like百分写最右，覆盖索引不写星；</li><li>不等非空还有or，索引失效要少用；</li><li>VAR引号不可丢，SQL高级也不难！</li></ul></blockquote><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。</p><h3 id="索引优化策略1"><a href="#索引优化策略1" class="headerlink" title="索引优化策略1"></a>索引优化策略1</h3><h4 id="避免对列的操作"><a href="#避免对列的操作" class="headerlink" title="避免对列的操作"></a>避免对列的操作</h4><h4 id="避免不必要的类型转换"><a href="#避免不必要的类型转换" class="headerlink" title="避免不必要的类型转换"></a>避免不必要的类型转换</h4><h4 id="增加查询的范围限制"><a href="#增加查询的范围限制" class="headerlink" title="增加查询的范围限制"></a>增加查询的范围限制</h4><h4 id="尽量去掉”IN”、”OR”"><a href="#尽量去掉”IN”、”OR”" class="headerlink" title="尽量去掉”IN”、”OR”"></a>尽量去掉”IN”、”OR”</h4><h4 id="尽量去掉-“-lt-gt-”"><a href="#尽量去掉-“-lt-gt-”" class="headerlink" title="尽量去掉 “&lt;&gt;”"></a>尽量去掉 “&lt;&gt;”</h4><h4 id="去掉Where子句中的IS-NULL和IS-NOT-NULL"><a href="#去掉Where子句中的IS-NULL和IS-NOT-NULL" class="headerlink" title="去掉Where子句中的IS NULL和IS NOT NULL"></a>去掉Where子句中的IS NULL和IS NOT NULL</h4><h4 id="索引提高数据分布不均匀时查询效率"><a href="#索引提高数据分布不均匀时查询效率" class="headerlink" title="索引提高数据分布不均匀时查询效率"></a>索引提高数据分布不均匀时查询效率</h4><h4 id="利用HINT强制指定索引"><a href="#利用HINT强制指定索引" class="headerlink" title="利用HINT强制指定索引"></a>利用HINT强制指定索引</h4><h4 id="利用HINT强制指定索引-1"><a href="#利用HINT强制指定索引-1" class="headerlink" title="利用HINT强制指定索引"></a>利用HINT强制指定索引</h4><h4 id="屏蔽无用索引"><a href="#屏蔽无用索引" class="headerlink" title="屏蔽无用索引"></a>屏蔽无用索引</h4><h4 id="分解复杂查询，用常量代替变量"><a href="#分解复杂查询，用常量代替变量" class="headerlink" title="分解复杂查询，用常量代替变量"></a>分解复杂查询，用常量代替变量</h4><h4 id="like子句尽量前端匹配"><a href="#like子句尽量前端匹配" class="headerlink" title="like子句尽量前端匹配"></a>like子句尽量前端匹配</h4><h4 id="用Case语句合并多重扫描"><a href="#用Case语句合并多重扫描" class="headerlink" title="用Case语句合并多重扫描"></a>用Case语句合并多重扫描</h4><h4 id="使用nls-date-format"><a href="#使用nls-date-format" class="headerlink" title="使用nls_date_format"></a>使用nls_date_format</h4><h4 id="使用基于函数的索引"><a href="#使用基于函数的索引" class="headerlink" title="使用基于函数的索引"></a>使用基于函数的索引</h4><h4 id="基于函数的索引要求等式匹配"><a href="#基于函数的索引要求等式匹配" class="headerlink" title="基于函数的索引要求等式匹配"></a>基于函数的索引要求等式匹配</h4><h4 id="使用分区索引"><a href="#使用分区索引" class="headerlink" title="使用分区索引"></a>使用分区索引</h4><h4 id="使用位图索引"><a href="#使用位图索引" class="headerlink" title="使用位图索引"></a>使用位图索引</h4><h4 id="决定使用全表扫描还是使用索引"><a href="#决定使用全表扫描还是使用索引" class="headerlink" title="决定使用全表扫描还是使用索引"></a>决定使用全表扫描还是使用索引</h4><h3 id="索引优化策略2"><a href="#索引优化策略2" class="headerlink" title="索引优化策略2"></a>索引优化策略2</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id + <span class="hljs-number">1</span> = <span class="hljs-number">5</span>;</code></pre><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id, actor_ <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> sakila.film_actor<span class="hljs-keyword">WHERE</span> actor_id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> film_id = <span class="hljs-number">1</span>;</code></pre><h4 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-keyword">DISTINCT</span> staff_id)/COUNT<span class="hljs-comment">(*) AS staff_id_selectivity,</span><span class="hljs-comment">COUNT(DISTINCT customer_id)/COUNT(*)</span> <span class="hljs-keyword">AS</span> customer_id_selectivity,COUNT<span class="hljs-comment">(*)</span><span class="hljs-comment">FROM payment;</span><span class="hljs-comment">   staff_id_selectivity: 0.0001</span><span class="hljs-comment">customer_id_selectivity: 0.0373</span><span class="hljs-comment">               COUNT(*)</span>: <span class="hljs-number">16049</span></code></pre><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>我们很多时候编写完一条SQL语句，往往想知道这条SQL语句执行是否高效。或者说，我们建立好的索引在这条SQL语句中是否使用到了，就可以使用<code>explain</code>命令来分析一下！</p><p>explain命令输出的结果有10列：<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code></p><h3 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a>1.id</h3><blockquote><p>包含一组数字，表示查询中执行SELECT子句或操作表的<strong>顺序</strong>。</p></blockquote><p>在id列上也会有几种情况：</p><ul><li><p>如果id相同执行顺序由上至下。</p></li><li><p>如果id不相同，id的序号会递增，id值越大优先级越高，越先被执行。</p></li><li><ul><li>(一般有子查询的SQL语句id就会不同)</li></ul></li></ul><p><img src="C:%5CUsers%5Ckaibo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802145639682.png" srcset="/img/loading.gif" alt="image-20200802145639682"></p><h3 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a>2.select_type</h3><blockquote><p>表示select查询的类型</p></blockquote><p>select_type属性下有好几种类型：</p><ul><li><strong>SIMPLLE</strong>：简单查询，该查询不包含 UNION 或子查询</li><li><strong>PRIMARY</strong>：如果查询包含UNION 或子查询，则<strong>最外层的查询</strong>被标识为PRIMARY</li><li>UNION：表示此查询是 UNION 中的第二个或者随后的查询</li><li>DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询</li><li>UNION RESULT：UNION 的结果</li><li><strong>SUBQUERY</strong>：子查询中的第一个select语句(该子查询不在from子句中)</li><li>DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询</li><li><strong>DERIVED</strong>：包含在from子句中子查询(也称为派生表)</li><li>UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li><li>UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li></ul><blockquote><p>类型有点多啊，加粗的是最常见的，起码要看得懂加粗的部分。</p></blockquote><h3 id="3-table"><a href="#3-table" class="headerlink" title="3.table"></a>3.table</h3><blockquote><p>该列显示了对应行正在访问哪个表(有别名就显示别名)。</p></blockquote><p>当from子句中有子查询时，table列是 <code>&lt;derivenN&gt;</code>格式，表示当前查询依赖 <code>id=N</code>的查询，于是先执行 <code>id=N</code> 的查询</p><h3 id="4-type"><a href="#4-type" class="headerlink" title="4.type"></a>4.type</h3><blockquote><p>该列称为<strong>关联类型或者访问类型</strong>，它指明了MySQL决定如何查找表中符合条件的行，同时<strong>是我们判断查询是否高效的重要依据</strong>。</p></blockquote><p>以下为常见的取值</p><ul><li>ALL：<strong>全表扫描</strong>，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型，因为这样的查询，在数据量最大的情况下，对数据库的性能是巨大的灾难。</li><li>index：<strong>全索引扫描</strong>，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。</li><li>range：<strong>范围扫描</strong>，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 <code>=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN、IN()</code> 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。</li><li>ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。</li><li>eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时会出现该值，非常高效。</li><li>const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。</li><li>NULL：在执行阶段不需要访问表。</li></ul><h3 id="5-possible-keys"><a href="#5-possible-keys" class="headerlink" title="5.possible_keys"></a>5.possible_keys</h3><blockquote><p>这一列显示查询<strong>可能</strong>使用哪些索引来查找</p></blockquote><h3 id="6-key"><a href="#6-key" class="headerlink" title="6.key"></a>6.key</h3><blockquote><p>这一列显示MySQL<strong>实际</strong>决定使用的索引。如果没有选择索引，键是NULL。</p></blockquote><h3 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7.key_len"></a>7.key_len</h3><blockquote><p>这一列显示了在索引里使用的字节数，当key列的值为 NULL 时，则该列也是 NULL</p></blockquote><h3 id="8-ref"><a href="#8-ref" class="headerlink" title="8.ref"></a>8.ref</h3><blockquote><p>这一列显示了哪些字段或者常量被用来和key配合从表中查询记录出来。</p></blockquote><h3 id="9-rows"><a href="#9-rows" class="headerlink" title="9.rows"></a>9.rows</h3><blockquote><p>这一列显示了<strong>估计</strong>要找到所需的行而要读取的行数，这个值是个估计值，原则上值越小越好。</p></blockquote><h3 id="10-extra"><a href="#10-extra" class="headerlink" title="10.extra"></a>10.extra</h3><blockquote><p>其他的信息</p></blockquote><p>常见的取值如下：</p><ul><li><strong>Using index</strong>：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。</li><li>Using Where：在存储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。</li><li>Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。</li><li>Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。</li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><p>事务简单来说：<strong>一个Session中所进行所有的操作，要么同时成功，要么同时失败</strong></p><p><strong>ACID — 数据库事务正确执行的四个基本要素</strong></p><ul><li>原子性：事务的所有操作要么全部执行，要么由于出错而被整体取消</li><li>一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性</li><li>隔离性：操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li><li>持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>数据库定义了4个隔离级别：</p><ol><li>Read UnCommitted(读未提交)：最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果</li><li>Read Committed(读提交)：大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果</li><li>Repeatable Read(重复读)：mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。InnoDB存储引擎默认支持该级别的事务隔离，但值得特别注意的是，InnoDB在该隔离级别下，使用Next-Key Lock算法，可以额外避免幻读这种情况</li><li>Serializable(序列化)最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。大部分人质疑该隔离级别存在一定的性能问题，但是根据某大牛指出，某些情况下 Serializable 性能更优<br>上述四中隔离级别可以逐个解决读脏、不可重复读、幻读这几类问题。</li></ol><p>产生的问题</p><p>丢失更新</p><p><img src="https://img2.jimu98.cn/blog/20200802161628.png" srcset="/img/loading.gif" alt="image-20200802161627911"></p><h1 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h1><p>在mysql中的锁<strong>看起来</strong>是很复杂的，因为有<strong>一大堆的东西和名词</strong>：排它锁，共享锁，表锁，页锁，间隙锁，意向排它锁，意向共享锁，行锁，读锁，写锁，乐观锁，悲观锁，死锁。这些名词有的博客又直接写锁的英文的简写—&gt;X锁，S锁，IS锁，IX锁，MMVC…</p><p>锁的相关知识又跟存储引擎，索引，事务的隔离级别都是关联的….</p><p><strong>定心丸</strong>：即使我们不会这些锁知识，我们的程序在<strong>一般情况下</strong>还是可以跑得好好的。因为这些锁数据库<strong>隐式</strong>帮我们加了</p><ul><li>对于 <code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li><li><strong>MyISAM</strong>在执行查询语句 <code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（ <code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li></ul><p>只会在某些特定的场景下才需要<strong>手动</strong>加锁，学习数据库锁知识就是为了:</p><ul><li>能让我们在特定的场景下派得上用场</li><li>更好<strong>把控自己写的程序</strong></li><li>在跟别人聊数据库技术的时候可以搭上几句话</li><li><strong>构建自己的知识库体系</strong>！在面试的时候不虚</li></ul><p>在数据库中，使用锁来管理对共享资源的并发访问，维护数据一致性。在数据库中有两类锁，分别是 latch 和 lock 。latch 一般称为闩锁(轻量级锁)，因为其要求锁定的时间必须非常短，若持续的时间长，则其性能将会非常差。在 InnoDB 存储引擎中又分 mutex(互斥量) 和 rwlock(读写锁) 。其目的是保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制。lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般 lock 的对象仅在事务 commit 或 rollback 后进行释放(不同事务隔离级别释放的时间可能不同)。lock 有死锁机制。二者对比如下：</p><table><thead><tr><th>名称</th><th>lock</th><th>latch</th></tr></thead><tbody><tr><td>对象</td><td>事务</td><td>线程</td></tr><tr><td>保护</td><td>数据库内容</td><td>内存资源结构</td></tr><tr><td>持续时间</td><td>整个事务过程</td><td>临界资源</td></tr><tr><td>模式</td><td>行锁、表锁、意向锁</td><td>读写锁、互斥量</td></tr><tr><td>死锁</td><td>通过waits-for graph、time out等机制进行死锁检查与处理</td><td>无死锁检查与处理机制</td></tr><tr><td>存在于</td><td>Lock Manager的哈希表中</td><td>每个数据结构的对象中</td></tr></tbody></table><h2 id="表锁-行锁-页锁"><a href="#表锁-行锁-页锁" class="headerlink" title="表锁 行锁 页锁"></a>表锁 行锁 页锁</h2><ul><li>表级锁：开销小，加锁快；不会出现死锁(因为MyISAM会一次性获得SQL所需的全部锁)；锁定粒度大，发生锁冲突的概率最高,并发度最低</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</li><li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</p><h2 id="Lock锁的类型"><a href="#Lock锁的类型" class="headerlink" title="Lock锁的类型"></a>Lock锁的类型</h2><p>数据库中有多重Lock，分别是：</p><ul><li>共享锁-S</li><li>排他锁-X</li><li>意向排他锁-IX</li><li>意向共享锁-IS</li></ul><p>InnoDB存储引擎支持多粒度锁定，这种锁允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，InnoDB支持一种额外的上锁方式，称为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。锁兼容性对比：</p><table><thead><tr><th>-</th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><h2 id="行锁的实现方法分类"><a href="#行锁的实现方法分类" class="headerlink" title="行锁的实现方法分类"></a>行锁的实现方法分类</h2><p>行锁有多重算法控制，这里仅对以下三种做件简要描述：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身</li><li>Next-Key Lock：Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身，可解决幻读问题</li></ul><h2 id="数据库中锁升级的理解"><a href="#数据库中锁升级的理解" class="headerlink" title="数据库中锁升级的理解"></a>数据库中锁升级的理解</h2><p>锁升级是指将当前锁的粒度提升。例如，数据库可以将一个表的 1000 个行锁升级为一个页锁，或者将页锁升级为表锁。在适当的时候将锁升级为更粗粒度的锁，这样可以保护锁资源，防止系统使用太多的内存来维护锁，在一定程度上提高了效率。</p><h2 id="死锁以及解决死锁的理解"><a href="#死锁以及解决死锁的理解" class="headerlink" title="死锁以及解决死锁的理解"></a>死锁以及解决死锁的理解</h2><p>事务 A 与事务 B 由于某种调度顺序，可能会互相等待对方释放资源的锁，进而造成死锁忙的忙等。在数据库中，解决死锁采用两种方式，预防死锁和解决死锁。发生死锁的四个条件：</p><ul><li>互斥</li><li>请求与保持</li><li>不剥夺</li><li>循环等待</li></ul><p>预防死锁的方式如下：</p><ul><li>一次封锁法：任务事务必须一次同时申请所有加锁请求，若不能同时加锁成功，则全部不加锁，并处于等待状态；若全部加锁成功，则可继续执行，在执行过程中不能对任何数据申请加锁</li><li>顺序封锁法：预先对所有数据对象规定一个顺序，任何一个事务要对几个数据对象进行封锁时，必须按照此规定顺序进行，若有一个对象封锁未成功，只能等待之，不得先封锁后面的数据对象</li></ul><p>解决死锁的方式如下：</p><ul><li>超时法</li><li>等待图法</li></ul><p>银行家算法：当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br>乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。乐观锁有可能导致类似循环等待的死锁状态，解决方案是把事务中的语句执行顺序进行调整。</p><h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。</p><p>当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。</p><h3 id="MVCC的实现机制"><a href="#MVCC的实现机制" class="headerlink" title="MVCC的实现机制"></a>MVCC的实现机制</h3><p>InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号。</p><p>　　在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p><h3 id="MVCC下的CRUD"><a href="#MVCC下的CRUD" class="headerlink" title="MVCC下的CRUD"></a>MVCC下的CRUD</h3><p><strong>SELECT：</strong><br>　　当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：<br>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。<br>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</p><p><strong>INSERT：</strong></p><p>　　InnoDB为这个新行记录当前的系统版本号。<br><strong>DELETE：</strong></p><p>　　InnoDB将当前的系统版本号设置为这一行的删除ID。<br><strong>UPDATE：</strong></p><p>　　InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p><p>　　这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。<br>　　MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><h2 id="数据库读写分离的理解"><a href="#数据库读写分离的理解" class="headerlink" title="数据库读写分离的理解"></a>数据库读写分离的理解</h2><p>读写分离的目的是为了提高数据库服务的性能，从而支持更大规模的并发访问。读写分离采用数据冗余的方式，每台从机保存了完整的业务数据。结构上采用一主多从的结构，主机负责处理写操作，从机负责处理读操作。数据同步由主机执行。读写分离常用代理方式实现，代理服务器接收应用程序传来的读写请求，然后决定转发到哪个具体的服务器进行处理。读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度上缓解了锁的争用</li><li>从服务器可以使用MyISAM，从而提供更高性能的查询并节约开销</li><li>增加冗余性的同时，可提高可用性</li></ul><h2 id="读写分离适用的场景"><a href="#读写分离适用的场景" class="headerlink" title="读写分离适用的场景"></a>读写分离适用的场景</h2><ul><li>并发访问量大，单机已经无法满足并发请求</li><li>读操作远远多于写操作</li><li>对数据实时性的要求不严苛</li></ul><h2 id="读写分离存在的瓶颈以及相应的解决方案"><a href="#读写分离存在的瓶颈以及相应的解决方案" class="headerlink" title="读写分离存在的瓶颈以及相应的解决方案"></a>读写分离存在的瓶颈以及相应的解决方案</h2><p>采用读写分离时，最大的问题就是存在主从复制延迟。数据写入主服务器后，由于主服务器数据同步到从服务器存在延迟，导致从机读取不到最新的数据。</p><p><img src="https://img2.jimu98.cn/blog/20200802180726.png" srcset="/img/loading.gif" alt="image-20200802180726548"></p><h1 id="MySql的架构与集群"><a href="#MySql的架构与集群" class="headerlink" title="MySql的架构与集群"></a>MySql的架构与集群</h1><h1 id="MySql场景"><a href="#MySql场景" class="headerlink" title="MySql场景"></a>MySql场景</h1><h2 id="一条SQL语句在MySQL中的执行过程-查询在内部如何流转"><a href="#一条SQL语句在MySQL中的执行过程-查询在内部如何流转" class="headerlink" title="一条SQL语句在MySQL中的执行过程(查询在内部如何流转)"></a>一条SQL语句在MySQL中的执行过程(查询在内部如何流转)</h2><p>当执行一条查询的SQl的时候大概发生了一下的步骤：</p><ol><li>连接器： 身份认证和权限相关(登录 MySQL 的时候)</li><li>查询缓存: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）</li><li>分析器: 没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句要干嘛，再检查你的SQL语句语法是否正确</li><li>优化器：按照 MySQL 认为最优的方案去执行</li><li>执行器: 执行语句，然后从存储引擎返回数据</li></ol><p>Mysql的执行的流程图如下图所示：</p><p><img src="https://img2.jimu98.cn/blog/20200801175847.png" srcset="/img/loading.gif" alt="image-20200801175847040"></p><h2 id="一条SQL语句执行地很慢的原因"><a href="#一条SQL语句执行地很慢的原因" class="headerlink" title="一条SQL语句执行地很慢的原因"></a>一条SQL语句执行地很慢的原因</h2><h4 id="偶尔很慢的情况"><a href="#偶尔很慢的情况" class="headerlink" title="偶尔很慢的情况"></a>偶尔很慢的情况</h4><ul><li>数据库在刷新脏页：数据库在插入、更新一条数据时，并不会马上持久化到磁盘中，而是将记录写入redolog 中，等到空闲的时候，再通过 redolog 里的日志将最新数据同步到磁盘中。当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为脏页。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为干净页。如果 redolog 写满了，就必须暂停执行其他操作，将所有数据同步到磁盘后再继续执行，导致 SQL 语句执行地很慢</li><li>无法拿到锁</li></ul><h4 id="一直很慢的情况"><a href="#一直很慢的情况" class="headerlink" title="一直很慢的情况"></a>一直很慢的情况</h4><ul><li>没使用索引：待搜索的字段没有索引，执行全表扫描；或字段有索引，但是没有用到索引，例如不满足最左前缀原则；对字段使用函数，导致无法使用索引</li><li>辅助索引导致的聚簇索引二次搜索</li></ul><h2 id="MySQL删除一张表的方式与区别"><a href="#MySQL删除一张表的方式与区别" class="headerlink" title="MySQL删除一张表的方式与区别"></a>MySQL删除一张表的方式与区别</h2><p>用法：<br>1、当你不再需要该表时， 用 drop;</p><p>2、当你仍要保留该表，但要删除所有记录时， 用 truncate;</p><p>3、当你要删除部分记录或者有可能会后悔的话， 用 delete。</p><p>删除程度可从强到弱如下排列：<br>\1. drop table tb;</p><p>  drop 是直接将表格删除，无法找回。例如删除 user 表：</p><p>drop table user;<br>\2. truncate （table） tb;</p><p>  truncate 是删除表中所有数据，但不能与where一起使用；</p><p>TRUNCATE TABLE user;<br>\3. delete from tb (where);</p><p>  delete 也是删除表中数据，但可以与where连用，删除特定行；</p><p>– 删除表中所有数据<br>delete from user;<br>– 删除指定行<br>delete from user where username =’Tom’;</p><p>truncate 和 delete 的区别：<br>\1. 事物</p><p>truncate删除后不记录mysql日志，因此不可以rollback，更不可以恢复数据；而 delete 是可以 rollback ；</p><p>原因：truncate 相当于保留原mysql表的结果，重新创建了这个表，所有的状态都相当于新的，而delete的效果相当于一行行删除，所以可以rollback;</p><p>\2. 效果</p><p>效率上 truncate 比 delete快，而且 truncate 删除后将重建索引（新插入数据后id从0开始记起），而 delete不会删除索引 （新插入的数据将在删除数据的索引后继续增加）</p><p>\3. truncate 不会触发任何 DELETE触发器；</p><p>\4. 返回值</p><p>delete 操作后返回删除的记录数，而 truncate 返回的是0或者-1（成功则返回0，失败返回-1）；</p><p>delete 与 delete from 区别：<br>如果只针对一张表进行删除，则效果一样；如果需要联合其他表，则需要使用from ：</p><p>delete tb1 from tb1 m where id in (select id from tb2)</p><h1 id="Mysql日志"><a href="#Mysql日志" class="headerlink" title="Mysql日志"></a>Mysql日志</h1><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。</p><p>1.redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</p><p>2.undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</p><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>undo日志用于存放数据修改被修改前的值，假设修改 tba 表中 id=2的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p><p>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型，一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。</p><p>MySQL跟undo有关的参数设置有这些：</p><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> show global variables like <span class="hljs-string">'%undo%'</span>;</span>+--------------------------+------------+| Variable_name            | Value      |+--------------------------+------------+| innodb_max_undo_log_size | 1073741824 || innodb_undo_directory    | ./         || innodb_undo_log_truncate | OFF        || innodb_undo_logs         | 128        || innodb_undo_tablespaces  | 3          |+--------------------------+------------+<span class="hljs-meta">mysql&gt;</span><span class="bash"> show global variables like <span class="hljs-string">'%truncate%'</span>;</span>+--------------------------------------+-------+| Variable_name                        | Value |+--------------------------------------+-------+| innodb_purge_rseg_truncate_frequency | 128   || innodb_undo_log_truncate             | OFF   |+--------------------------------------+-------+</code></pre><ul><li><p><strong>innodb_max_undo_log_size</strong></p><p>控制最大undo tablespace文件的大小，当启动了innodb_undo_log_truncate 时，undo tablespace 超过innodb_max_undo_log_size 阀值时才会去尝试truncate。该值默认大小为1G，truncate后的大小默认为10M。</p></li><li><p><strong>innodb_undo_tablespaces</strong> </p><p>设置undo独立表空间个数，范围为0-128， 默认为0，0表示表示不开启独立undo表空间 且 undo日志存储在ibdata文件中。该参数只能在最开始初始化MySQL实例的时候指定，如果实例已创建，这个参数是不能变动的，如果在数据库配置文 件 .cnf 中指定innodb_undo_tablespaces 的个数大于实例创建时的指定个数，则会启动失败，提示该参数设置有误。</p></li></ul><p><img src="https://img2.jimu98.cn/blog/20200805164427.png" srcset="/img/loading.gif" alt="image-20200805164427671"></p><p>  如果设置了该参数为n（n&gt;0），那么就会在undo目录下创建n个undo文件（undo001，undo002 …… undo n），每个文件默认大小为10M.</p><p><img src="https://img2.jimu98.cn/blog/20200805164455.png" srcset="/img/loading.gif" alt="image-20200805164455318"></p><p><strong>什么时候需要来设置这个参数呢？</strong></p><p>  当DB写压力较大时，可以设置独立UNDO表空间，把UNDO LOG从ibdata文件中分离开来，指定 innodb_undo_directory目录存放，可以制定到高速磁盘上，加快UNDO LOG 的读写性能。</p><ul><li><p><strong>innodb_undo_log_truncate</strong></p><p>InnoDB的purge线程，根据innodb_undo_log_truncate设置开启或关闭、innodb_max_undo_log_size的参数值，以及truncate的频率来进行空间回收和 undo file 的重新初始化。</p></li></ul><p><strong>该参数生效的前提是，已设置独立表空间且独立表空间个数大于等于2个。</strong></p><p>  purge线程在truncate undo log file的过程中，需要检查该文件上是否还有活动事务，如果没有，需要把该undo log file标记为不可分配，这个时候，undo log 都会记录到其他文件上，所以至少需要2个独立表空间文件，才能进行truncate 操作，标注不可分配后，会创建一个独立的文件undo_<space_id><em>trunc.log，记录现在正在truncate 某个undo log文件，然后开始初始化undo log file到10M，操作结束后，删除表示truncate动作的 undo</em><space_id>_trunc.log 文件，这个文件保证了即使在truncate过程中发生了故障重启数据库服务，重启后，服务发现这个文件，也会继续完成truncate操作，删除文件结束后，标识该undo log file可分配。</p><ul><li><p><strong>innodb_purge_rseg_truncate_frequency</strong></p><p>用于控制purge回滚段的频度，默认为128。假设设置为n，则说明，当Innodb Purge操作的协调线程 purge事务128次时，就会触发一次History purge，检查当前的undo log 表空间状态是否会触发truncate。</p></li><li><p><strong>innodb_max_undo_log_size</strong></p></li></ul><h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>1.定义：</p><p>redo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。</p><p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。<strong>先写日志，再写磁盘</strong>，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p><p>2.记录方式</p><p>InnoDB 的 redo log 大小是固定的，采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。如下图：</p><p><img src="https://img2.jimu98.cn/blog/20200805165535.png" srcset="/img/loading.gif" alt="image-20200805165535360"></p><p>write pos 是当前记录的位置，一边写以便后移，写到3号文件末尾就回到0号文件开头。check point是当前要擦除的位置，也是往后推移并循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和check point 之间的是粉板上还空着的部分（write pos到3号文件末尾再加上0号文件开头到check point的部分），可以用来记录新的操作。如果write pos追上check point，表示粉板满了，这个时候不能再执行新的更新，得停下来先擦掉一些记录，把check point推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><p>要理解crash-safe这个概念，可以想想前面赊账记录的例子。只要赊账记录记在了粉板上或者写在了账本上，之后即使掌柜忘记了，依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h2><p>1.定义</p><p>binlog 是 MySQL 的逻辑日志，也叫二进制日志、归档日志，由 MySQL Server 来记录。</p><p>用于记录用户对数据库操作的SQL语句（除了查询语句）信息，以二进制的形式保存在磁盘中。</p><p>2.记录方式</p><p>binlog 通过追加的方式写入的，可通过配置参数 max_binlog_size 设置每个 binlog 文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。</p><p>3.格式 </p><p>binlog 日志有三种格式，分别为 STATMENT、ROW 和 MIXED。</p><table><thead><tr><th></th><th>STATMENT</th><th>ROW</th></tr></thead><tbody><tr><td>说明</td><td>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。是bin log的默认格式。</td><td>基于行的复制(row-based replication, RBR)：不记录每一条SQL语句的上下文信息，仅保存哪条记录被修改。</td></tr><tr><td>优点</td><td>不需要记录每一条SQL语句与每行的数据变化，减少了bin log的日志量，节约了磁盘IO，提高性能。</td><td>会非常清楚的记录下每一行数据修改的细节，不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</td></tr><tr><td>缺点</td><td>在某些情况下会导致master-slave中的数据不一致，如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题。</td><td>会产生大量的日志，尤其是alter table的时候会让日志暴涨。</td></tr></tbody></table><p>MIXED模式是基于 STATMENT 和 ROW 两种模式的混合复制(mixed-based replication, MBR)，一般的复制使用STATEMENT模式保存 binlog，对于 STATEMENT 模式无法复制的操作使用ROW模式保存 binlog，MySQL 会根据执行的 SQL 语句选择日志保存方式。</p><h3 id="redo-log和二进制日志的区别"><a href="#redo-log和二进制日志的区别" class="headerlink" title="redo log和二进制日志的区别"></a>redo log和二进制日志的区别</h3><blockquote><p>物理日志：redo log</p></blockquote><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他就可以把顾客名和账目写在板上。但是如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ol><li>直接把账本翻出来，把这次赊的账加上去或者扣除掉。</li><li>先在粉板上记下这次账，等打烊以后再把账本翻出来核算。</li></ol><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在太麻烦了。首先，得找到这个人的赊账总额那条记录。找到之后再拿出算盘计算，最后再将结果写回到账本上。相比之下，还是先在粉板上记一下方便。</p><blockquote><p>逻辑日志：binlog</p></blockquote><p>上一篇文章说过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面聊到的粉板redo log 是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>binlog有两种模式，statement模式记录的是SQL语句，row模式记录的是行的内容，记录两条更新前的行内容与更新后的行内容。</p><p>有两份日志的原因是最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另一套日志系统也就是说redo log 来实现crash-safe能力。</p><ol><li>这两种日志有以下三点不同：<ol><li>redo log 是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这行的c字段加1“。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol></li></ol><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>当执行一条 SQL 更新语句时，过程如下：</p><p><img src="https://img2.jimu98.cn/blog/20200805170731.png" srcset="/img/loading.gif" alt="image-20200805170731137"></p><p>可以看到，在“两阶段提交”阶段，将 redo log 的写入分成了两步：prepare 和 commit。在 redo log 状态为 prepare 时记录 binlog 可以保证两个日志的记录一致。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】Git常用操作</title>
    <link href="/posts/12822/"/>
    <url>/posts/12822/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】Git常用操作"><a href="#【java总结】Git常用操作" class="headerlink" title="【java总结】Git常用操作"></a>【java总结】Git常用操作</h1><h2 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h2><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>Git 与 SVN 区别点：</p><ul><li><strong>1、Git 是分布式的，SVN 不是</strong>：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li><li><strong>2、Git 把内容按元数据方式存储，而 SVN 是按文件：</strong>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li><li><strong>3、Git 分支和 SVN 的分支不同：</strong>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li><li><strong>4、Git 没有一个全局的版本号，而 SVN 有：</strong>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li><li><strong>5、Git 的内容完整性要优于 SVN：</strong>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ul><p><img src="https://img2.jimu98.cn/blog/20200801000439.png" srcset="/img/loading.gif" alt="image-20200801000439354"></p><h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p>git工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们先来理解下Git 工作区、暂存区和版本库概念</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://img2.jimu98.cn/blog/20200801001527.png" srcset="/img/loading.gif" alt="image-20200801001527806"></p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><h4 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">"jimu98"</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global user.email z591593455@qq.com</span></code></pre><h4 id="设置文本编辑器"><a href="#设置文本编辑器" class="headerlink" title="设置文本编辑器"></a>设置文本编辑器</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor emacs</span></code></pre><h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --list</span><span class="hljs-meta">$</span><span class="bash"> git config user.name</span></code></pre><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h4 id="本地新建"><a href="#本地新建" class="headerlink" title="本地新建"></a>本地新建</h4><p>使用 Git 来对现有的项目进行管理，进入该项目目录然后输入：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span></code></pre><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。<br>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add *.c   <span class="hljs-comment">#添加所有以 .c 结尾的</span></span><span class="hljs-meta">$</span><span class="bash"> git add LICENSE   <span class="hljs-comment">#添加README文件</span></span><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">'初始化项目版本'</span></span></code></pre><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>克隆仓库的命令格式是 git clone <repo> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2</span></code></pre><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span></code></pre><h2 id="Git文件的声明周期"><a href="#Git文件的声明周期" class="headerlink" title="Git文件的声明周期"></a>Git文件的声明周期</h2><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。<br>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p><p><img src="https://img2.jimu98.cn/blog/20200801113456.png" srcset="/img/loading.gif" alt="image-20200801113455974"></p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><h2 id="Git提交-跟踪"><a href="#Git提交-跟踪" class="headerlink" title="Git提交/跟踪/"></a>Git提交/跟踪/</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>各种语言的规范请参考:<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要查看哪些文件处于什么状态，可以用 git status 命令。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status <span class="hljs-comment">#-s 以精简的方式显示文件状态。</span></span></code></pre><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add README</span></code></pre><h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span></code></pre><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git diff</span></code></pre><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit</span></code></pre><p>可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"info"</span></span></code></pre><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">'added new benchmarks'</span></span></code></pre><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm PROJECTS.md</span></code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。<br>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm --cached README</span></code></pre><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git mv file_from file_to</span></code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -p -2 // 查看前两次提交的内容差异</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span>    // 查看每次提交的简略统计信息</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --since=2.weeks   // 列出所有最近两周内的提交</span></code></pre><p>一个常用的选项是 –pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同。</p><pre><code class="hljs shell">-p 按补丁格式显示每个更新之间的差异。--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史。--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。--grep 仅显示含指定关键字的提交-S 仅显示添加或移除了某个关键字的提交</code></pre><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">'initial commit'</span></span><span class="hljs-meta">$</span><span class="bash"> git add forgotten_file</span><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span></code></pre><p>–amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span></code></pre><h4 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h4><p>checkout 命令方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span></code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote</span><span class="hljs-meta">$</span><span class="bash"> git remote -v // 选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</span></code></pre><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 git remote add 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span><span class="hljs-meta">$</span><span class="bash"> git remote -v</span></code></pre><h4 id="从远程仓库抓取"><a href="#从远程仓库抓取" class="headerlink" title="从远程仓库抓取"></a>从远程仓库抓取</h4><p>从远程仓库中获得数据，可以执行：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git fetch [remote-name]</span></code></pre><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><h4 id="向远程仓库推送"><a href="#向远程仓库推送" class="headerlink" title="向远程仓库推送"></a>向远程仓库推送</h4><p>当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span></code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p><h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span></code></pre><h4 id="远程仓库重命名"><a href="#远程仓库重命名" class="headerlink" title="远程仓库重命名"></a>远程仓库重命名</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rename pb paul // pb-&gt;paul</span></code></pre><h4 id="远程仓库移除"><a href="#远程仓库移除" class="headerlink" title="远程仓库移除"></a>远程仓库移除</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rm paul</span></code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code class="hljs shell">git branch &lt;分支名&gt;git branch -v 查看分支</code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code class="hljs shell">git checkout &lt;分支名&gt;git checkout -b &lt;分支名&gt;  一步创建+切换</code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre><code class="hljs shell">先切换到主干  git checkout mastergit merge &lt;分支名&gt;</code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre><code class="hljs shell">先切换到主干  git checkout mastergit branch —D &lt;分支名&gt;</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><span class="hljs-meta">$</span><span class="bash"> git tag -l <span class="hljs-string">'v1.8.5*'</span></span></code></pre><h4 id="轻量标签与附注标签"><a href="#轻量标签与附注标签" class="headerlink" title="轻量标签与附注标签"></a>轻量标签与附注标签</h4><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。<br>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="hljs-string">'my version 1.4'</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】面试题整理</title>
    <link href="/posts/32991/"/>
    <url>/posts/32991/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】面试题整理"><a href="#【java总结】面试题整理" class="headerlink" title="【java总结】面试题整理"></a>【java总结】面试题整理</h1><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="详解JVM内存模型"><a href="#详解JVM内存模型" class="headerlink" title="详解JVM内存模型"></a>详解JVM内存模型</h2><blockquote><p>线程共享，线程独占</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200816210021.png" srcset="/img/loading.gif" alt="image-20200816210021395"></p><p>栈管运行，堆管存储</p><h3 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h3><blockquote><p>它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。</p><p>根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。</p><p>当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</p></blockquote><h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><blockquote><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p></blockquote><h3 id="虚拟机栈："><a href="#虚拟机栈：" class="headerlink" title="虚拟机栈："></a>虚拟机栈：</h3><blockquote><p>每个方法被执行的时候都会创建一个栈帧用于存储<strong>局部变量表</strong>，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。</p><p>Java虚拟机栈可能出现两种类型的异常：</p><ol><li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li><li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li></ol></blockquote><h3 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h3><blockquote><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。</p></blockquote><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><blockquote><p>又叫PC寄存器</p><p>他是一块很小的区域，几乎可以忽略不计，存储指向下一条指令的地址</p><p>分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成</p></blockquote><h2 id="使用PC寄存器记录当前线程的执行地址有什么用？"><a href="#使用PC寄存器记录当前线程的执行地址有什么用？" class="headerlink" title="使用PC寄存器记录当前线程的执行地址有什么用？"></a>使用PC寄存器记录当前线程的执行地址有什么用？</h2><blockquote><p>因为CPU需要不停的起换各个线程，这时候切换回来以后，就得知道接从哪哪开始继续执行</p></blockquote><h2 id="类加载的过程？"><a href="#类加载的过程？" class="headerlink" title="类加载的过程？"></a>类加载的过程？</h2><p>class文件开头标识：CAFEBABE </p><p>类加载过程共有5个步骤：加载、验证、准备、解析、初始化。其中，验证、准备、解析称为连接。</p><p>所以一般也可以说类加载分为三个阶段：加载阶段，链接阶段，初始化阶段</p><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><blockquote><p>通过一个类的全限定明来获取定义此类的二进制字节流。从Jar、War，数据库，甚至从网络获取</p><p>将这个字节流所代表的静态存储结构转化为方法区运行时数据结构。</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></blockquote><h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><blockquote><p>文件格式验证<br>元数据验证<br>字节码验证<br>符号引用验证</p></blockquote><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><blockquote><p>为类的静态变量分配内存并设置初始值。</p></blockquote><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><blockquote><p>Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p><strong>符号引用（Symbolic References）</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用目标并不一定已经加载到内存中。</p><p><strong>直接引用（Direct References）</strong>：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有直接引用，那引用的目标必定已经在内存中存在。</p></blockquote><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><blockquote><p><strong>就是执行类构造器<clinit>()方法的过程。</strong>所谓<strong><clinit>()方法的过程</strong>就是用户在类中定义的常量值赋值、静态代码块执行过程。在<strong>准备阶段</strong>已经对常量值设置初始值，在这里就是对常量设置用户定义的值，比如在类中存在如下一行代码：</p></blockquote><p>ClassLoader只负责class文件的加载，至于能不能运行，则由Execution Engine（执行引擎）决定</p><p><a href="https://blog.csdn.net/u010425776/article/details/51254858" target="_blank" rel="noopener">其他类加载问题</a></p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><blockquote><p>Bootstrap Class Loader  启动类加载器</p><p>Extension Class Loader  拓展类加载器</p><p>System Class Loader  应用类加载器</p></blockquote><blockquote><p>自定义类加载器</p></blockquote><h2 id="双亲委派机制是什么"><a href="#双亲委派机制是什么" class="headerlink" title="双亲委派机制是什么?"></a>双亲委派机制是什么?</h2><blockquote><ol><li>首先会先查找当前ClassLoader是否加载过此类，有就返回；</li><li>如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；如果没有，就把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。</li><li>如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)。</li></ol></blockquote><h2 id="双亲委派机制可以被打破吗"><a href="#双亲委派机制可以被打破吗" class="headerlink" title="双亲委派机制可以被打破吗?"></a>双亲委派机制可以被打破吗?</h2><p>可以</p><blockquote><ol><li><p>自定义类加载器，重写loadClass方法;</p></li><li><p>使用线程上下文类加载器;</p></li></ol></blockquote><h2 id="TOMCAT加载顺序："><a href="#TOMCAT加载顺序：" class="headerlink" title="TOMCAT加载顺序："></a>TOMCAT加载顺序：</h2><ol><li>Bootstrap</li><li>WebappX</li><li>System</li><li>Common</li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><blockquote><p>顶层的bootstrap加载器查找这个类，由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染</p></blockquote><h2 id="GC分为几种"><a href="#GC分为几种" class="headerlink" title="GC分为几种"></a>GC分为几种</h2><ul><li>Minor GC</li><li>Full GC</li><li>Major GC 是清理永久代 通常至少经历过一次Minor GC</li></ul><h2 id="怎么判定垃圾"><a href="#怎么判定垃圾" class="headerlink" title="怎么判定垃圾"></a>怎么判定垃圾</h2><blockquote><p>引用计数法<br>可达性分析</p></blockquote><h2 id="垃圾清理机制"><a href="#垃圾清理机制" class="headerlink" title="垃圾清理机制"></a>垃圾清理机制</h2><blockquote><p>标记–清除算法</p><p>标记-整理算法</p><p>复制算法</p><p>分代收集算法：新生代中，每次垃圾收集时都发现有大批对象死去，少量存活，选用复制算法；老年代中，对象存活率高、没有额外空间进行分配担保，使用“标记-清理”或者“标记-整理”。永久代满了就触发Full GC</p></blockquote><h2 id="有哪几种垃圾收集器？"><a href="#有哪几种垃圾收集器？" class="headerlink" title="有哪几种垃圾收集器？"></a>有哪几种垃圾收集器？</h2><p><img src="https://img2.jimu98.cn/blog/20200816213707.png" srcset="/img/loading.gif" alt="image-20200816213707240"></p><blockquote><p>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p><p>老年代收集器：Serial Old、Parallel Old、CMS；</p><p>整堆收集器：G1；</p></blockquote><p>客户端用哪个收集器好一点：Serial。可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</p><h2 id="GC发生在哪里？"><a href="#GC发生在哪里？" class="headerlink" title="GC发生在哪里？"></a>GC发生在哪里？</h2><blockquote><p>堆</p></blockquote><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="创建线程的几种方式？"><a href="#创建线程的几种方式？" class="headerlink" title="创建线程的几种方式？"></a>创建线程的几种方式？</h2><blockquote><p>一、继承Thread类的方式<br>二、实现Runnable接口的方式<br>三、带返回值的方式 Callable<br>四、线程池的方式<br>五、定时器方式<br>六、匿名内部类的方式<br>七、Spring实现多线程（Spring的异步任务）<br>八、lambda表达式方式（jdk1.8提供的lambda表达式进行并行计算）</p></blockquote><blockquote><p>其实每种方式的本质都是一样的，那就是创建Thread对象，只不过使用到的构造方法不同罢了。</p></blockquote><h2 id="线程池原理，参数？"><a href="#线程池原理，参数？" class="headerlink" title="线程池原理，参数？"></a>线程池原理，参数？</h2><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互<br> 而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时<br> 更应该考虑使用线程池</p><p><strong>线程池里的每个线程代码结束后并不会死亡</strong><br> 而是再次回到线程池中成为空闲状态，等待下一个对象再来使用</p><ul><li><p>底层有七个参数</p><ul><li><p>corePoolSize 线程池种的常驻核心线程数</p></li><li><p>maximumPoolSize 线程池种能够容纳最大线程数</p></li><li><p>keepAliveTime  多余的空闲线程的存活时间</p></li><li><p>unit keepAliveTime的单位</p></li><li><p>workQueue 任务队列</p></li><li><p>threadFactory 表示生成线程池中工作线程的线程工厂，</p></li><li><p>handler 拒绝策略，表示当队列满了，如何拒绝</p></li></ul></li></ul><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="SpringMVC执行流程图"><a href="#SpringMVC执行流程图" class="headerlink" title="SpringMVC执行流程图"></a>SpringMVC执行流程图</h2><p><img src="https://img2.jimu98.cn/blog/20200808165459.png" srcset="/img/loading.gif" alt="image-20200808165458277"></p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h3 id="如果遇到数据库字段和pojo不一致怎么办？"><a href="#如果遇到数据库字段和pojo不一致怎么办？" class="headerlink" title="如果遇到数据库字段和pojo不一致怎么办？"></a>如果遇到数据库字段和pojo不一致怎么办？</h3><blockquote><ul><li>1.sql语句写别名</li><li>2.开启驼峰命名映射规则</li><li>3.在Mapper映射文件使用resultMap指定规则</li></ul></blockquote><p><img src="https://api2.mubu.com/v3/document_image/b176477b-cbf2-4e51-9005-4436f82abf3b-1015484.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL扩展具体的实现方式？"><a href="#MySQL扩展具体的实现方式？" class="headerlink" title="MySQL扩展具体的实现方式？"></a>MySQL扩展具体的实现方式？</h2><blockquote><p>业务拆分</p><p>主从复制</p><p>数据库分库与分表</p></blockquote><h2 id="分库分表策略"><a href="#分库分表策略" class="headerlink" title="分库分表策略"></a>分库分表策略</h2><blockquote><p>水平分库：以<strong>字段</strong>为依据，按照一定策略（hash、range等），将一个<strong>库</strong>中的数据拆分到多个<strong>库</strong>中。每个<strong>库</strong>的<strong>结构</strong>都一样；</p><p>水平分表：以<strong>字段</strong>为依据，按照一定策略（hash、range等），将一个<strong>表</strong>中的数据拆分到多个<strong>表</strong>中。每个<strong>表</strong>的<strong>结构</strong>都一样；</p><p>垂直分库：以<strong>表</strong>为依据，按照业务归属不同，将不同的<strong>表</strong>拆分到不同的<strong>库</strong>中。每个<strong>库</strong>的<strong>结构</strong>都不一样；</p><p>垂直分表：以<strong>字段</strong>为依据，按照字段的活跃性，将<strong>表</strong>中字段拆到不同的<strong>表</strong>（主表和扩展表）中。</p></blockquote><h2 id="什么是回表"><a href="#什么是回表" class="headerlink" title="什么是回表?"></a>什么是回表?</h2><blockquote><p>什么是回表？</p><ul><li>简单来说就是数据库根据索引找到了指定的记录所在行后，还需要根据rowid再次到数据块里取数据的操作。</li><li>比如这样的执行计划，先索引扫描，再通过rowid去取索引中未能提供的数据，即为回表。</li><li>“回表”一般就是指执行计划里显示的“TABLE ACCESS BY INDEX ROWID”。</li><li>再例如，虽然只查询索引里的列，但是需要回表过滤掉其他行。</li></ul><p>怎么避免回表？</p><ul><li>将需要的字段放在索引中去。查询的时候就能避免回表。</li></ul><p>但是不要刻意去避免回表，那样代价太了。也不是将所有的字段都放在所有中。</p></blockquote><h2 id="建立索引的规则"><a href="#建立索引的规则" class="headerlink" title="建立索引的规则"></a>建立索引的规则</h2><blockquote><p>选择唯一性索引<br>为经常需要排序、分组和联合操作的字段建立索引<br>为常作为查询条件的字段建立索引<br>尽量使用数据量少的索引<br>尽量使用最左前缀匹配原则，非常重要的原则。<br>尽量选择区分度高的列作为索引(男/女)<br>索引列不能参与计算，保持列“干净”</p></blockquote><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><h2 id="布隆过滤器出错概率"><a href="#布隆过滤器出错概率" class="headerlink" title="布隆过滤器出错概率"></a>布隆过滤器出错概率</h2><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="服务注册发现原理"><a href="#服务注册发现原理" class="headerlink" title="服务注册发现原理"></a>服务注册发现原理</h2><blockquote><p>在服务注册与发现中，有一个注册中心，当服务器启动的时候，会把当前自已服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。</p><p>另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后在实现本地rpc调用远程。</p></blockquote><h2 id="微服务的优点有哪些？"><a href="#微服务的优点有哪些？" class="headerlink" title="微服务的优点有哪些？"></a>微服务的优点有哪些？</h2><blockquote><p>开发效率提高；</p><p>服务可以独立扩展</p><p>更好的容错性</p><p>可以与别的语言更方便的交互</p></blockquote><h2 id="微服务的缺点有哪些？"><a href="#微服务的缺点有哪些？" class="headerlink" title="微服务的缺点有哪些？"></a>微服务的缺点有哪些？</h2><blockquote><p>需要一个专门的运维人员，去测试各个服务。</p><p>借助网络传递数据影响传输</p><p>可能会引入分布式事务</p></blockquote><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="Time-wait"><a href="#Time-wait" class="headerlink" title="Time_wait"></a>Time_wait</h2><blockquote><p>主动断开的一方的TCP连接会在这个状态下保持2MSL（报文段的最大生存时间）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java SE</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java知识点】单例模式八种写法</title>
    <link href="/posts/13078/"/>
    <url>/posts/13078/</url>
    
    <content type="html"><![CDATA[<h1 id="【java知识点】单例模式八种写法"><a href="#【java知识点】单例模式八种写法" class="headerlink" title="【java知识点】单例模式八种写法"></a>【java知识点】单例模式八种写法</h1><blockquote><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p></blockquote><blockquote><p>单例模式一般分为懒汉式和饿汉式，同时还有线程安全和不安全的问题。所以记录一下几种写法</p></blockquote><h3 id="1、饿汉式（静态常量）√√"><a href="#1、饿汉式（静态常量）√√" class="headerlink" title="1、饿汉式（静态常量）√√"></a>1、饿汉式（静态常量）√√</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton1</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton1 INSTANCE = <span class="hljs-keyword">new</span> Singleton1();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton1</span><span class="hljs-params">()</span></span>&#123; &#125;&#125;</code></pre><blockquote><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p></blockquote><h3 id="2、饿汉式（静态代码块）√√√√√"><a href="#2、饿汉式（静态代码块）√√√√√" class="headerlink" title="2、饿汉式（静态代码块）√√√√√"></a>2、饿汉式（静态代码块）√√√√√</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton2 INSTANCE;    <span class="hljs-keyword">static</span>&#123;        INSTANCE =<span class="hljs-keyword">new</span> Singleton2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton2</span><span class="hljs-params">()</span></span>&#123; &#125;&#125;</code></pre><blockquote><p>用于复杂初始化，比如需要读取外部配置文件等</p></blockquote><h3 id="3、枚举-√√√√√"><a href="#3、枚举-√√√√√" class="headerlink" title="3、枚举  √√√√√"></a>3、枚举  √√√√√</h3><pre><code class="hljs java"><span class="hljs-keyword">enum</span> Singleton8 &#123;    INSTANCE;&#125;</code></pre><blockquote><p>JDK1.5以后有一种更简洁的单例模式。</p></blockquote><h3 id="4、懒汉式-线程不安全-×"><a href="#4、懒汉式-线程不安全-×" class="headerlink" title="4、懒汉式(线程不安全) ×"></a>4、懒汉式(线程不安全) ×</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton3</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton3 singleton;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton3</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;            singleton = <span class="hljs-keyword">new</span> Singleton3();        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h3 id="7、静态内部类-√√√√√"><a href="#7、静态内部类-√√√√√" class="headerlink" title="7、静态内部类 √√√√√"></a>7、静态内部类 √√√√√</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton7</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton7 INSTANCE = <span class="hljs-keyword">new</span> Singleton7();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton7 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;    &#125;&#125;</code></pre><blockquote><p>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>优点：避免了线程不安全，延迟加载，效率高。</p></blockquote><blockquote><p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p></blockquote><h3 id="6、懒汉式-线程安全，同步方法-√"><a href="#6、懒汉式-线程安全，同步方法-√" class="headerlink" title="6、懒汉式(线程安全，同步方法) √"></a>6、懒汉式(线程安全，同步方法) √</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton4</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton4 singleton;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton4</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;            singleton = <span class="hljs-keyword">new</span> Singleton4();        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><blockquote><p>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p></blockquote><h3 id="7、懒汉式-线程安全，同步代码块-×"><a href="#7、懒汉式-线程安全，同步代码块-×" class="headerlink" title="7、懒汉式(线程安全，同步代码块) ×"></a>7、懒汉式(线程安全，同步代码块) ×</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton5</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton5 singleton;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton5</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton5 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton5<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                singleton = <span class="hljs-keyword">new</span> Singleton5();            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><blockquote><p>但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p></blockquote><h3 id="8、双重检查-√√√√√"><a href="#8、双重检查-√√√√√" class="headerlink" title="8、双重检查 √√√√√"></a>8、双重检查 √√√√√</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton6</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton6 singleton;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton6</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton6 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton6<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;                    singleton = <span class="hljs-keyword">new</span> Singleton6();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><blockquote><p>进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p><p>优点：线程安全；延迟加载；效率较高。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java SE</tag>
      
      <tag>基础篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO友链随机排序</title>
    <link href="/posts/64778/"/>
    <url>/posts/64778/</url>
    
    <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><blockquote><p>最近做博客做的很有乐趣，到处找人换友链</p><p>然后我就发现排在前面和排在后面点击效果比较好</p><p>这对排在中间的朋友们极其不公平。</p><p>我就想搞个随机友链</p></blockquote><h1 id="找出目录"><a href="#找出目录" class="headerlink" title="找出目录"></a>找出目录</h1><blockquote><p>首先我们思考一下hexo原理，他是把你的配置文件还有静态资源通过各种类似脚本的方式生成静态页面</p><p>那么就要去找到友链所对应的脚本或者资源</p></blockquote><p>首先打开主题文件夹，友链无非就那几个关键字 link，links，friend，反正看到类似的就可以</p><p>我的是在 <code>layout/links.ejs文件下面</code></p><h2 id="原来的代码"><a href="#原来的代码" class="headerlink" title="原来的代码"></a>原来的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alpha%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><p>看到这几个for循环，感觉亲切了许多是吧。</p><p>theme.links.items应该就是存放友链的数组了</p><blockquote><p>继续思考</p></blockquote><blockquote><p>hexo是生成静态页面的，我们打开看一下生成的public文件夹，很明显，每一条数据都直接固定写成了html</p><p>那说明这里只是拼接html的脚本</p><p>我有两种想法</p><p>通过js操作dom来修改html数据（太过于繁琐，放弃）</p><p>直接在生成前，把数组打乱（so easy，就他了）</p><p>大家看上面的&lt;%  %&gt;了吗  很明显，这里是动态获取数据的地方</p><p>那我们就开始写了</p><p>打乱数组：</p><p>其实我们可以使用js的sort，然后给他一个随机对比</p><p>这样</p><p>function randomsort(a, b) {<br> return Math.random()&gt;.5 ? -1 : 1;<br>}<br>theme.links.items.sort(randomsort);</p><p>//这是一种最简单的方法，但是你可想一下  前面的在前面的概率比较大，后面的在后面的概率比较大，对不对</p><p>（比如先给你加友链的小伙伴，很大的改了可以在前面对不对）</p><p>//当然，我们还是的采用更公平的随机算法：随机洗牌算法</p><p>Array.prototype.shuffle = function() {<br>var input = this;<br>    for (var i = input.length-1; i &gt;=0; i–) {<br>        var randomIndex = Math.floor(Math.random()*(i+1));<br>        var itemAtIndex = input[randomIndex];<br>        input[randomIndex] = input[i];<br>        input[i] = itemAtIndex;<br>    }<br>    return input;<br>}<br>theme.links.items.shuffle();</p></blockquote><h2 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><blockquote><p>好像这个主题友链没带加评论，也没有自我介绍</p><p>那让想要添加我的小伙伴操作起来多么繁琐，找到代码  加上去</p></blockquote><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;本站友情链接顺序随机&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;div class&#x3D;&quot;content-tab-content  &quot; data-tab-index&#x3D;&quot;2&quot;&gt;名称：积木&lt;br&gt;网址：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&lt;&#x2F;a&gt;&lt;br&gt;头像：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&lt;&#x2F;a&gt;&lt;br&gt;描述：积木-互联网的一只小菜鸡。&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;row links&quot;&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;              &lt;div class&#x3D;&quot;comments&quot; id&#x3D;&quot;comments&quot;&gt;                &lt;% var type &#x3D; &#39;_partial&#x2F;comments&#x2F;&#39; + theme.post.comments.type %&gt;                &lt;%- partial(type) %&gt;              &lt;&#x2F;div&gt;</code></pre><blockquote><p>当然这种随机，每次更新文章从新上传的时候，他会随机生成。</p><p>但是有小伙伴需要刷新一次页面生成一次，</p><p>那这种想法很明显，html代码写死了</p><p>所以你要么写js代码，每次动态修改html</p><p>要么直接把友链数据写到js里面渲染</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>随机排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】Object的概念与区别</title>
    <link href="/posts/35360/"/>
    <url>/posts/35360/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】Object的概念与区别"><a href="#【项目笔记】Object的概念与区别" class="headerlink" title="【项目笔记】Object的概念与区别"></a>【项目笔记】Object的概念与区别</h1><blockquote><p>首先来一张图，简单看一下</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200727194511.png" srcset="/img/loading.gif" alt="image-20200727194312707"></p><blockquote><p>网上这类帖子特别乱，比如有解释VO、DTO区别的，还有什么DO，PO，TO区别的</p><p>有好处也有坏处吧，好处在于准确对比。坏处可能会更加迷糊</p><p>于是我自己把大佬们文章整理一下，如果哪里不对，大家一定要留言告诉我</p></blockquote><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>最常用实体类，基本和数据表一一对应，一个实体一张表。</p><h3 id="POJO（Plain-Ordinary-Java-Object）："><a href="#POJO（Plain-Ordinary-Java-Object）：" class="headerlink" title="POJO（Plain Ordinary Java Object）："></a>POJO（Plain Ordinary Java Object）：</h3><p>表示一个简单的Java对象,实际就是普通JavaBeans,是为了避免和EJB混淆所创造的简称，下面要说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。</p><blockquote><p>有部分人写代码经常用pojo来代替entity，至于哪个更规范，我也不知道，只是现在经常使用entity</p></blockquote><h3 id="PO（Persistent-Object）："><a href="#PO（Persistent-Object）：" class="headerlink" title="PO（Persistent Object）："></a>PO（Persistent Object）：</h3><p>持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><blockquote><p>人话：我们正常写得entity，一个实体就是一个PO</p></blockquote><h3 id="VO（View-Object）："><a href="#VO（View-Object）：" class="headerlink" title="VO（View Object）："></a>VO（View Object）：</h3><p>视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p><blockquote><p>用来承载前端交互数据，比如前端需要的数据来自三个数据库，那么我们就可以封装出一个vo实体，包含这三个表中某些字段。然后返回给前端</p></blockquote><h3 id="DO（Domain-Object）："><a href="#DO（Domain-Object）：" class="headerlink" title="DO（Domain Object）："></a>DO（Domain Object）：</h3><p>领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><blockquote><p>我查了很多的资料，基本别的很详细解释，而这个只有这一句话，甚至很多人都说可能不存在这个概念。我的理解他可能就像java中的抽象这个概念。</p><p>比如  人  可是我们项目中哪里需要传递这么一个抽象的类呢，比如我们可以传递一个po 人的信息，或者传递一个vo，人的行为和他的好基友们。所以这个可能只是停留在概念上面</p></blockquote><h3 id="BO（business-Object）："><a href="#BO（business-Object）：" class="headerlink" title="BO（business Object）："></a>BO（business Object）：</h3><p>业务对象，封装对象、复杂对象 ，里面可能包含多个类；</p><blockquote><p>BO 通常位于业务层，要区别于直接对外提供服务的服务层：</p></blockquote><h3 id="TO（Transfer-Objerct）："><a href="#TO（Transfer-Objerct）：" class="headerlink" title="TO（Transfer Objerct）："></a>TO（Transfer Objerct）：</h3><p>数据传输对象，不同应用程序之间传输的对象</p><blockquote><p>他和DTO作用相似，用于微服务间。</p></blockquote><h3 id="DTO（Data-Transfer-Object）："><a href="#DTO（Data-Transfer-Object）：" class="headerlink" title="DTO（Data Transfer Object）："></a>DTO（Data Transfer Object）：</h3><p>数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</p><blockquote><p>这个主要作用是在微服务与微服务之间相互调用时候传输的数据对象。</p></blockquote><h3 id="DAO（Data-Access-Object）"><a href="#DAO（Data-Access-Object）" class="headerlink" title="DAO（Data Access Object）"></a>DAO（Data Access Object）</h3><p>用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。</p><blockquote><p>用来访问数据库的对象，我们经常写数据库语句进行操作数据库，实际就是编写DAO</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object</tag>
      
      <tag>POJO</tag>
      
      <tag>DTO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 二叉树的最近公共祖先</title>
    <link href="/posts/62741/"/>
    <url>/posts/62741/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 1.</span>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 3.</span>        <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 4.</span>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 2. if(left != null and right != null)</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的最近公共祖先</title>
    <link href="/posts/52930/"/>
    <url>/posts/52930/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】构建乘积数组</title>
    <link href="/posts/0/"/>
    <url>/posts/0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p>示例:</p><p>输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]</p><p>提示：</p><p>所有元素乘积之和不会溢出 32 位整数<br>a.length &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;        <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            tmp *= a[i + <span class="hljs-number">1</span>];            b[i] *= tmp;        &#125;        <span class="hljs-keyword">return</span> b;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把字符串转换成整数</title>
    <link href="/posts/14041/"/>
    <url>/posts/14041/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] c = str.trim().toCharArray();        <span class="hljs-keyword">if</span>(c.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>) sign = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] != <span class="hljs-string">'+'</span>) i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; c.length; j++) &#123;            <span class="hljs-keyword">if</span>(c[j] &lt; <span class="hljs-string">'0'</span> || c[j] &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">'7'</span>) <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;            res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">'0'</span>);        &#125;        <span class="hljs-keyword">return</span> sign * res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】不用加减乘除做加法</title>
    <link href="/posts/29898/"/>
    <url>/posts/29898/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p>示例:</p><p>输入: a = 1, b = 1<br>输出: 2</p><p>提示：</p><p>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span>            <span class="hljs-keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span>            a ^= b; <span class="hljs-comment">// a = 非进位和</span>            b = c; <span class="hljs-comment">// b = 进位</span>        &#125;        <span class="hljs-keyword">return</span> a;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】求1+2+…+n</title>
    <link href="/posts/57729/"/>
    <url>/posts/57729/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例 1：</p><p>输入: n = 3<br>输出: 6<br>示例 2：</p><p>输入: n = 9<br>输出: 45</p><p>限制：</p><p>1 &lt;= n &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>什么都不让用，那就递归</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    n += sumNums(n - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> n;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】股票的最大利润</title>
    <link href="/posts/34252/"/>
    <url>/posts/34252/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price : prices) &#123;            cost = Math.min(cost, price);            profit = Math.max(profit, price - cost);        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】圆圈中最后剩下的数字</title>
    <link href="/posts/57141/"/>
    <url>/posts/57141/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><p>输入: n = 5, m = 3<br>输出: 3<br>示例 2：</p><p>输入: n = 10, m = 17<br>输出: 2</p><p>限制：</p><p>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】扑克牌中的顺子</title>
    <link href="/posts/57432/"/>
    <url>/posts/57432/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p>示例 1:</p><p>输入: [1,2,3,4,5]<br>输出: True</p><p>示例 2:</p><p>输入: [0,0,1,2,5]<br>输出: True</p><p>限制：</p><p>数组长度为 5 </p><p>数组的数取值为 [0, 13] .</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> joker = <span class="hljs-number">0</span>;        Arrays.sort(nums); <span class="hljs-comment">// 数组排序</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++; <span class="hljs-comment">// 统计大小王数量</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 若有重复，提前返回 false</span>        &#125;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 59 - II. 队列的最大值</title>
    <link href="/posts/52311/"/>
    <url>/posts/52311/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue;    LinkedList&lt;Integer&gt; max;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        max = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-comment">//LinkedList是双端链表</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> max.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:max.getFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue.add(value);        <span class="hljs-keyword">while</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;max.getLast()&lt;value)&#123;<span class="hljs-comment">//注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。</span>            max.removeLast();        &#125;        max.add(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;queue.peek().equals(max.getFirst()))<span class="hljs-comment">//Integer类型的值的比较不能直接使用==</span>            max.removeFirst();        <span class="hljs-keyword">return</span> queue.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:queue.poll();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment">     * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment">     * int param_1 = obj.max_value();</span><span class="hljs-comment">     * obj.push_back(value);</span><span class="hljs-comment">     * int param_3 = obj.pop_front();</span><span class="hljs-comment">     */</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 I. 滑动窗口的最大值</title>
    <link href="/posts/63496/"/>
    <url>/posts/63496/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><blockquote><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span> - k; j &lt; nums.length; i++, j++) &#123;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>])                deque.removeFirst(); <span class="hljs-comment">// 删除 deque 中对应的 nums[i-1]</span>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])                deque.removeLast(); <span class="hljs-comment">// 保持 deque 递减</span>            deque.addLast(nums[j]);            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)                res[i] = deque.peekFirst();  <span class="hljs-comment">// 记录窗口最大值</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】左旋转字符串</title>
    <link href="/posts/21767/"/>
    <url>/posts/21767/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：</p><p>1 &lt;= k &lt; s.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】翻转单词顺序</title>
    <link href="/posts/14883/"/>
    <url>/posts/14883/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：</p><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span>        <span class="hljs-keyword">int</span> j = s.length() - <span class="hljs-number">1</span>, i = j;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 搜索首个空格</span>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 添加单词</span>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span>    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        String[] strs = s.trim().split(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 删除首尾空格，分割字符串</span>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒序遍历单词列表</span>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">""</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 遇到空单词则跳过</span>            res.append(strs[i] + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 将单词拼接至 StringBuilder</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串，删除尾部空格，并返回</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的连续正数序列</title>
    <link href="/posts/28354/"/>
    <url>/posts/28354/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;= target &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的左边界</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的右边界</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口中数字的和</span>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (i &lt;= target / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (sum &lt; target) &#123;            <span class="hljs-comment">// 右边界向右移动</span>            sum += j;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 记录结果</span>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++) &#123;                arr[k-i] = k;            &#125;            res.add(arr);            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的两个数字</title>
    <link href="/posts/51459/"/>
    <url>/posts/51459/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p><p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">int</span> s = nums[i] + nums[j];            <span class="hljs-keyword">if</span>(s &lt; target) i++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; target) j--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; nums[i], nums[j] &#125;;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】56 - II. 数组中数字出现的次数 II</title>
    <link href="/posts/6401/"/>
    <url>/posts/6401/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>示例 1：</p><p>输入：nums = [3,4,3,3]<br>输出：4<br>示例 2：</p><p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">大佬题解</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c : nums) &#123;        b = b ^ c &amp; ~ a;        a = a ^ c &amp; ~ b;    &#125;    <span class="hljs-keyword">return</span> b;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 数组中数字出现的次数</title>
    <link href="/posts/48087/"/>
    <url>/posts/48087/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：</p><p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p><p>限制：</p><p>2 &lt;= nums.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            x^=s;        &#125;        x&amp;=-x;        <span class="hljs-keyword">int</span> x1=<span class="hljs-number">0</span>,x2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            <span class="hljs-keyword">if</span>((s&amp;x) ==<span class="hljs-number">0</span>) x1^=s;            <span class="hljs-keyword">else</span> x2^=s;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x1,x2&#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】平衡二叉树</title>
    <link href="/posts/41081/"/>
    <url>/posts/41081/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>      1     / \    2   2   / \  3   3 / \4   4</code></pre><p>返回 false 。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dg(root)!=-<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dg</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=dg(root.left);        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right=dg(root.right);        <span class="hljs-keyword">if</span>(right==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> Math.abs(left-right)&lt;<span class="hljs-number">2</span>?Math.max(left,right)+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】55 - I. 二叉树的深度</title>
    <link href="/posts/2906/"/>
    <url>/posts/2906/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><p>提示：</p><p>节点总数 &lt;= 10000</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) tmp.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) tmp.add(node.right);            &#125;            queue = tmp;            res++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/posts/7777/"/>
    <url>/posts/7777/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4<br>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p><p>限制：</p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>本文解法基于此性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p><p>根据以上性质，易得二叉搜索树的 <strong>中序遍历倒序</strong> 为 <strong>递减序列</strong> 。</p><p>因此，求 “二叉搜索树第 <em>k</em> 大的节点” 可转化为求 “此树的中序遍历倒序的第 <em>k</em> 个节点”。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res, k;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.k = k;        dfs(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(--k == <span class="hljs-number">0</span>) res = root.val;        dfs(root.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 0～n-1中缺失的数字</title>
    <link href="/posts/44204/"/>
    <url>/posts/44204/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例 1:</p><p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/posts/7776/"/>
    <url>/posts/7776/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(nums, target) - helper(nums, target - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] &lt;= tar) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】两个链表的第一个公共节点</title>
    <link href="/posts/33030/"/>
    <url>/posts/33030/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" alt="img"></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="/img/loading.gif" alt="img"></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>方法1，使用双指针</p><p>一个从A开始   结束之后指向B</p><p>一个从B开始 结束之后指向A</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;    <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    ListNode L = headA;    ListNode R = headB;    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-comment">//当一个节点达到一个链表的尾部，则从另一个链表继续，同时count++</span>    <span class="hljs-keyword">while</span> (L != R) &#123;        L = L.next;        R = R.next;        <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span>) &#123;            L = headB;            count ++;        &#125;        <span class="hljs-keyword">if</span> (R == <span class="hljs-keyword">null</span>) &#123;            R = headA;            count++;        &#125;        <span class="hljs-keyword">if</span> (count &gt;<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> L;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/posts/48274/"/>
    <url>/posts/48274/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】跨域问题"><a href="#【项目笔记】跨域问题" class="headerlink" title="【项目笔记】跨域问题"></a>【项目笔记】跨域问题</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是 浏览器对javascript施加的安全限制。 • 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p><p><img src="https://img2.jimu98.cn/blog/20200724001043.png" srcset="/img/loading.gif" alt="image-20200724001043268"></p><h2 id="跨域流程"><a href="#跨域流程" class="headerlink" title="跨域流程"></a>跨域流程</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">具体点这里</a></p><p>看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>巴拉巴拉，这些不是重点，如果大家想看更多，强烈建议去看阮一峰老师的博客</p><p>那么这里着重说一下，非简单请求。</p><p>非简单请求，在请求前，需要发送<code>预检请求</code></p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><h2 id="跨域解决办法"><a href="#跨域解决办法" class="headerlink" title="跨域解决办法"></a>跨域解决办法</h2><h3 id="1-使用niinx部署为同一域"><a href="#1-使用niinx部署为同一域" class="headerlink" title="1.使用niinx部署为同一域"></a>1.使用niinx部署为同一域</h3><p><img src="https://img2.jimu98.cn/blog/20200724001945.png" srcset="/img/loading.gif" alt="image-20200724001945071"></p><h3 id="2-配置当次请求允许跨域"><a href="#2-配置当次请求允许跨域" class="headerlink" title="2.配置当次请求允许跨域"></a>2.配置当次请求允许跨域</h3><pre><code class="hljs mathematica"><span class="hljs-number">1</span>、添加响应头• Access-<span class="hljs-keyword">Control</span>-Allow-Origin：支持哪些来源的请求跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Methods：支持哪些方法跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含cookie• Access-<span class="hljs-keyword">Control</span>-Expose-Headers：跨域请求暴露的字段• CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到<span class="hljs-number">6</span>个基本字段：Cache-<span class="hljs-keyword">Control</span>、Content-<span class="hljs-keyword">Language</span>、Content-Type、Expires、<span class="hljs-keyword">Last</span>-Modified、Pragma。如果想拿到其他字段，就必须在Access-<span class="hljs-keyword">Control</span>-Expose-Headers里面指定。• Access-<span class="hljs-keyword">Control</span>-<span class="hljs-keyword">Max</span>-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</code></pre><blockquote></blockquote><h3 id="3…"><a href="#3…" class="headerlink" title="3….."></a>3…..</h3><p>办法相当多，合理使用</p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>递归</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三级分类：递归树形结构数据</title>
    <link href="/posts/2980/"/>
    <url>/posts/2980/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】三级分类：递归树形结构数据"><a href="#【项目笔记】三级分类：递归树形结构数据" class="headerlink" title="【项目笔记】三级分类：递归树形结构数据"></a>【项目笔记】三级分类：递归树形结构数据</h1><blockquote><p>注意要熟悉 stream 写法</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1.查出所有分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter((categoryEntity) -&gt;                                                                categoryEntity.getParentCid() == <span class="hljs-number">0</span>                                                               ).map((menu) -&gt; &#123;        menu.setChildren(getChildrens(menu, entities));        <span class="hljs-keyword">return</span> menu;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-comment">//2.组装成父子树形结构</span>    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">//递归查找所有菜单的子菜单</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; &#123;        <span class="hljs-keyword">return</span> categoryEntity.getParentCid().equals(root.getCatId());    &#125;).map(categoryEntity -&gt; &#123;        <span class="hljs-comment">//1.找到子菜单</span>        categoryEntity.setChildren(getChildrens(categoryEntity, all));        <span class="hljs-keyword">return</span> categoryEntity;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-comment">//2.菜单的排序</span>        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-keyword">return</span> children;&#125;<span class="hljs-comment">//for循环拼接</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.查询出所有的分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 2.组装成父子的树形结构</span>    List&lt;CategoryEntity&gt; level1Menus = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 找到所有的一级分类</span>    <span class="hljs-keyword">for</span> (CategoryEntity entity : entities) &#123;        <span class="hljs-keyword">if</span> (entity.getParentCid() == <span class="hljs-number">0</span>) &#123;            level1Menus.add(entity);        &#125;    &#125;    <span class="hljs-keyword">for</span> (CategoryEntity level1Menu : level1Menus) &#123;        level1Menu.setChildren(getChildrens(level1Menu, entities));    &#125;    <span class="hljs-comment">//排序</span>    level1Menus.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * 递归查找所有的下级分类</span><span class="hljs-comment">     * 在这一级别的分类中找下级分类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 当前级别的分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> all  全部分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下一级分类</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (CategoryEntity a : all) &#123;        <span class="hljs-keyword">if</span> (a.getParentCid().equals(root.getCatId())) &#123;            a.setChildren(getChildrens(a, all));            children.add(a);        &#125;    &#125;    children.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> children;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>递归</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】VUE复习</title>
    <link href="/posts/63899/"/>
    <url>/posts/63899/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】VUE复习"><a href="#【项目笔记】VUE复习" class="headerlink" title="【项目笔记】VUE复习"></a>【项目笔记】VUE复习</h1><h2 id="MVVM思想"><a href="#MVVM思想" class="headerlink" title="MVVM思想"></a>MVVM思想</h2><p>MVVM的全名是Model-View-ViewModel，它的基本思路就是这样：</p><p><img src="https://pic3.zhimg.com/80/1d9336019baa5cabdf0e5e30b3effffb_hd.jpg" srcset="/img/loading.gif" alt="image"></p><p>M：即Model，模型，包括数据和一些基本操作</p><p>V：即View，试图，页面渲染结果</p><p>VM：即View-Model，模型与视图间的双向操作</p><p><img src="https://pic4.zhimg.com/80/edd0080fb145315fbc96164c219fee7e_hd.jpg" srcset="/img/loading.gif" alt="image"></p><h2 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h2><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官网链接</a></p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;num&quot;&gt;    &lt;button v-on:click&#x3D;&quot;num++&quot;&gt;点赞&lt;&#x2F;button&gt;    &lt;button v-on:click&#x3D;&quot;cancle&quot;&gt;取消&lt;&#x2F;button&gt;    &lt;h1&gt; &#123;&#123;name&#125;&#125; ,非常帅，有&#123;&#123;num&#125;&#125;个人为他点赞&#123;&#123;hello()&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;1、vue声明式渲染    let vm &#x3D; new Vue(&#123;        el: &quot;#app&quot;,&#x2F;&#x2F;绑定元素        data: &#123;  &#x2F;&#x2F;封装数据            name: &quot;张三&quot;,            num: 1        &#125;,        methods:&#123;  &#x2F;&#x2F;封装方法            cancle()&#123;                this.num -- ;            &#125;,            hello()&#123;                return &quot;1&quot;            &#125;        &#125;    &#125;);    &#x2F;&#x2F;2、双向绑定,模型变化，视图变化。反之亦然。    &#x2F;&#x2F;3、事件处理    &#x2F;&#x2F;v-xx：指令    &#x2F;&#x2F;1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的    &#x2F;&#x2F;2、指令来简化对dom的一些操作。    &#x2F;&#x2F;3、声明方法来做更复杂的操作。methods里面可以封装方法。&lt;&#x2F;script&gt;</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-text-v-html"><a href="#v-text-v-html" class="headerlink" title="v-text=   v-html="></a>v-text=   v-html=</h3><pre><code class="hljs js">&lt;span v-html=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;br/</span>&gt;&lt;span v-text=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">data:&#123;</span><span class="hljs-regexp">    msg:"&lt;h1&gt;Hello&lt;/</span>h1&gt;<span class="hljs-string">",</span><span class="hljs-string">    link:"</span>http:<span class="hljs-comment">//www.baidu.com"</span>&#125;,</code></pre><h3 id="v-bind：-给任意属性绑定值-或者前面加"><a href="#v-bind：-给任意属性绑定值-或者前面加" class="headerlink" title="v-bind： 给任意属性绑定值  或者前面加 :"></a>v-bind： 给任意属性绑定值  或者前面加 :</h3><pre><code class="hljs js">&lt;a :href=<span class="hljs-string">"link"</span>&gt;gogogo&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- class,style  &#123;class名：加上？&#125;--&gt;</span><span class="hljs-regexp">    &lt;span v-bind:class="&#123;active:isActive,'text-danger':hasError&#125;"</span><span class="hljs-regexp">    :style="&#123;color: color1,fontSize: size&#125;"&gt;你好&lt;/</span>span&gt;data:&#123;    link: <span class="hljs-string">"http://www.baidu.com"</span>,isActive:<span class="hljs-literal">true</span>,hasError:<span class="hljs-literal">true</span>,color1:<span class="hljs-string">'red'</span>,size:<span class="hljs-string">'36px'</span>&#125;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model="></a>v-model=</h3><blockquote><p>在未来开发中，使用这个较多</p></blockquote><pre><code class="hljs js">精通的语言：    &lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Java"</span>&gt; java&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"PHP"</span>&gt; PHP&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Python"</span>&gt; Python&lt;br/&gt;选中了 &#123;&#123;language.join(<span class="hljs-string">","</span>)&#125;&#125;data:&#123;    language: []&#125;</code></pre><h3 id="v-on：-绑定事件-或者直接写"><a href="#v-on：-绑定事件-或者直接写" class="headerlink" title="v-on： 绑定事件 或者直接写@"></a>v-on： 绑定事件 或者直接写@</h3><pre><code class="hljs js">&lt;!--事件中直接写js片段--&gt;    &lt;button v-on:click=<span class="hljs-string">"num++"</span>&gt;点赞&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;</span><span class="hljs-regexp">        &lt;button @click="cancle"&gt;取消&lt;/</span>button&gt;&lt;!--  --&gt;        &lt;h1&gt;有&#123;&#123;num&#125;&#125;个赞&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 事件修饰符 --&gt;</span><span class="hljs-regexp">&lt;div style="border: 1px solid red;padding: 20px;" v-on:click.once="hello"&gt;</span><span class="hljs-regexp">                大div</span><span class="hljs-regexp">&lt;div style="border: 1px solid blue;padding: 20px;" @click.stop="hello"&gt;</span><span class="hljs-regexp">    小div &lt;br /</span>&gt;    &lt;a href=<span class="hljs-string">"http://www.baidu.com"</span> @click.prevent.stop=<span class="hljs-string">"hello"</span>&gt;去百度&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 按键修饰符： --&gt;</span><span class="hljs-regexp">        &lt;input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10"&gt;&lt;br /</span>&gt;            提示：&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;script src="../</span>node_modules/vue/dist/vue.js<span class="hljs-string">"&gt;&lt;/script&gt;</span><span class="hljs-string"></span><span class="hljs-string">&lt;script&gt;</span><span class="hljs-string">        new Vue(&#123;</span>        el:"#app",        data:&#123;            num: <span class="hljs-number">1</span>        &#125;,        methods:&#123;            cancle()&#123;                <span class="hljs-keyword">this</span>.num--;            &#125;,            hello()&#123;                alert(<span class="hljs-string">"点击了"</span>)            &#125;        &#125;    &#125;)&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>阻止事件</p><blockquote><p>.stop 阻止事件冒泡到父元素<br>.prevent 阻止默认事件发生<br>.capture 使用事件捕获模式<br>.self 只有元素自身触发事件才 执行。(冒泡或捕获的都不执行 )<br>.once 只执行一-次</p></blockquote><p>按键修饰符</p><blockquote><p>.ctrl  =&gt; //Ctrl键</p><p>.enter =&gt; // enter键 </p><p>.tab =&gt; // tab键 </p><p>.delete (捕获“删除”和“退格”按键) =&gt; // 删除键 </p><p>.esc =&gt; // 取消键 .space =&gt; // 空格键 </p><p>.up =&gt; // 上 </p><p>.down =&gt; // 下 </p><p>.left =&gt; // 左 </p><p>.right =&gt; // 右</p></blockquote><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for="></a>v-for=</h3><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;ul&gt;    &lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(user,index) in users"</span> :key=<span class="hljs-string">"user.name"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"user.gender == '女'"</span>&gt;        &lt;!-- <span class="hljs-number">1</span>、显示user信息：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span> --&gt;            当前索引：&#123;&#123;index&#125;&#125; ==&gt; &#123;&#123;user.name&#125;&#125;  ==&gt;   &#123;&#123;user.gender&#125;&#125; ==&gt;&#123;&#123;user.age&#125;&#125; &lt;br&gt;                &lt;!-- <span class="hljs-number">2</span>、获取数组下标：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(item,index) in items"</span> --&gt;                &lt;!-- <span class="hljs-number">3</span>、遍历对象：                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"value in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key) in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key,index) in object"</span>     --&gt;    对象信息：&lt;span v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(v,k,i) in user"</span>&gt;&#123;&#123;k&#125;&#125;==&#123;&#123;v&#125;&#125;==&#123;&#123;i&#125;&#125;；&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;</span><span class="hljs-regexp">    &lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;ul&gt;</span><span class="hljs-regexp">    &lt;li v-for="(num,index) in nums" :key="index"&gt;&lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp">&lt;script&gt;         </span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            users: [&#123; name: '柳岩', gender: '女', age: 21 &#125;,</span><span class="hljs-regexp">                    &#123; name: '张三', gender: '男', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '范冰冰', gender: '女', age: 24 &#125;,</span><span class="hljs-regexp">                    &#123; name: '刘亦菲', gender: '女', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '古力娜扎', gender: '女', age: 25 &#125;],</span><span class="hljs-regexp">            nums: [1,2,3,4,4]</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">    &#125;)</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><blockquote><p>v-else和v-else-if</p></blockquote><pre><code class="hljs js">&lt;!--     v-<span class="hljs-keyword">if</span>，顾名思义，条件判断。当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被渲染。    v-show，当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被显示。 --&gt;&lt;button v-on:click=<span class="hljs-string">"show = !show"</span>&gt;点我呀&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!-- 1、使用v-if显示 --&gt;</span><span class="hljs-regexp">    &lt;h1 v-if="show"&gt;if=看到我....&lt;/</span>h1&gt;&lt;!-- <span class="hljs-number">2</span>、使用v-show显示 --&gt;    &lt;h1 v-show=<span class="hljs-string">"show"</span>&gt;show=看到我&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/</span>button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-if="random&gt;=0.75"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.75</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>=<span class="hljs-string">"random&gt;=0.5"</span>&gt;    看到我啦？！ &amp;gt;= <span class="hljs-number">0.5</span>&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-else-if="random&gt;=0.2"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.2</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>&gt;    看到我啦？！ &amp;lt; <span class="hljs-number">0.2</span>&lt;<span class="hljs-regexp">/h1&gt;</span></code></pre><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><blockquote><p>计算属性 是指一个可以计算的属性（这不是废话吗<del>~</del>）</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//计算属性可以写到computed里面</span>computed: &#123;    totalPrice() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xyjPrice * <span class="hljs-keyword">this</span>.xyjNum + <span class="hljs-keyword">this</span>.shzPrice * <span class="hljs-keyword">this</span>.shzNum    &#125;&#125;,<span class="hljs-comment">//监听器</span>watch: &#123;    xyjNum(newVal, oldVal) &#123;        <span class="hljs-keyword">if</span> (newVal &gt;= <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">"库存超出限制"</span>;            <span class="hljs-keyword">this</span>.xyjNum = <span class="hljs-number">3</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">""</span>;        &#125;    &#125;&#125;,</code></pre><blockquote><p>过滤器</p></blockquote><pre><code class="hljs js">&#123;&#123;user.gender | genderFilter&#125;&#125; ==&gt; &#123;&#123;user.gender | gFilter&#125;&#125;<span class="hljs-comment">//   `|`  表示管道符</span><span class="hljs-comment">//全局过滤器</span>Vue.filter(<span class="hljs-string">"gFilter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"男~~~"</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"女~~~"</span>;    &#125;&#125;)filters: &#123;    <span class="hljs-comment">//// filters 定义局部过滤器，只可以在当前vue实例中使用</span>    genderFilter(val) &#123;        <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"男"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"女"</span>;        &#125;    &#125;&#125;</code></pre><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。<br>但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</p><p>在vue里面，所有的vue实例都是组件</p></blockquote><p><img src="http://www.uml.org.cn/AJAX/images/201905069.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs js"><span class="hljs-comment">//用的时候就直接这么用</span>&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/1、全局声明注册一个组件</span><span class="hljs-regexp">Vue.component("counter", &#123;</span><span class="hljs-regexp">    template: `&lt;button v-on:click="count++"&gt;我被点击了 &#123;&#123;count&#125;&#125; 次&lt;/</span>button&gt;<span class="hljs-string">`,</span><span class="hljs-string">    data() &#123;</span><span class="hljs-string">        return &#123;</span><span class="hljs-string">            count: 1</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;);</span><span class="hljs-string"></span><span class="hljs-string">//2、局部声明一个组件</span><span class="hljs-string">const buttonCounter = &#123;</span><span class="hljs-string">    template: `</span>&lt;button v-on:click=<span class="hljs-string">"count++"</span>&gt;我被点击了 &#123;&#123;count&#125;&#125; 次~~~&lt;<span class="hljs-regexp">/button&gt;`,</span><span class="hljs-regexp">    data() &#123;</span><span class="hljs-regexp">        return &#123;</span><span class="hljs-regexp">            count: 1</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;;</span></code></pre><h2 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">官网地址</a></p><p><img src="https://cn.vuejs.org/images/lifecycle.png" srcset="/img/loading.gif" alt="Vue 实例生命周期"></p><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;span id=<span class="hljs-string">"num"</span>&gt;&#123;&#123;num&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;button @click="num++"&gt;赞！&lt;/</span>button&gt;&lt;h2&gt;&#123;&#123;name&#125;&#125;，有&#123;&#123;num&#125;&#125;个人点赞&lt;<span class="hljs-regexp">/h2&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            name: "张三",</span><span class="hljs-regexp">            num: 100</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        methods: &#123;</span><span class="hljs-regexp">            show() &#123;</span><span class="hljs-regexp">                return this.name;</span><span class="hljs-regexp">            &#125;,</span><span class="hljs-regexp">            add() &#123;</span><span class="hljs-regexp">                this.num++;</span><span class="hljs-regexp">            &#125;</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeCreate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeCreate=============");</span><span class="hljs-regexp">            console.log("数据模型未加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法未加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板未加载：" + document.getElementById("num"));</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        created: function () &#123;</span><span class="hljs-regexp">            console.log("=========created=============");</span><span class="hljs-regexp">            console.log("数据模型已加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法已加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板已加载：" + document.getElementById("num"));</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeMount() &#123;</span><span class="hljs-regexp">            console.log("=========beforeMount=============");</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        mounted() &#123;</span><span class="hljs-regexp">            console.log("=========mounted=============");</span><span class="hljs-regexp">            console.log("html模板已渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeUpdate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeUpdate=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板未更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        updated() &#123;</span><span class="hljs-regexp">            console.log("=========updated=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板已更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;);</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h2 id="vue模块化开发"><a href="#vue模块化开发" class="headerlink" title="vue模块化开发"></a>vue模块化开发</h2><blockquote><p>1、npm install webpack -g<br>全局安装webpack<br>2、npm install -g @vue/cli-init<br>全局安装vue脚手架<br>3、初始化vue项目;<br>vue init webpack appname:  vue 脚手架使用webpack模板初始化一个 appname项目<br>4、启动vue项目;<br>项目的package.json中有scripts, 代表我们能运行的命令<br>npm start = npm run dev:  启动项目</p></blockquote><pre><code class="hljs 1c"><span class="hljs-comment">//文件目录结构</span><span class="hljs-comment">//build  跟打包相关目录</span><span class="hljs-comment">//config  配置信息，一般配置一些端口之类的，然后区分不同的环境</span><span class="hljs-comment">//node_modules   用npm安装的所有项目依赖</span><span class="hljs-comment">//src  编写代码的文件夹</span><span class="hljs-comment">//assets </span><span class="hljs-comment">//components</span><span class="hljs-comment">//router  路由配置</span><span class="hljs-comment">//main.js  主程序</span><span class="hljs-comment">//static  静态资源文件</span><span class="hljs-comment">//.babelrc  语法转义</span><span class="hljs-comment">//package.json  需要的依赖   类似于maven的pom</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>promist</tag>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/posts/53611/"/>
    <url>/posts/53611/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例:</p><p>s = “abaccdeff”<br>返回 “b”</p><p>s = “”<br>返回 “ “</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>//方法1</p><ol><li><p>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt; 1&gt;1 ”。</p></li><li><p>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 11 的字符”，并返回。</p></li></ol><p>//方法2</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//方法1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            <span class="hljs-keyword">if</span>(dic.get(c)) <span class="hljs-keyword">return</span> c;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;           <span class="hljs-keyword">if</span>(d.getValue()) <span class="hljs-keyword">return</span> d.getKey();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】丑数</title>
    <link href="/posts/30989/"/>
    <url>/posts/30989/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>示例:</p><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>1 是丑数。<br>n 不超过1690。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题目如果循环遍历当然可以，但是更好的做法是动态规划</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最长不含重复字符的子字符串</title>
    <link href="/posts/32201/"/>
    <url>/posts/32201/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：</p><p>s.length &lt;= 40000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;            <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取索引 i</span>            dic.put(s.charAt(j), j); <span class="hljs-comment">// 更新哈希表</span>            tmp = tmp &lt; j - i ? tmp + <span class="hljs-number">1</span> : j - i; <span class="hljs-comment">// dp[j - 1] -&gt; dp[j]</span>            res = Math.max(res, tmp); <span class="hljs-comment">// max(dp[j - 1], dp[j])</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】礼物的最大价值</title>
    <link href="/posts/55982/"/>
    <url>/posts/55982/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 初始化第一行</span>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) <span class="hljs-comment">// 初始化第一列</span>            grid[i][<span class="hljs-number">0</span>] += grid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)                 grid[i][j] += Math.max(grid[i][j - <span class="hljs-number">1</span>], grid[i - <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数字翻译成字符串</title>
    <link href="/posts/53764/"/>
    <url>/posts/53764/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p>提示：</p><p>0 &lt;= num &lt; 231</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        String str=String.valueOf(num);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length()];        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = (str.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>);    dp[<span class="hljs-number">1</span>] = n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;str.length();i++)&#123;            n = (str.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(i) - <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span>) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[str.length() - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】ES6复习</title>
    <link href="/posts/9344/"/>
    <url>/posts/9344/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】ES6复习"><a href="#【项目笔记】ES6复习" class="headerlink" title="【项目笔记】ES6复习"></a>【项目笔记】ES6复习</h1><h2 id="ES6介绍"><a href="#ES6介绍" class="headerlink" title="ES6介绍"></a>ES6介绍</h2><p>ECMAScript6.0是JavaScript语言的下一代标准。。。。。。等等介绍。。</p><h2 id="let语法"><a href="#let语法" class="headerlink" title="let语法"></a>let语法</h2><pre><code class="hljs js"><span class="hljs-comment">//var声明的变量往往会越域</span><span class="hljs-comment">//let声明的变量有严格的局部作用域</span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>    &#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">//b is not defined</span><span class="hljs-comment">//var可以声明多次</span><span class="hljs-comment">//let只能声明一次</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">4</span>  <span class="hljs-comment">//报错</span><span class="hljs-comment">//var 会变量提升</span><span class="hljs-comment">//let 不存在变量提升</span><span class="hljs-built_in">console</span>.log(x)  <span class="hljs-comment">//undefined</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><span class="hljs-built_in">console</span>.log(y)  <span class="hljs-comment">//y is not defined</span><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span><span class="hljs-comment">//因此，以后我们经常使用let生成变量</span><span class="hljs-comment">//同时我们也经常使用const声明常量  声明之后就不可以再改变</span></code></pre><h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">//原来</span><span class="hljs-keyword">let</span> a = arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">let</span> b = arr[<span class="hljs-number">1</span>]<span class="hljs-keyword">let</span> c = arr[<span class="hljs-number">2</span>]<span class="hljs-built_in">console</span>.log(a, b, c)<span class="hljs-comment">//现在</span><span class="hljs-keyword">let</span> [x, y, z] = arr<span class="hljs-built_in">console</span>.log(x, y, z)<span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-comment">//原来</span><span class="hljs-comment">// const name = person.name</span><span class="hljs-comment">// const age = person.age</span><span class="hljs-comment">// const language = person.language</span><span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>:abc, age, language &#125; = person<span class="hljs-built_in">console</span>.log(name, age, language)</code></pre><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> str=<span class="hljs-string">`&lt;div&gt;</span><span class="hljs-string">            &lt;span&gt;hello jimu98&lt;/span&gt;</span><span class="hljs-string">        &lt;/div&gt;`</span><span class="hljs-comment">//以前这些内容需要字符串拼接，现在只需要一个反引号</span></code></pre><h3 id="字符串插入变量和表达式"><a href="#字符串插入变量和表达式" class="headerlink" title="字符串插入变量和表达式"></a>字符串插入变量和表达式</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"这是一个函数"</span>&#125;<span class="hljs-keyword">let</span> info =<span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age+<span class="hljs-number">10</span>&#125;</span>了，我想说<span class="hljs-subst">$&#123;fun()&#125;</span>`</span><span class="hljs-built_in">console</span>.log(info)</code></pre><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code class="hljs js"><span class="hljs-comment">//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    b=b || <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>))<span class="hljs-comment">//现在可以写默认值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a,b=<span class="hljs-number">1</span></span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">20</span>))</code></pre><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><pre><code class="hljs js"><span class="hljs-comment">//不定参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">...values</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(values.length)&#125;fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="hljs js"><span class="hljs-comment">//以前声明一个方法</span><span class="hljs-keyword">var</span> print1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(obj)&#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(obj)print(<span class="hljs-string">"Hello"</span>)<span class="hljs-comment">//多个参数</span><span class="hljs-keyword">var</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + bprint(sum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<span class="hljs-comment">//箭头函数+解构</span><span class="hljs-keyword">var</span> hello2 = <span class="hljs-function">(<span class="hljs-params">&#123; name &#125;</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello,"</span> + name)hello2(person)</code></pre><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><h3 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person))<span class="hljs-comment">//["name", "age", "language"]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(person))<span class="hljs-comment">//["jimu98", 21, Array(3)]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(person)) <span class="hljs-comment">//[Array(2), Array(2), Array(2)]</span><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;<span class="hljs-built_in">Object</span>.assign(target, source1, source2)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(target))<span class="hljs-comment">//["a", "b", "c"]</span></code></pre><h3 id="声明对象的简写"><a href="#声明对象的简写" class="headerlink" title="声明对象的简写"></a>声明对象的简写</h3><pre><code class="hljs js"><span class="hljs-comment">//声明对象简写</span><span class="hljs-keyword">const</span> age = <span class="hljs-number">23</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">"jimu98"</span><span class="hljs-comment">//原来</span><span class="hljs-keyword">const</span> person1 = &#123; <span class="hljs-attr">age</span>: age, <span class="hljs-attr">name</span>: name &#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> person2=&#123;age,name&#125;<span class="hljs-built_in">console</span>.log(person2)</code></pre><h3 id="函数的简写"><a href="#函数的简写" class="headerlink" title="函数的简写"></a>函数的简写</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">"jack"</span>,    <span class="hljs-comment">//原来</span>    eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;,    eat2: <span class="hljs-function"><span class="hljs-params">food</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(person.name + <span class="hljs-string">"在吃"</span> + food),<span class="hljs-comment">//这里不能用this</span>    eat3(food)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;&#125;person.eat(<span class="hljs-string">"香蕉"</span>)person.eat2(<span class="hljs-string">"苹果"</span>)person.eat3(<span class="hljs-string">"梨"</span>)</code></pre><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><pre><code class="hljs js"><span class="hljs-comment">// 1、拷贝对象（深拷贝）</span><span class="hljs-keyword">let</span> p1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> someone = &#123; ...p1 &#125;<span class="hljs-built_in">console</span>.log(someone)  <span class="hljs-comment">//&#123;name: "Amy", age: 15&#125;</span><span class="hljs-comment">// 2、合并对象</span><span class="hljs-keyword">let</span> age1 = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> name1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span> &#125;<span class="hljs-keyword">let</span> p2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"zhangsan"</span>&#125;p2 = &#123; ...age1, ...name1 &#125; <span class="hljs-comment">//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值</span><span class="hljs-built_in">console</span>.log(p2)</code></pre><p>map和reduce方法</p><p>//map()接受一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><pre><code class="hljs js"><span class="hljs-comment">//数组中新增了map和reduce方法。</span><span class="hljs-comment">//map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'20'</span>, <span class="hljs-string">'-5'</span>, <span class="hljs-string">'3'</span>];<span class="hljs-comment">//原来</span>arr = arr.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>&#125;);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//现在</span>arr = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//传入回调函数</span><span class="hljs-keyword">let</span> res = arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"上一次处理后"</span> + a)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"当前正在处理的"</span> + b)    <span class="hljs-keyword">return</span> a + b;&#125;)<span class="hljs-built_in">console</span>.log(res)</code></pre><h2 id="promist"><a href="#promist" class="headerlink" title="promist"></a>promist</h2><blockquote><p>这个是用来处理异步</p><p>在之前我们写ajax中，需要一层层嵌套，通过这个就可以使用then关键字</p><p>最后还可以抽取出来公共代码，使得代码更加优雅</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//1、查出当前用户信息</span><span class="hljs-comment">//2、按照当前用户的id查出他的课程</span><span class="hljs-comment">//3、按照当前课程id查出分数</span><span class="hljs-comment">// $.ajax(&#123;</span><span class="hljs-comment">//     url: "mock/user.json",</span><span class="hljs-comment">//     success(data) &#123;</span><span class="hljs-comment">//         console.log("查询用户：", data);</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//             success(data) &#123;</span><span class="hljs-comment">//                 console.log("查询到课程：", data);</span><span class="hljs-comment">//                 $.ajax(&#123;</span><span class="hljs-comment">//                     url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//                     success(data) &#123;</span><span class="hljs-comment">//                         console.log("查询到分数：", data);</span><span class="hljs-comment">//                     &#125;,</span><span class="hljs-comment">//                     error(error) &#123;</span><span class="hljs-comment">//                         console.log("出现异常了：" + error);</span><span class="hljs-comment">//                     &#125;</span><span class="hljs-comment">//                 &#125;);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error(error) &#123;</span><span class="hljs-comment">//                 console.log("出现异常了：" + error);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;,</span><span class="hljs-comment">//     error(error) &#123;</span><span class="hljs-comment">//         console.log("出现异常了：" + error);</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">//1、Promise可以封装异步操作</span><span class="hljs-comment">// let p = new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//     //1、异步操作</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: "mock/user.json",</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询用户成功:", data)</span><span class="hljs-comment">//             resolve(data);</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//             reject(err);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// p.then((obj) =&gt; &#123;</span><span class="hljs-comment">//     return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;obj.id&#125;.json`,</span><span class="hljs-comment">//             success: function (data) &#123;</span><span class="hljs-comment">//                 console.log("查询用户课程成功:", data)</span><span class="hljs-comment">//                 resolve(data);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error: function (err) &#123;</span><span class="hljs-comment">//                 reject(err)</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">// &#125;).then((data) =&gt; &#123;</span><span class="hljs-comment">//     console.log("上一步的结果", data)</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询课程得分成功:", data)</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, data</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        $.ajax(&#123;            url: url,            data: data,            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;                resolve(data);            &#125;,            error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;                reject(err)            &#125;        &#125;)    &#125;);&#125;<span class="hljs-keyword">get</span>("mock/user.json")    .then((data) =&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"用户查询成功~~~:"</span>, data)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(`mock/user_corse_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data) =&gt; &#123;</span><span class="hljs-string">    console.log("课程查询成功~~~:", data)</span><span class="hljs-string">    return get(`</span>mock/corse_score_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data)=&gt;&#123;</span><span class="hljs-string">    console.log("课程成绩查询成功~~~:", data)</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .catch((err)=&gt;&#123;</span><span class="hljs-string">    console.log("出现异常",err)</span><span class="hljs-string">&#125;);</span></code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>如果我们想在写的代码里面调用其他js，就可以采用模块化的方法</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//export  导出</span>varname =<span class="hljs-string">"jack"</span><span class="hljs-keyword">var</span> age=<span class="hljs-number">21</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-keyword">export</span> &#123;name,age,add&#125;<span class="hljs-comment">//import 导入</span><span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">"./hello.js"</span><span class="hljs-keyword">import</span> &#123;name,age,add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./user.js"</span><span class="hljs-comment">//使用</span><span class="hljs-keyword">let</span> res = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(res)</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>箭头函数</tag>
      
      <tag>promist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/posts/53610/"/>
    <url>/posts/53610/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><p>提示:</p><p>0 &lt; nums.length &lt;= 100<br>说明:</p><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)             strs[i] = String.valueOf(nums[i]);        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(String s : strs)            res.append(s);        <span class="hljs-keyword">return</span> res.toString();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/posts/11457/"/>
    <url>/posts/11457/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p>示例 1：</p><p>输入：n = 3<br>输出：3<br>示例 2：</p><p>输入：n = 11<br>输出：0</p><p>限制：</p><p>0 &lt;= n &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0.9</span> *Math.pow(<span class="hljs-number">10</span>,i)*i)&#123;            n -= <span class="hljs-number">0.9</span>*Math.pow(<span class="hljs-number">10</span>,i)*i;            i++;        &#125;        <span class="hljs-keyword">int</span> s=(n-<span class="hljs-number">1</span>)/i+(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        String res=Integer.toString(s);        <span class="hljs-keyword">return</span> res.charAt((n-<span class="hljs-number">1</span>)%i)-<span class="hljs-string">'0'</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】1～n整数中1出现的次数</title>
    <link href="/posts/31564/"/>
    <url>/posts/31564/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>示例 1：</p><p>输入：n = 12<br>输出：5<br>示例 2：</p><p>输入：n = 13<br>输出：6</p><p>限制：</p><p>1 &lt;= n &lt; 2^31</p><p>题解</p><p>根据当前位 curcur 值的不同，分为以下三种情况：</p><p>当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：high×digit</p><blockquote><p>如下图所示，以 n = 2304为例，求 digit = 10（即十位）的 11 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155713.png" srcset="/img/loading.gif" alt="image-20200723155713725"></p><p>当 cur = 1时： 此位 11 的出现次数由高位 high 和低位 low 决定，计算公式为：high×digit+low+1</p><blockquote><p>如下图所示，以 n = 2314 为例，求 digit = 10digit=10 （即十位）的 1出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155726.png" srcset="/img/loading.gif" alt="image-20200723155726661"></p><p>当 cur = 2, 3, …, 9时： 此位 1 的出现次数只由高位 high决定，计算公式为：(high+1)×digit</p><blockquote><p>如下图所示，以 n = 2324 为例，求 digit = 10（即十位）的 1 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155740.png" srcset="/img/loading.gif" alt="image-20200723155740761"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> digit=<span class="hljs-number">1</span>,res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> high=n/<span class="hljs-number">10</span>,low=<span class="hljs-number">0</span>,cur=n%<span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)res+=high*digit;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">1</span>) res+=high*digit+low+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> res+= (high+<span class="hljs-number">1</span>) * digit;            low+=cur*digit;            cur = high%<span class="hljs-number">10</span>;            high/=<span class="hljs-number">10</span>;            digit*=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】连续子数组的最大和</title>
    <link href="/posts/24791/"/>
    <url>/posts/24791/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>简单dp</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> [] dp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [nums.length];        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max=dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            dp[i]=Math.max(nums[i],nums[i]+dp[i-<span class="hljs-number">1</span>]);            max=Math.max(max,dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;<span class="hljs-comment">//-----------直接用原来数组-------------</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            nums[i]=Math.max(nums[i],nums[i]+nums[i-<span class="hljs-number">1</span>]);            max=Math.max(max,nums[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数据流中的中位数</title>
    <link href="/posts/4804/"/>
    <url>/posts/4804/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p><p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：</p><p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p><p>限制：</p><p>最多会对 addNum、findMedia进行 50000 次调用。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>建立一个 <strong>小顶堆</strong> <em>A</em> 和 <strong>大顶堆</strong> <em>B</em> ，各保存列表的一半元素</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    Queue&lt;Integer&gt; A,B;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y-x));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;            A.add(num);            B.add(A.poll());        &#125;<span class="hljs-keyword">else</span>&#123;            B.add(num);            A.add(B.poll());        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.size()!=B.size()?A.peek():(A.peek()+B.peek())/<span class="hljs-number">2.0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>小顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/posts/11456/"/>
    <url>/posts/11456/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p>限制：</p><p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题直接排序即可，但是还是多写几次快排吧，毕竟太难记了</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span>        <span class="hljs-keyword">return</span> quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] quickSearch(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span>        <span class="hljs-keyword">int</span> j = partition(nums, lo, hi);        <span class="hljs-keyword">if</span> (j == k) &#123;            <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span>        <span class="hljs-keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k): quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);    &#125;    <span class="hljs-comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">int</span> v = nums[lo];        <span class="hljs-keyword">int</span> i = lo, j = hi + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);            <span class="hljs-keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">int</span> t = nums[j];            nums[j] = nums[i];            nums[i] = t;        &#125;        nums[lo] = nums[j];        nums[j] = v;        <span class="hljs-keyword">return</span> j;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数组中出现次数超过一半的数字</title>
    <link href="/posts/32794/"/>
    <url>/posts/32794/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> x=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;                x=nums[i];                y=<span class="hljs-number">1</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(x!=nums[i])&#123;                y--;            &#125;<span class="hljs-keyword">else</span>                y++;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】字符串的排列</title>
    <link href="/posts/29189/"/>
    <url>/posts/29189/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Set&lt;String&gt; res = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;&#125;;        <span class="hljs-keyword">boolean</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()];        dfs(s,<span class="hljs-string">""</span>,visited);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s,String letter,<span class="hljs-keyword">boolean</span>[] visited)</span></span>&#123;        <span class="hljs-keyword">if</span>(s.length()==letter.length())&#123;            res.add(letter);            <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//为了退出递归</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">char</span> c=s.charAt(i);            <span class="hljs-keyword">if</span>(visited[i])<span class="hljs-keyword">continue</span>;            visited[i]=<span class="hljs-keyword">true</span>;            dfs(s,letter+c,visited);            visited[i]=<span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】序列化二叉树</title>
    <link href="/posts/43464/"/>
    <url>/posts/43464/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]”</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"[]"</span>;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"["</span>);        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>) &#123;                res.append(node.val + <span class="hljs-string">","</span>);                queue.add(node.left);                queue.add(node.right);            &#125;            <span class="hljs-keyword">else</span> res.append(<span class="hljs-string">"null,"</span>);        &#125;        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);        res.append(<span class="hljs-string">"]"</span>);        <span class="hljs-keyword">return</span> res.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">"[]"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        String[] vals = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">","</span>);        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.left);            &#125;            i++;            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.right);            &#125;            i++;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树与双向链表</title>
    <link href="/posts/43341/"/>
    <url>/posts/43341/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p> <img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" srcset="/img/loading.gif" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>直接使用中序遍历可以按顺序遍历，之后定义一个pre节点用来构造链表。</p><p>pre就是已经构造好的链表，cur是要被构造的，所以 cur.left=pre  pre=cur</p><p>但是pre的right也要指向cur</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Node pre,head;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        dfs(root);        head.left=pre;        pre.right=head;                <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span>;        dfs(cur.left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>)pre.right=cur;        <span class="hljs-keyword">else</span> head=cur;        cur.left=pre;        pre=cur;        dfs(cur.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】复杂链表的复制</title>
    <link href="/posts/60762/"/>
    <url>/posts/60762/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>示例 1：</p><p><img src="https://img2.jimu98.cn/blog/20200723155648.png" srcset="/img/loading.gif" alt="image-20200723155648550"></p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Node cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));            cur=cur.next;        &#125;        cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.get(cur).next=map.get(cur.next);            map.get(cur).random=map.get(cur.random);            cur=cur.next;        &#125;        <span class="hljs-keyword">return</span> map.get(head);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树中和为某一值的路径</title>
    <link href="/posts/39292/"/>
    <url>/posts/39292/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \    / \7    2  5   1</code></pre><p>返回:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><p>提示：</p><p>节点总数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;        recur(root, sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        path.add(root.val);        tar -= root.val;        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            res.add(<span class="hljs-keyword">new</span> LinkedList(path));        recur(root.left, tar);        recur(root.right, tar);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的后序遍历序列</title>
    <link href="/posts/10263/"/>
    <url>/posts/10263/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code> 5/ \</code></pre><p>   2   6<br>  / <br> 1   3<br>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><p>提示：</p><p>数组长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> root = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = postorder.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])            root = stack.pop();            stack.add(postorder[i]);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅲ. 从上到下打印二叉树</title>
    <link href="/posts/26051/"/>
    <url>/posts/26051/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) Collections.reverse(tmp);            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅱ. 从上到下打印二叉树</title>
    <link href="/posts/38336/"/>
    <url>/posts/38336/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 从上到下打印二叉树</title>
    <link href="/posts/19999/"/>
    <url>/posts/19999/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p><p>[3,9,20,15,7]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            ans.add(node.val);            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++)            res[i] = ans.get(i);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】栈的压入、弹出序列</title>
    <link href="/posts/44870/"/>
    <url>/posts/44870/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p><p>提示：</p><p>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : pushed) &#123;            stack.push(num); <span class="hljs-comment">// num 入栈</span>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; <span class="hljs-comment">// 循环判断与出栈</span>                stack.pop();                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】包含min函数的栈</title>
    <link href="/posts/38161/"/>
    <url>/posts/38161/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><p>提示：</p><p>各函数的调用总次数不超过 20000 次</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; A, B;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        A.add(x);        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)            B.add(x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))            B.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> B.peek();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】顺时针打印矩阵</title>
    <link href="/posts/46990/"/>
    <url>/posts/46990/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>限制：</p><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = matrix.length - <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(r + <span class="hljs-number">1</span>) * (b + <span class="hljs-number">1</span>)];        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="hljs-comment">// left to right.</span>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="hljs-comment">// top to bottom.</span>            <span class="hljs-keyword">if</span>(l &gt; --r) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="hljs-comment">// right to left.</span>            <span class="hljs-keyword">if</span>(t &gt; --b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="hljs-comment">// bottom to top.</span>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】对称的二叉树</title>
    <link href="/posts/37514/"/>
    <url>/posts/37514/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>  1 / \2   2 \   \ 3    3</code></pre><p>示例 1：</p><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : recur(root.left, root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树的镜像</title>
    <link href="/posts/8573/"/>
    <url>/posts/8573/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>    4   /  \  2    7 / \   / \1   3 6   9</code></pre><p>镜像输出：</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>示例 1：</p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode tmp = root.left;        root.left = mirrorTree(root.right);        root.right = mirrorTree(tmp);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】树的子结构</title>
    <link href="/posts/14963/"/>
    <url>/posts/14963/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>示例 1：</p><p>输入：A = [1,2,3], B = [3,1]<br>输出：false<br>示例 2：</p><p>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true<br>限制：</p><p>0 &lt;= 节点个数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">return</span> (A != <span class="hljs-keyword">null</span> &amp;&amp; B != <span class="hljs-keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】合并两个排序的链表</title>
    <link href="/posts/30/"/>
    <url>/posts/30/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p><p>0 &lt;= 链表长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>为了方便，在做链表题的时候一定要给自己加一个伪头节点</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dum = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), cur = dum;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;                cur.next = l1;                l1 = l1.next;            &#125;            <span class="hljs-keyword">else</span> &#123;                cur.next = l2;                l2 = l2.next;            &#125;            cur = cur.next;        &#125;        cur.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> dum.next;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/posts/49603/"/>
    <url>/posts/49603/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">null</span>;ListNode cur = head;ListNode tmp = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            tmp=cur.next;            cur.next=pre;            pre=cur;            cur=tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>反转链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】链表中倒数第 k 个节点</title>
    <link href="/posts/59519/"/>
    <url>/posts/59519/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode former = head, latter = head;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)            former = former.next;        <span class="hljs-keyword">while</span>(former != <span class="hljs-keyword">null</span>) &#123;            former = former.next;            latter = latter.next;        &#125;        <span class="hljs-keyword">return</span> latter;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/posts/49602/"/>
    <url>/posts/49602/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>示例：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首尾双指针<br>定义头指针 leftleft ，尾指针 rightright .<br>leftleft 一直往右移，直到它指向的值为偶数<br>rightright 一直往左移， 直到它指向的值为奇数<br>交换 nums[left]nums[left] 和 nums[right]nums[right] .<br>重复上述操作，直到 left == rightleft==right .</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>, tmp;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;            tmp = nums[i];            nums[i] = nums[j];            nums[j] = tmp;        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】表示数值的字符串</title>
    <link href="/posts/22013/"/>
    <url>/posts/22013/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://img2.jimu98.cn/blog/20200723155550.png" srcset="/img/loading.gif" alt="image-20200723155550061"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;        Map[] states = &#123;            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">0</span>); put(<span class="hljs-string">'s'</span>, <span class="hljs-number">1</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;, <span class="hljs-comment">// 0.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;,                           <span class="hljs-comment">// 1.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;, <span class="hljs-comment">// 2.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,              <span class="hljs-comment">// 3.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); &#125;&#125;,                                        <span class="hljs-comment">// 4.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'s'</span>, <span class="hljs-number">6</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                           <span class="hljs-comment">// 5.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                                        <span class="hljs-comment">// 6.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,                           <span class="hljs-comment">// 7.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;                                         <span class="hljs-comment">// 8.</span>        &#125;;        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> t;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) t = <span class="hljs-string">'d'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) t = <span class="hljs-string">'s'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'.'</span> || c == <span class="hljs-string">'e'</span> || c == <span class="hljs-string">'E'</span> || c == <span class="hljs-string">' '</span>) t = c;            <span class="hljs-keyword">else</span> t = <span class="hljs-string">'?'</span>;            <span class="hljs-keyword">if</span>(!states[p].containsKey(t)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            p = (<span class="hljs-keyword">int</span>)states[p].get(t);        &#125;        <span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】删除链表的节点</title>
    <link href="/posts/60046/"/>
    <url>/posts/60046/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head.val==val)<span class="hljs-keyword">return</span> head.next;        ListNode p=head;        ListNode q=head;        head=head.next;        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(head.val==val)&#123;                q.next=head.next;                <span class="hljs-keyword">return</span> p;            &#125;            q=head;            head=head.next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】打印从1到最大的n位数</title>
    <link href="/posts/16039/"/>
    <url>/posts/16039/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例 1:</p><p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p>说明：</p><p>用返回一个整数列表来代替打印<br>n 为正整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;        <span class="hljs-keyword">int</span> Size=(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Size];        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>)&#123;            result[i]=i+<span class="hljs-number">1</span>;            i++;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数值的整数次方</title>
    <link href="/posts/24573/"/>
    <url>/posts/24573/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:</p><p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p><p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> b = n;        <span class="hljs-keyword">double</span> res=<span class="hljs-number">1.0</span>;        <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;            x=<span class="hljs-number">1</span>/x;            b=-b;        &#125;        <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)res*=x;            x*=x;            b&gt;&gt;=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二进制中1的个数</title>
    <link href="/posts/23336/"/>
    <url>/posts/23336/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例 1：</p><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是逐位判断</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res += n &amp; <span class="hljs-number">1</span>;            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><blockquote><p>下面看其他大佬们的位运算</p></blockquote><p>n&amp;(n-1)即可将最后一位1置为0</p><p><img src="https://img2.jimu98.cn/blog/20200723155527.png" srcset="/img/loading.gif" alt="image-20200723155527400"></p><p>那么循环置为0   就可以将全部的1统计出来了</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res++;            n &amp;= n - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 剪绳子 II</title>
    <link href="/posts/33109/"/>
    <url>/posts/33109/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p>提示：</p><p>2 &lt;= n &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>与剪绳子相比，这个需要手写一个快速幂</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) rem = (rem * x) % p;            x = (x * x) % p;        &#125;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】剪绳子</title>
    <link href="/posts/16499/"/>
    <url>/posts/16499/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>提示：</p><p>2 &lt;= n &lt;= 58</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>先说结论，绳子尽量切割成多个3，至于为什么，我也不会</p><p>但是，比如四   1和3 明显不如 2和2</p><p>最终结论：<br>最优： 33 。把绳子尽可能切为多个长度为 33 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,2 三种情况。<br>次优： 22 。若最后一段绳子长度为 22 ；则保留，不再拆为 1+11+1 。<br>最差： 11 。若最后一段绳子长度为 11 ；则应把一份 3 + 13+1 替换为 2 + 22+2，因为 2 * 2 &gt; 3 * 1 </p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】机器人的运动范围</title>
    <link href="/posts/24502/"/>
    <url>/posts/24502/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><p>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：</p><p>输入：m = 3, n = 1, k = 0<br>输出：1<br>提示：</p><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>注意，这里是不能进入行坐标和列坐标的数位之和大于k的格子。  是“数位之和”</p><p>所以不可以简单的循环，因为有些区域数值可以达到，但是走不到</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155448.png" srcset="/img/loading.gif" alt="image-20200723155447989"></p><p>比如这张图</p><p><img src="https://img2.jimu98.cn/blog/20200723155502.png" srcset="/img/loading.gif" alt="image-20200723155502511"></p><pre><code class="hljs java"><span class="hljs-comment">//dfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> m, n, k;    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.m = m; <span class="hljs-keyword">this</span>.n = n; <span class="hljs-keyword">this</span>.k = k;        <span class="hljs-keyword">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> si, <span class="hljs-keyword">int</span> sj)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        visited[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj) + dfs(i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span>);    &#125;&#125;<span class="hljs-comment">//bfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue= <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt;();        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span>[] x = queue.poll();            <span class="hljs-keyword">int</span> i = x[<span class="hljs-number">0</span>], j = x[<span class="hljs-number">1</span>], si = x[<span class="hljs-number">2</span>], sj = x[<span class="hljs-number">3</span>];            <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">continue</span>;            visited[i][j] = <span class="hljs-keyword">true</span>;            res ++;            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj &#125;);            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span> &#125;);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】矩阵中的路径</title>
    <link href="/posts/14838/"/>
    <url>/posts/14838/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例 1：</p><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false<br>提示：</p><p>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> []dx=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,dy=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] words = word.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;                <span class="hljs-keyword">if</span>(dfs(board,words,i,j,<span class="hljs-number">0</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][]board,<span class="hljs-keyword">char</span> [] word,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> tmp)</span></span>&#123;        <span class="hljs-keyword">if</span>(word[tmp]!=board[i][j])<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(tmp==word.length-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;            <span class="hljs-keyword">int</span> new_x=i+dx[k],new_y=j+dy[k];            <span class="hljs-keyword">if</span>(new_x&lt;<span class="hljs-number">0</span> || new_x&gt;= board.length || new_y&lt;<span class="hljs-number">0</span> || new_y&gt;= board[<span class="hljs-number">0</span>].length)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">char</span> c=board[i][j];            board[i][j]=<span class="hljs-string">'/'</span>;            <span class="hljs-keyword">if</span>(dfs(board,word,new_x,new_y,tmp+<span class="hljs-number">1</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            board[i][j]=c;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】旋转数组的最小数字</title>
    <link href="/posts/34802/"/>
    <url>/posts/34802/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j=numbers.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;j) &#123;            <span class="hljs-keyword">int</span> mid=(i+j)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(numbers[mid]&gt;numbers[j])                i=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid]&lt;numbers[j])                j=mid;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> numbers[i];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>旋转数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】青蛙跳台问题</title>
    <link href="/posts/10863/"/>
    <url>/posts/10863/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：2<br>示例 2：</p><p>输入：n = 7<br>输出：21<br>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>其实这个题目就是斐波那契数列，但是用到了记忆化</p><p>这么一说  不就有点dp的味道了吗，对，没错。其实算法间没那么清晰的界限。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】斐波那契数列一</title>
    <link href="/posts/13220/"/>
    <url>/posts/13220/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：1<br>示例 2：</p><p>输入：n = 5<br>输出：5</p><p>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(N-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】用两个栈实现队列</title>
    <link href="/posts/63463/"/>
    <url>/posts/63463/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Deque&lt;Integer&gt; stack1;    Deque&lt;Integer&gt; stack2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();        stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        stack1.push(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果第二个栈为空，就把第一个全部倒进第二个</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;                stack2.push(stack1.pop());            &#125;        &#125;        <span class="hljs-comment">//判断第二个栈是否为空，空就返回-1</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> stack2.pop();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】重建二叉树</title>
    <link href="/posts/40693/"/>
    <url>/posts/40693/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>递归解法</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map &lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.length;i++)map.put(inorder[i],i);        <span class="hljs-keyword">return</span> dfs(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> pl,<span class="hljs-keyword">int</span> pr,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> il,<span class="hljs-keyword">int</span> ir)</span></span>&#123;        <span class="hljs-keyword">if</span>(pl&gt;pr)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[pl]);        <span class="hljs-keyword">int</span> k=map.get(root.val);        TreeNode left = dfs(preorder,pl+<span class="hljs-number">1</span>,pl+k-il,inorder,il,k-<span class="hljs-number">1</span>);        TreeNode right = dfs(preorder,pl+k-il+<span class="hljs-number">1</span>,pr,inorder,k+<span class="hljs-number">1</span>,ir);        root.left=left;        root.right=right;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】从尾到头打印链表</title>
    <link href="/posts/62262/"/>
    <url>/posts/62262/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;        List &lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            list.add(head.val);            head=head.next;        &#125;        <span class="hljs-keyword">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [list.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;            res[i]=list.get(res.length-<span class="hljs-number">1</span>-i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】找出数组中重复的数字</title>
    <link href="/posts/39270/"/>
    <url>/posts/39270/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;  <span class="hljs-comment">//看题目要求，这一段可以不写</span>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span> || nums[i]&gt;n)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">while</span>(nums[i]!=i)&#123;                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<span class="hljs-keyword">return</span> nums[i];                swap(nums,i,nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp=nums[a];        nums[a]=nums[b];        nums[b]=tmp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】替换空格</title>
    <link href="/posts/12645/"/>
    <url>/posts/12645/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = s.length();        <span class="hljs-keyword">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length * <span class="hljs-number">3</span>];        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">char</span> c = s.charAt(i);            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;                array[size++] = <span class="hljs-string">'%'</span>;                array[size++] = <span class="hljs-string">'2'</span>;                array[size++] = <span class="hljs-string">'0'</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                array[size++] = c;            &#125;        &#125;        String newStr = <span class="hljs-keyword">new</span> String(array, <span class="hljs-number">0</span>, size);  <span class="hljs-comment">//记住这种转换方法</span>        <span class="hljs-keyword">return</span> newStr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二维数组中的查找</title>
    <link href="/posts/42070/"/>
    <url>/posts/42070/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数target。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是遍历寻找，或者二分，但是这个题很取巧</p><p>比如我们将要求的数和右上角进行比较</p><p>如果右上角小于target，那么这一行所有的数小于target  也就是i++</p><p>如果右上角大于target，那么这一列所有的数都大于target   也就是j–</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;-<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(matrix[i][j]==target)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)i++;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Gateway微服务网关</title>
    <link href="/posts/13347/"/>
    <url>/posts/13347/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Gateway微服务网关"><a href="#【项目创建流程】Gateway微服务网关" class="headerlink" title="【项目创建流程】Gateway微服务网关"></a>【项目创建流程】Gateway微服务网关</h1><h2 id="网关基本概念"><a href="#网关基本概念" class="headerlink" title="网关基本概念"></a>网关基本概念</h2><h3 id="1、API网关介绍"><a href="#1、API网关介绍" class="headerlink" title="1、API网关介绍"></a>1、API网关介绍</h3><p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><p>（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。</p><p>（2）存在跨域请求，在一定场景下处理相对复杂。</p><p>（3）认证复杂，每个服务都需要独立认证。</p><p>（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</p><p>以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p><h3 id="2、Spring-Cloud-Gateway"><a href="#2、Spring-Cloud-Gateway" class="headerlink" title="2、Spring Cloud Gateway"></a>2、Spring Cloud Gateway</h3><p><strong>Spring cloud gateway</strong>是spring官方基于Spring 5.0和Spring Boot2.0等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。</p><h3 id="3、Spring-Cloud-Gateway-核心概念"><a href="#3、Spring-Cloud-Gateway-核心概念" class="headerlink" title="3、Spring Cloud Gateway 核心概念"></a>3、Spring Cloud Gateway 核心概念</h3><p>下面介绍一下Spring Cloud Gateway中几个重要的概念。</p><p>（1）路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter组成。如果断言路由为真，则说明请求的URL和配置匹配</p><p>（2）断言。Java8中的断言函数。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。</p><p>（3）过滤器。一个标准的Spring webFilter。Spring cloud gateway中的filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。</p><h3 id="4、执行流程"><a href="#4、执行流程" class="headerlink" title="4、执行流程"></a>4、执行流程</h3><p>如下图所示，Spring cloud Gateway发出请求。然后再由Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway web handler。Handler再通过指定的过滤器链将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154454.png" srcset="/img/loading.gif" alt="image-20200723154454083"></p><p><strong>4、特点</strong></p><p>优点：</p><ul><li>性能强劲：是第一代网关Zuul的1.6倍</li><li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li><li>设计优雅，容易扩展</li></ul><p>缺点：</p><ul><li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li><li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li><li>需要Spring Boot 2.0及以上的版本，才支持</li></ul><h2 id="搭建Gateway服务"><a href="#搭建Gateway服务" class="headerlink" title="搭建Gateway服务"></a>搭建Gateway服务</h2><h3 id="创建父模块infrastructure"><a href="#创建父模块infrastructure" class="headerlink" title="创建父模块infrastructure"></a>创建父模块infrastructure</h3><h3 id="创建子模块api-gateway"><a href="#创建子模块api-gateway" class="headerlink" title="创建子模块api_gateway"></a>创建子模块api_gateway</h3><h3 id="配置pom"><a href="#配置pom" class="headerlink" title="配置pom"></a>配置pom</h3><p>在api_gateway的pom中添加如下依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 网关 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h3 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h3><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">9110</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">infrastructure-apigateway</span> <span class="hljs-comment"># 服务名</span></code></pre><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><p>修改日志输出目录名为 apigateway</p><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><blockquote><p>gataway依赖common，课是common引入了mybatisplus操作，所有有数据库操作，因此需要排除数据库操作</p><p>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class} )</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfrastructureApiGatewayApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(InfrastructureApiGatewayApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="启动网关"><a href="#启动网关" class="headerlink" title="启动网关"></a>启动网关</h2><h3 id="配置路由和跨域"><a href="#配置路由和跨域" class="headerlink" title="配置路由和跨域"></a>配置路由和跨域</h3><h4 id="1、路由和断言"><a href="#1、路由和断言" class="headerlink" title="1、路由和断言"></a>1、路由和断言</h4><p>application.yml文件中添加路由配置</p><ul><li>-：表示数组元素，可以配置多个节点</li><li>id：配置的唯一标识，可以和微服务同名，也可以起别的名字，区别于其他 Route。</li><li>uri：路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li><li>predicates：断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li><li>Path：路径形式的断言。当匹配这个路径时，断言条件成立</li><li>/**：一个或多个层次的路径</li></ul><pre><code class="hljs dts"><span class="hljs-meta">#spring:</span><span class="hljs-symbol">  cloud:</span><span class="hljs-symbol">    gateway:</span><span class="hljs-symbol">      routes:</span>      - id: service-edu<span class="hljs-symbol">        uri:</span> http:<span class="hljs-comment">//localhost:8110</span><span class="hljs-symbol">        predicates:</span>        - Path=<span class="hljs-meta-keyword">/user/</span>**</code></pre><h5 id="内置路由断言工厂"><a href="#内置路由断言工厂" class="headerlink" title="内置路由断言工厂"></a>内置路由断言工厂</h5><p>Predicate(断言) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。</p><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><h6 id="1、基于Datetime"><a href="#1、基于Datetime" class="headerlink" title="1、基于Datetime"></a>1、基于Datetime</h6><p>此类型的断言根据时间做判断，主要有三个：</p><ul><li>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期</li><li>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期</li><li>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内</li></ul><pre><code class="hljs angelscript">- After=<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>T23:<span class="hljs-number">59</span>:<span class="hljs-number">59.789</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>[Asia/Shanghai]</code></pre><h6 id="2、基于远程地址"><a href="#2、基于远程地址" class="headerlink" title="2、基于远程地址"></a>2、基于远程地址</h6><p> RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中</p><pre><code class="hljs angelscript">- RemoteAddr=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">24</span></code></pre><h6 id="3、基于Cookie"><a href="#3、基于Cookie" class="headerlink" title="3、基于Cookie"></a>3、基于Cookie</h6><p>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Cookie</span>=chocolate, ch.</code></pre><h6 id="4、基于Header"><a href="#4、基于Header" class="headerlink" title="4、基于Header"></a>4、基于Header</h6><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Header</span>=X-Request-Id, \d+</code></pre><h6 id="5、基于Host"><a href="#5、基于Host" class="headerlink" title="5、基于Host"></a>5、基于Host</h6><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Host</span>=**.testhost.org</code></pre><h6 id="6、基于Method请求方法"><a href="#6、基于Method请求方法" class="headerlink" title="6、基于Method请求方法"></a>6、基于Method请求方法</h6><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。</p><pre><code class="hljs oxygene">- <span class="hljs-function"><span class="hljs-keyword">Method</span>=<span class="hljs-title">GET</span></span></code></pre><h6 id="7、基于Path请求路径"><a href="#7、基于Path请求路径" class="headerlink" title="7、基于Path请求路径"></a>7、基于Path请求路径</h6><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。</p><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/foo/</span>**</span></code></pre><h6 id="8、基于Query请求参数"><a href="#8、基于Query请求参数" class="headerlink" title="8、基于Query请求参数"></a>8、基于Query请求参数</h6><p>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Query</span>=url,baidu</code></pre><h6 id="9、基于路由权重"><a href="#9、基于路由权重" class="headerlink" title="9、基于路由权重"></a>9、基于路由权重</h6><p>WeightRoutePredicateFactory：接收一个[组名,权重]，然后对于同一个组内的路由按照权重转发</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route1</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host1</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group3,</span> <span class="hljs-number">1</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route2</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host2</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=</span> <span class="hljs-string">group3,</span> <span class="hljs-number">9</span></code></pre><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><h6 id="一、过滤器的基本概念"><a href="#一、过滤器的基本概念" class="headerlink" title="一、过滤器的基本概念"></a>一、过滤器的基本概念</h6><p>1、作用</p><p>过滤器就是在请求的传递过程中，对请求和响应做一些修改</p><p>2、生命周期</p><p>客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p><p>pre： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现参数校验、权限校验、流量监控、日志输出、协议转换等；</p><p>post：这种过滤器在路由到达微服务以后执行。这种过滤器可用做响应内容、响应头的修改，日志的输出，流量监控等。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154536.png" srcset="/img/loading.gif" alt="image-20200723154536196"></p><p>3、分类</p><p>局部过滤器 GatewayFilter：作用在某一个路由上</p><p>全局过滤器 GlobalFilter：作用全部路由上</p><h6 id="二、局部过滤器"><a href="#二、局部过滤器" class="headerlink" title="二、局部过滤器"></a>二、局部过滤器</h6><p>1、内置局部过滤器</p><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">service-edu</span>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-edu</span>  <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**,</span> <span class="hljs-string">/*/edu/**</span>  <span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=250</span> <span class="hljs-comment"># 修改返回状态码</span></code></pre><p>测试：</p><p><img src="https:////img2.jimu98.cn/blog/20200723154605.png" srcset="/img/loading.gif" alt="image-20200723154605180"></p><h6 id="三、全局过滤器"><a href="#三、全局过滤器" class="headerlink" title="三、全局过滤器"></a>三、全局过滤器</h6><p>1、内置全局过滤器</p><p><img src="https:////img2.jimu98.cn/blog/20200723154630.png" srcset="/img/loading.gif" alt="image-20200723154630370"></p><p>内置全局过滤器的使用举例：负载均衡过滤器</p><pre><code class="hljs dts"><span class="hljs-symbol">lb:</span><span class="hljs-comment">//service-edu</span></code></pre><p>2、自定义全局过滤器</p><p>定义一个Filter实现 GlobalFilter 和 Ordered接口</p><p><code>自定义转发路径</code></p><pre><code class="hljs yaml"><span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\&#123;segment&#125;</span></code></pre><p>2、测试网关路由转发</p><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><p>请求转发到：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:8110/user/info</a></p><h3 id="通过nacos注册中心"><a href="#通过nacos注册中心" class="headerlink" title="通过nacos注册中心"></a>通过nacos注册中心</h3><h4 id="1、网关中添加依赖"><a href="#1、网关中添加依赖" class="headerlink" title="1、网关中添加依赖"></a>1、网关中添加依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、主类添加注解"><a href="#2、主类添加注解" class="headerlink" title="2、主类添加注解"></a>2、主类添加注解</h4><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableDiscoveryClient</span>  <span class="hljs-comment">//SpringBoot2.0之后可以省略</span></code></pre><h4 id="3、添加nacos配置"><a href="#3、添加nacos配置" class="headerlink" title="3、添加nacos配置"></a>3、添加nacos配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><h4 id="4、添加gateway配置"><a href="#4、添加gateway配置" class="headerlink" title="4、添加gateway配置"></a>4、添加gateway配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span><span class="hljs-comment">#    gateway:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">locator:</span>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># gateway可以发现nacos中的微服务</span></code></pre><h4 id="5、修改uri配置"><a href="#5、修改uri配置" class="headerlink" title="5、修改uri配置"></a>5、修改uri配置</h4><p>将uri的地址修改成注册中心中的微服务地址，网关姜葱nacos中按照名称获取微服务</p><p>lb：表示在集群环境下通过负载均衡的方式调用</p><pre><code class="hljs groovy"><span class="hljs-string">uri:</span> <span class="hljs-string">lb:</span><span class="hljs-comment">//service-edu  #内置负载均衡过滤器</span></code></pre><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><h4 id="7、匹配多个path"><a href="#7、匹配多个path" class="headerlink" title="7、匹配多个path"></a>7、匹配多个path</h4><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span></code></pre><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><h4 id="1、前端配置"><a href="#1、前端配置" class="headerlink" title="1、前端配置"></a>1、前端配置</h4><p>修改guli-admin中 config/dev.env.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">BASE_API: '"http://127.0.0.1:<span class="hljs-number">9110</span>"',</code></pre><h4 id="2、删除后端跨域配置"><a href="#2、删除后端跨域配置" class="headerlink" title="2、删除后端跨域配置"></a>2、删除后端跨域配置</h4><p>此时可以删除微服务中的跨域注解 <em>@CrossOrigin</em></p><p><em>例如 service_edu中 LoginController的跨域注解</em></p><h4 id="3、跨域配置"><a href="#3、跨域配置" class="headerlink" title="3、跨域配置"></a>3、跨域配置</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway.config;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        config.addAllowedMethod(<span class="hljs-string">"*"</span>);        config.addAllowedOrigin(<span class="hljs-string">"*"</span>);        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource(<span class="hljs-keyword">new</span> PathPatternParser());        source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(source);    &#125;&#125;</code></pre><p>注意：去掉后端的所有跨域配置</p><h3 id="完整的路由配置"><a href="#完整的路由配置" class="headerlink" title="完整的路由配置"></a>完整的路由配置</h3><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><pre><code class="hljs haml">routes:-<span class="ruby"> <span class="hljs-symbol">id:</span> service-edu</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-edu</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-cms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-cms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/cms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-oss</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-oss</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/oss</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-sms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-sms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/sms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-trade</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-trade</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/trade</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-ucenter</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-ucenter</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/ucenter</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-vod</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-vod</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/vod</span><span class="hljs-regexp">/**</span></span></code></pre><h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><p>（1）修改guli-site中 utils/request.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">baseURL: 'http://127.0.0.1:<span class="hljs-number">9110</span>',</code></pre><p>（2）所有的api模块中的baseURL可以删除</p><p>（3）guli-admin上传相关表单中action地址的修改</p><p>data中定义：</p><pre><code class="hljs css"><span class="hljs-selector-tag">BASE_API</span>: <span class="hljs-selector-tag">process</span><span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.BASE_API</span></code></pre><p>html中使用：</p><pre><code class="hljs clojure"><span class="hljs-symbol">:action=</span><span class="hljs-string">"BASE_API+'/admin/oss/file/upload?module=avatar'"</span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】集成Redis缓存</title>
    <link href="/posts/42033/"/>
    <url>/posts/42033/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】集成Redis缓存"><a href="#【项目创建流程】集成Redis缓存" class="headerlink" title="【项目创建流程】集成Redis缓存"></a>【项目创建流程】集成Redis缓存</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>由于首页数据变化不是很频繁，而且首页访问量相对较大，所以我们有必要把首页数据缓存到redis中，减少数据库压力和提高访问速度。</p><h3 id="2、RedisTemplate"><a href="#2、RedisTemplate" class="headerlink" title="2、RedisTemplate"></a>2、RedisTemplate</h3><p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是Spring Data Redis中对Jedis api的高度封装。</p><p>Spring Data Redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化功能，支持发布订阅，并对spring cache进行了实现。</p><h2 id="二、引入redis"><a href="#二、引入redis" class="headerlink" title="二、引入redis"></a>二、引入redis</h2><h3 id="1、项目中集成redis"><a href="#1、项目中集成redis" class="headerlink" title="1、项目中集成redis"></a>1、项目中集成redis</h3><p>common父模块中添加redis依赖，Spring Boot 2.0以上默认通过commons-pool2连接池连接redis</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring boot redis缓存引入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- lecttuce 缓存连接池--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加redis连接配置"><a href="#2、添加redis连接配置" class="headerlink" title="2、添加redis连接配置"></a>2、添加redis连接配置</h3><p>service_cms 和 service_edu 的 application.yml 中添加如下配置</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.100</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span> <span class="hljs-comment">#默认为空</span>    <span class="hljs-attr">lettuce:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#最大连接数，负值表示没有限制，默认8</span>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span>    <span class="hljs-comment">#最大阻塞等待时间，负值表示没限制，默认-1</span>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>     <span class="hljs-comment">#最大空闲连接，默认8</span>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>     <span class="hljs-comment">#最小空闲连接，默认0</span></code></pre><h3 id="3、配置Redis"><a href="#3、配置Redis" class="headerlink" title="3、配置Redis"></a>3、配置Redis</h3><p>service-base添加RedisConfig</p><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.atguigu.guli.service.base.config;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 我们自定义一个 RedisTemplate，设置序列化器，这样我们可以很方便的操作实例对象。</span><span class="hljs-comment"> * 否则redis自动使用对象的jdk序列化</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    @Bean    <span class="hljs-keyword">public</span> RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-type">RedisTemplate</span>&lt;&gt;();        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">StringRedisSerializer</span>());<span class="hljs-comment">//key序列化方式</span>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">GenericJackson2JsonRedisSerializer</span>());<span class="hljs-comment">//value序列化</span>        redisTemplate.setConnectionFactory(connectionFactory);                <span class="hljs-keyword">return</span> redisTemplate;    &#125;&#125;</code></pre><h2 id="三、测试redisTemplate"><a href="#三、测试redisTemplate" class="headerlink" title="三、测试redisTemplate"></a>三、测试redisTemplate</h2><h3 id="1、测试redis数据存储"><a href="#1、测试redis数据存储" class="headerlink" title="1、测试redis数据存储"></a>1、测试redis数据存储</h3><p>ApiAdController中添加下面的方法进行测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@PostMapping(<span class="hljs-meta-string">"save-test"</span>)</span><span class="hljs-keyword">public</span> R saveAd(<span class="hljs-meta">@RequestBody</span> Ad ad)&#123;    <span class="hljs-comment">//redisTemplate.opsForValue().set("ad1", ad);</span>    redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(<span class="hljs-string">"index::ad"</span>, ad);    <span class="hljs-keyword">return</span> R.ok();&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"get-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R getAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    Ad ad = (Ad)redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(key);    <span class="hljs-keyword">return</span> R.ok().<span class="hljs-keyword">data</span>(<span class="hljs-string">"ad"</span>, ad);&#125;<span class="hljs-meta">@DeleteMapping(<span class="hljs-meta-string">"remove-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R removeAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    <span class="hljs-built_in">Boolean</span> delete = redisTemplate.delete(key);    System.<span class="hljs-keyword">out</span>.println(delete);<span class="hljs-comment">//是否删除成功</span>    <span class="hljs-built_in">Boolean</span> hasKey = redisTemplate.hasKey(key);    System.<span class="hljs-keyword">out</span>.println(hasKey);<span class="hljs-comment">//key是否存在</span>    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h3 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h3><p>redisTemplate提供了以下几种存储数据的方法</p><pre><code class="hljs gcode">redisTemplate.opsForValue<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作字符串</span>redisTemplate.opsForHash<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作hash</span>redisTemplate.opsForList<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作list</span>redisTemplate.opsForSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作set</span>redisTemplate.opsForZSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作有序set</span></code></pre><h2 id="四、使用缓存注解"><a href="#四、使用缓存注解" class="headerlink" title="四、使用缓存注解"></a>四、使用缓存注解</h2><h3 id="1、修改Redis配置类"><a href="#1、修改Redis配置类" class="headerlink" title="1、修改Redis配置类"></a>1、修改Redis配置类</h3><p>配置类上添加注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableCaching</span></code></pre><p>添加bean配置</p><pre><code class="hljs reasonml">@Beanpublic CacheManager cache<span class="hljs-constructor">Manager(LettuceConnectionFactory <span class="hljs-params">connectionFactory</span>)</span> &#123;        RedisCacheConfiguration config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheConfiguration</span>.</span></span>default<span class="hljs-constructor">CacheConfig()</span>        <span class="hljs-comment">//过期时间600秒</span>        .entry<span class="hljs-constructor">Ttl(Duration.<span class="hljs-params">ofSeconds</span>(600)</span>)         <span class="hljs-comment">// 配置序列化</span>        .serialize<span class="hljs-constructor">KeysWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> StringRedisSerializer()</span>))        .serialize<span class="hljs-constructor">ValuesWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> GenericJackson2JsonRedisSerializer()</span>))        .disable<span class="hljs-constructor">CachingNullValues()</span>;    RedisCacheManager cacheManager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheManager</span>.</span></span>builder(connectionFactory)        .cache<span class="hljs-constructor">Defaults(<span class="hljs-params">config</span>)</span>        .build<span class="hljs-literal">()</span>;    return cacheManager;&#125;</code></pre><h3 id="2、添加缓存注解"><a href="#2、添加缓存注解" class="headerlink" title="2、添加缓存注解"></a>2、添加缓存注解</h3><p>@Cacheable(value = “xxx”, key = “‘xxx’”)：标注在方法上，对方法返回结果进行缓存。下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><p>service_cms：AdServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectByAdTypeId'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Ad&gt; selectByAdTypeId(String adTypeId) &#123;</code></pre><p>service_edu：CourseServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotCourse'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Course&gt; selectHotCourse() &#123;</code></pre><p>service_edu：TeacherServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotTeacher'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Teacher&gt; selectHotTeacher() &#123;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Redis</tag>
      
      <tag>bean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Sentinel介绍和环境搭建</title>
    <link href="/posts/42905/"/>
    <url>/posts/42905/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Sentinel介绍和环境搭建"><a href="#【项目创建流程】Sentinel介绍和环境搭建" class="headerlink" title="【项目创建流程】Sentinel介绍和环境搭建"></a>【项目创建流程】Sentinel介绍和环境搭建</h1><h2 id="一、Sentinel介绍"><a href="#一、Sentinel介绍" class="headerlink" title="一、Sentinel介绍"></a>一、Sentinel介绍</h2><h3 id="1、什么是Sentinel"><a href="#1、什么是Sentinel" class="headerlink" title="1、什么是Sentinel"></a>1、什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于服务容错的综合性解决方案。它以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来保护服务的稳定性。</p><h3 id="2、Sentinel-的特征"><a href="#2、Sentinel-的特征" class="headerlink" title="2、Sentinel 的特征"></a>2、Sentinel 的特征</h3><ul><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li>完备的实时监控：Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 SpringCloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。</li><li>完善的扩展点：Sentinel 提供简单易用、完善的扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="3、Sentinel-的组成"><a href="#3、Sentinel-的组成" class="headerlink" title="3、Sentinel 的组成"></a>3、Sentinel 的组成</h3><p>核心库（Java 客户端）：不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo /Spring Cloud 等框架也有较好的支持。</p><p>控制台（Dashboard）：基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="二、Sentinel控制台"><a href="#二、Sentinel控制台" class="headerlink" title="二、Sentinel控制台"></a>二、Sentinel控制台</h2><p>Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。</p><h3 id="1、下载和安装"><a href="#1、下载和安装" class="headerlink" title="1、下载和安装"></a>1、下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></p><p>下载版本：sentinel-dashboard-1.7.0.jar</p><h3 id="2、启动控制台"><a href="#2、启动控制台" class="headerlink" title="2、启动控制台"></a>2、启动控制台</h3><p>控制台本身是一个SpringBoot项目，直接使用jar命令启动项目</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">sentinel-dashboard-1</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.jar</span></code></pre><pre><code class="hljs reasonml">java -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dserver</span>.</span></span>port=<span class="hljs-number">8888</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dcsp</span>.</span></span>sentinel.dashboard.server=localhost:<span class="hljs-number">8080</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dproject</span>.</span></span>name=sentinel-dashboard -jar sentinel-dashboard-<span class="hljs-number">1.7</span>.<span class="hljs-number">0.</span>jar</code></pre><p>访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>用户名密码：sentinel/sentinel</p><h2 id="三、微服务集成Sentinel客户端"><a href="#三、微服务集成Sentinel客户端" class="headerlink" title="三、微服务集成Sentinel客户端"></a>三、微服务集成Sentinel客户端</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Sentinel的pom依赖（实际是在服务消费者端需要依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加测试方法"><a href="#2、添加测试方法" class="headerlink" title="2、添加测试方法"></a>2、添加测试方法</h3><p>TeacherController中添加如下方法用于测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message1"</span>)</span><span class="hljs-keyword">public</span> String message1() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message1"</span>;&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message2"</span>)</span><span class="hljs-keyword">public</span> String message2() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message2"</span>;&#125;</code></pre><h2 id="四、微服务连接控制台"><a href="#四、微服务连接控制台" class="headerlink" title="四、微服务连接控制台"></a>四、微服务连接控制台</h2><h3 id="1、微服务配置"><a href="#1、微服务配置" class="headerlink" title="1、微服务配置"></a>1、微服务配置</h3><p>service_edu微服务yml中添加以下配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span> <span class="hljs-comment">#跟控制台交流的端口，随意指定一个未使用的端口即可</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment"># 指定控制台服务的地址</span></code></pre><h3 id="2、swagger中测试"><a href="#2、swagger中测试" class="headerlink" title="2、swagger中测试"></a>2、swagger中测试</h3><p>测试message1和message2的访问</p><h3 id="3、查看sentinel控制台"><a href="#3、查看sentinel控制台" class="headerlink" title="3、查看sentinel控制台"></a>3、查看sentinel控制台</h3><p><img src="https://img2.jimu98.cn/blog/20200723155019.png" srcset="/img/loading.gif" alt="image-20200723155018963"></p><h3 id="4、控制台运行原理"><a href="#4、控制台运行原理" class="headerlink" title="4、控制台运行原理"></a>4、控制台运行原理</h3><p>Sentinel的控制台是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上，即在微服务中指定控制台的地址（localhost:8080）</p><p>并且还要开启一个跟控制台传递数据的端口（8081），控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。</p><h2 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h2><h3 id="1、引入sentinel的依赖"><a href="#1、引入sentinel的依赖" class="headerlink" title="1、引入sentinel的依赖"></a>1、引入sentinel的依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、开启Sentinel支持"><a href="#2、开启Sentinel支持" class="headerlink" title="2、开启Sentinel支持"></a>2、开启Sentinel支持</h3><p>在service_edu的yml配置文件中开启Feign对Sentinel的支持</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h3 id="3、创建容错类"><a href="#3、创建容错类" class="headerlink" title="3、创建容错类"></a>3、创建容错类</h3><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign.fallback;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OssFileServiceFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">removeFile</span><span class="hljs-params">(String url)</span> </span>&#123;        log.info(<span class="hljs-string">"熔断保护"</span>);        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;&#125;</code></pre><h3 id="4、指定容错类"><a href="#4、指定容错类" class="headerlink" title="4、指定容错类"></a>4、指定容错类</h3><p>为OpenFeign远程调用接口添加fallback属性值没指定容错类</p><pre><code class="hljs less"><span class="hljs-variable">@Service</span><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">"service-oss"</span>, fallback = OssFileServiceFallBack.class)public interface OssFileService &#123;</code></pre><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>停止service_oss微服务，测试删除讲师的功能</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Sentinel</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】注册中心和服务调用和配置中心</title>
    <link href="/posts/40668/"/>
    <url>/posts/40668/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Nacos注册中心和服务调用和配置中心"><a href="#【项目创建流程】Nacos注册中心和服务调用和配置中心" class="headerlink" title="【项目创建流程】Nacos注册中心和服务调用和配置中心"></a>【项目创建流程】Nacos注册中心和服务调用和配置中心</h1><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><h3 id="1、常见注册中心"><a href="#1、常见注册中心" class="headerlink" title="1、常见注册中心"></a>1、常见注册中心</h3><ul><li><p>Eureka：Eureka是Spring Cloud Netflix中的重要组件，主要作用就是做服务注册和发现。2.0遇到性能瓶颈，停止维护，现在已经闭源。</p></li><li><p>Consul：Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。</p></li><li><p>Zookeeper：zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目。</p></li><li><p>Nacos（Spring Cloud Alibaba）</p></li><li><ul><li>Alibaba针对Spring Cloud体系的注册中心</li><li>相对于 Spring Cloud Eureka 来说，Nacos 更强大</li><li>Nacos = Spring Cloud Eureka + Spring Cloud Config + Spring Cloud Bus</li></ul></li></ul><h3 id="2、为什么叫Nacos"><a href="#2、为什么叫Nacos" class="headerlink" title="2、为什么叫Nacos"></a>2、为什么叫Nacos</h3><ul><li><p>前四个字母分别为 Naming 和 Configuration 的前两个字母，最后的s为Service</p></li><li><ul><li>Dynamic Naming and Configuration Service</li></ul></li><li><p>Nacos就是：注册中心 + 配置中心的组合</p></li><li><ul><li>Spring Cloud Alibaba Nacos = SpringCloudEureka + SpringCloudConfig +SpringCloudBus</li></ul></li></ul><h3 id="3、Nacos下载和安装"><a href="#3、Nacos下载和安装" class="headerlink" title="3、Nacos下载和安装"></a>3、Nacos下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>下载版本：nacos-server-1.1.4.zip 或 nacos-server-1.1.4.tar.gz，解压任意目录即可</p><h3 id="4、启动Nacos"><a href="#4、启动Nacos" class="headerlink" title="4、启动Nacos"></a>4、启动Nacos</h3><p>- Windows</p><p>启动：双击bin/startup.cmd运行文件</p><p>访问：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><p>- Linux/Unix/Mac</p><p>启动命令(standalone代表着单机模式运行，非集群模式)</p><p>启动命令：sh startup.sh -m standalone</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Nacos客户端的pom依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加服务配置信息"><a href="#2、添加服务配置信息" class="headerlink" title="2、添加服务配置信息"></a>2、添加服务配置信息</h3><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><p>接下来要起一个名字，这样才能知道这个服务在配置中心叫什么</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">gulimall-coupon</span></code></pre><h3 id="3、添加Nacos客户端注解"><a href="#3、添加Nacos客户端注解" class="headerlink" title="3、添加Nacos客户端注解"></a>3、添加Nacos客户端注解</h3><p>在客户端微服务启动类中添加注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span>   <span class="hljs-comment">//开启服务注册发现，这个注解可加可不加</span></code></pre><h3 id="4、启动客户端微服务"><a href="#4、启动客户端微服务" class="headerlink" title="4、启动客户端微服务"></a>4、启动客户端微服务</h3><p>启动注册中心，启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><p><img src="https://img2.jimu98.cn/blog/20200723155043.png" srcset="/img/loading.gif" alt="image-20200723155043496"></p><h2 id="基于OpenFeign的服务调用"><a href="#基于OpenFeign的服务调用" class="headerlink" title="基于OpenFeign的服务调用"></a>基于OpenFeign的服务调用</h2><h3 id="一、OpenFeign是什么"><a href="#一、OpenFeign是什么" class="headerlink" title="一、OpenFeign是什么"></a>一、OpenFeign是什么</h3><p>说起这个，还得先知道Feign是什么，Feign是一个声明式的Http客户端，它的目的就是让远程调用更加简单，Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数，格式，地址等信息</p><p>OpenFeign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。</p><p>Nacos很好的兼容了OpenFeign， OpenFeign默认集成了 Ribbon， 所以在Nacos下使用OpenFeign默认就实现了负载均衡的效果。</p><h3 id="二、OpenFeign的引入"><a href="#二、OpenFeign的引入" class="headerlink" title="二、OpenFeign的引入"></a>二、OpenFeign的引入</h3><h4 id="1、引入依赖-1"><a href="#1、引入依赖-1" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>service模块中配置OpenFeign的pom依赖（实际是在服务消费者端需要OpenFeign的依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务调用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、启动类添加注解"><a href="#2、启动类添加注解" class="headerlink" title="2、启动类添加注解"></a>2、启动类添加注解</h4><p>在消费者service_edu的启动类添加如下注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span>或者<span class="hljs-meta">@EnableFeignClients</span>(basePackages = <span class="hljs-string">"cn.jimu98.gulimall.member.feign"</span>)</code></pre><h3 id="三、OpenFeign的使用"><a href="#三、OpenFeign的使用" class="headerlink" title="三、OpenFeign的使用"></a>三、OpenFeign的使用</h3><h4 id="1、oss微服务中创建测试api"><a href="#1、oss微服务中创建测试api" class="headerlink" title="1、oss微服务中创建测试api"></a>1、oss微服务中创建测试api</h4><p>服务的生产者的FileController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test() &#123;    <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h4 id="2、edu微服务中创建远程调用接口"><a href="#2、edu微服务中创建远程调用接口" class="headerlink" title="2、edu微服务中创建远程调用接口"></a>2、edu微服务中创建远程调用接口</h4><p>服务消费者中创建feign包，创建如下接口：</p><p>该接口首先写上注解</p><p>@FeignClient(“service-oss”)  表示调用哪个微服务</p><p>然后里面写上具体的方法（该方法去直接复制生产者Controller复制即可，但是要注意全地址，包括类注解地址）</p><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign;<span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(<span class="hljs-meta-string">"service-oss"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/admin/oss/file/test"</span>)</span>    R test();&#125;</code></pre><h4 id="3、调用远程方法"><a href="#3、调用远程方法" class="headerlink" title="3、调用远程方法"></a>3、调用远程方法</h4><p>服务消费者中的TeacherController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span>private OssFileService ossFileService;<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">"测试服务调用"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test()&#123;    <span class="hljs-selector-tag">ossFileService</span><span class="hljs-selector-class">.test</span>();    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h3 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h3><h4 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h4><table><thead><tr><th>策略名</th><th>策略描述</th></tr></thead><tbody><tr><td>BestAvailableRule</td><td>选择一个最小的并发请求的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）</td></tr><tr><td>WeightedResponseTimeRule</td><td>根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</td></tr><tr><td>RetryRule</td><td>对选定的负载均衡策略机上重试机制。</td></tr><tr><td>RoundRobinRule</td><td>轮询选择server</td></tr><tr><td>RandomRule</td><td>随机选择一个server</td></tr><tr><td>ZoneAvoidanceRule</td><td>综合判断server所在区域的性能和server的可用性选择server</td></tr></tbody></table><p>配置负载均衡策略的方式：</p><pre><code class="hljs yaml"><span class="hljs-attr">service-product:</span> <span class="hljs-comment"># 调用的提供者的名称 </span>  <span class="hljs-attr">ribbon:</span>     <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span></code></pre><h3 id="五、OpenFeign的超时控制"><a href="#五、OpenFeign的超时控制" class="headerlink" title="五、OpenFeign的超时控制"></a>五、OpenFeign的超时控制</h3><h4 id="1、模拟长流程业务"><a href="#1、模拟长流程业务" class="headerlink" title="1、模拟长流程业务"></a>1、模拟长流程业务</h4><p>修改oss服务FileController的test方法，添加sleep 3秒：</p><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    log.info(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h4 id="2、远程调用测试"><a href="#2、远程调用测试" class="headerlink" title="2、远程调用测试"></a>2、远程调用测试</h4><p>上面的程序在测试时会出现远程调用超时错误。如下：因为OpenFeign默认等待1秒钟，否则超时报错</p><p>重试规则：每隔一秒发起重试</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 同一实例最大重试次数，不包括首次调用，默认0</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 重试其他实例的最大重试次数，不包括首次所选的server，默认1</span></code></pre><h4 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h4><p>application.yml文件中配置ribbon的超时时间（因为OpenFeing的底层即是对ribbon的封装）</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span></code></pre><h3 id="六、OpenFeign日志"><a href="#六、OpenFeign日志" class="headerlink" title="六、OpenFeign日志"></a>六、OpenFeign日志</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>OpenFeign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解OpenFeign中Http请求的细节。即对OpenFeign远程接口调用的情况进行监控和日志输出。</p><h4 id="2、日志级别"><a href="#2、日志级别" class="headerlink" title="2、日志级别"></a>2、日志级别</h4><ul><li>NONE：默认级别，不显示日志</li><li>BASIC：仅记录请求方法、URL、响应状态及执行时间</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应头信息</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应正文及元数据信息</li></ul><h4 id="3、配置日志bean"><a href="#3、配置日志bean" class="headerlink" title="3、配置日志bean"></a>3、配置日志bean</h4><p>在service_edu中创建配置文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.config</span>;<span class="hljs-keyword">@Configuration</span>public class OpenFeignConfig &#123;    <span class="hljs-keyword">@Bean</span>    Logger.Level feignLoggerLevel()&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Logger</span><span class="hljs-selector-class">.Level</span><span class="hljs-selector-class">.FULL</span>;    &#125;&#125;</code></pre><h4 id="4、开启日志"><a href="#4、开启日志" class="headerlink" title="4、开启日志"></a>4、开启日志</h4><p>在service_edu中，application.yml中指定监控的接口，以及日志级别</p><pre><code class="hljs css"><span class="hljs-selector-tag">logging</span>:  <span class="hljs-selector-tag">level</span>:    <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.feign</span><span class="hljs-selector-class">.OssFileService</span>: <span class="hljs-selector-tag">debug</span> #以什么级别监控哪个接口</code></pre><h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><h3 id="首先导入依赖"><a href="#首先导入依赖" class="headerlink" title="首先导入依赖"></a>首先导入依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置中心来做配置管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="新建bootstrap-yml-配置文件中配置Nacos-Config元数据"><a href="#新建bootstrap-yml-配置文件中配置Nacos-Config元数据" class="headerlink" title="新建bootstrap.yml 配置文件中配置Nacos Config元数据"></a>新建bootstrap.yml 配置文件中配置Nacos Config元数据</h3><blockquote><p>你既然要获取配置，那说明你上来根本没有配置，所以你得创建一个优先级更高的配置</p><p>来指定配置中心的地址</p><p>然后动态获取配置文件</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-sms</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">config:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos中心地址</span>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式，如果是properties文件则不用配置此项</span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.name1&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.age&#125;"</span>)<span class="hljs-keyword">private</span> String age;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"name"</span>, name+<span class="hljs-string">" ..."</span>).put(<span class="hljs-string">"age"</span>, age);&#125;</code></pre><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>public（保留空间）默认新增的所有配置都在public空间</p><p>开发，测试，生产：可能有不同的配置，这时候就可以创建不同的命名空间</p><blockquote><p>你可以创建不同的命名空间，然后创建配置的时候选择不同的命名空间</p><p>然后修改bootstrap文件，spring.cloud.nacos.config.namespace=xxxx;(id编号)</p></blockquote><h3 id="配置集"><a href="#配置集" class="headerlink" title="配置集"></a>配置集</h3><p>所有配置的集合</p><p>配置集ID：类似文件名</p><p>​    Data ID：</p><blockquote><p>使用spring.cloud.nacos.config.group=1111  //切换不同的组</p></blockquote><p>加载多个配置集</p><blockquote><p>spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml</p><p>spring.cloud.nacos.config.ext-config[0].group=dev</p><p>spring.cloud.nacos.config.ext-config[0].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml</p><p>spring.cloud.nacos.config.ext-config[1].group=dev</p><p>spring.cloud.nacos.config.ext-config[1].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[2].data-id=other.yml</p><p>spring.cloud.nacos.config.ext-config[2].group=dev</p><p>spring.cloud.nacos.config.ext-config[2].refresh=true  //配置是否自动刷新</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Nacos</tag>
      
      <tag>服务注册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端项目开发流程</title>
    <link href="/posts/52461/"/>
    <url>/posts/52461/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端项目开发流程"><a href="#【项目创建流程】前端项目开发流程" class="headerlink" title="【项目创建流程】前端项目开发流程"></a>【项目创建流程】前端项目开发流程</h1><h2 id="定义路由模块"><a href="#定义路由模块" class="headerlink" title="定义路由模块"></a>定义路由模块</h2><pre><code class="hljs js"><span class="hljs-comment">// 课程管理</span>  &#123;    path: <span class="hljs-string">'/course'</span>,    component: Layout,    redirect: <span class="hljs-string">'/course/list'</span>,    name: <span class="hljs-string">'Course'</span>,    meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程管理'</span> &#125;,    children: [      &#123;        path: <span class="hljs-string">'list'</span>,        name: <span class="hljs-string">'CourseList'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/list'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程列表'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info'</span>,        name: <span class="hljs-string">'CourseInfo'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'发布课程'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info/:id'</span>,        name: <span class="hljs-string">'CourseInfoEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑课程'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;,      &#123;        path: <span class="hljs-string">'chapter/:id'</span>,        name: <span class="hljs-string">'CourseChapterEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑大纲'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;    ]  &#125;,</code></pre><h2 id="定义api模块"><a href="#定义api模块" class="headerlink" title="定义api模块"></a>定义api模块</h2><pre><code class="hljs js"><span class="hljs-comment">// @ 符号在build/webpack.base.conf.js 中配置 表示 'src' 路径</span><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  list() &#123;    <span class="hljs-keyword">return</span> request(&#123;      url: <span class="hljs-string">'/admin/edu/teacher/list'</span>,      method: <span class="hljs-string">'get'</span>    &#125;)  &#125;&#125;</code></pre><h2 id="定义页面组件脚本"><a href="#定义页面组件脚本" class="headerlink" title="定义页面组件脚本"></a>定义页面组件脚本</h2><pre><code class="hljs vu">&lt;script&gt;import teacherApi from &#39;@&#x2F;api&#x2F;teacher&#39;export default &#123;  &#x2F;&#x2F; 定义数据模型  data() &#123;    return &#123;      list: [] &#x2F;&#x2F; 讲师列表    &#125;  &#125;,  &#x2F;&#x2F; 页面渲染成功后获取数据  created() &#123;    this.fetchData()  &#125;,  &#x2F;&#x2F; 定义方法  methods: &#123;    fetchData() &#123;      &#x2F;&#x2F; 调用api      teacherApi.list().then(response &#x3D;&gt; &#123;        this.list &#x3D; response.data.items      &#125;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h2 id="定义页面组件模板"><a href="#定义页面组件模板" class="headerlink" title="定义页面组件模板"></a>定义页面组件模板</h2><pre><code class="hljs vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    讲师列表  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端业务总结</title>
    <link href="/posts/4216/"/>
    <url>/posts/4216/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端业务总结"><a href="#【项目创建流程】前端业务总结" class="headerlink" title="【项目创建流程】前端业务总结"></a>【项目创建流程】前端业务总结</h1><h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>为方便后续开发，建议安装如下插件</p><p><img src="https://img2.jimu98.cn/blog/20200723155141.png" srcset="/img/loading.gif" alt="image-20200723155141680"></p><p><img src="https://img2.jimu98.cn/blog/20200723155224.png" srcset="/img/loading.gif" alt="image-20200723155224355"></p><p><img src="https://img2.jimu98.cn/blog/20200723155212.png" srcset="/img/loading.gif" alt="image-20200723155212540"></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h4><p>浏览器的内核包括两部分核心：</p><ul><li><p>DOM渲染引擎</p></li><li><p>JavaScript解析引擎</p></li><li><ul><li>Chrome浏览器内置V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</li></ul></li></ul><h4 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h4><p>脱离浏览器环境也可以运行JavaScript，只要有JavaScript引擎就可以。</p><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境：即Node.js内置了Chrome的V8 引擎，可以在Node.js环境中直接运行JavaScript程序。</p><ul><li><p>在Node.js中写JavaScript和在Chrome浏览器中写JavaScript<strong>基本</strong>没有什么不一样。哪里不一样呢？</p></li><li><ul><li>Node.js没有浏览器API，即document，window的等。</li><li>加了许多Node.js 专属API，例如文件系统，进程，http功能。</li></ul></li></ul><h4 id="Node-js有什么用"><a href="#Node-js有什么用" class="headerlink" title="Node.js有什么用"></a>Node.js有什么用</h4><ul><li><p>如果你想开发类似JavaWeb的简单的后端程序，那么学习Node.js是一个非常好的选择。</p></li><li><p>如果你想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p></li><li><ul><li>通常他会被用来作一个BFF层，即 Backend For Frontend（服务于前端的后端），通俗的说是一个专门用于为前端业务提供数据的后端程序</li></ul></li></ul><h4 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h4><h5 id="BFF-解决什么问题"><a href="#BFF-解决什么问题" class="headerlink" title="BFF 解决什么问题"></a>BFF 解决什么问题</h5><p>一个前端页面向 Service A、Service B 以及 Service C发送请求，不同的微服务返回的值用于渲染页面中不同的组件。此时，每次访问该页面都需要发送 3 个请求。我们需要一个服务来聚合Service A、Service B 以及 Service C响应的数据，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF0_2.png" srcset="/img/loading.gif" alt="img"></p><p>手机、平板端、PC机等用户终端都需要向每个Service，例如Service A发送请求。对于同一个功能，不同的终端需要的数据格式和内容会有不同。此时 Service A 的一个接口，不能同时满足三个客户端的不同需求。我们可以在Service A中开发三个接口，也可以增加一个数据裁剪服务，将数据按照不同终端的不同要求进行裁剪，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF1_2.png" srcset="/img/loading.gif" alt="img"></p><p>BFF层的作用是让前端有能力自由组装后台数据，减少大量的业务沟通成本，加快业务的迭代速度。无论是数据聚合还是数据剪裁，这类程序的特点是不需要太强大的服务器运算能力，但是对程序的灵活性有较高的要求，这两个特点都正好和Node.js的优势相吻合。</p><h5 id="什么是BFF"><a href="#什么是BFF" class="headerlink" title="什么是BFF"></a>什么是BFF</h5><p>用户体验适配器</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击安装 node-v10.14.2-x64.msi</p><blockquote><p>查看版本 node -v</p></blockquote><h3 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h3><p>在为 AngularJS 工作之后，Vue 的作者尤雨溪开发出了这一框架。他声称自己的思路是提取 Angular 中为自己所喜欢的部分，构建出一款相当轻量的框架。Vue 最早发布于 2014 年 2 月。作者在 Hacker News、Echo JS 与 Reddit 的 javascript 版块发布了最早的版本。一天之内，Vue 就登上了这三个网站的首页。Vue 是 Github 上最受欢迎的开源项目之一。同时，在 JavaScript 框架/函数库中，Vue 所获得的星标数已超过 React，并高于 Backbone.js、Angular 2、jQuery 等项目。</p><p>Vue.js 是一款流行的 JavaScript 前端框架，目的是简化 Web 开发。Vue 所关注的核心是 MVC 模式中的视图层，同时，它也能方便地获取数据更新，实现视图与模型的交互。</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是独立于vue的一个项目，可以用于浏览器和node.js中发送ajax请求</p><h3 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h3><h4 id="1、引入脚本库"><a href="#1、引入脚本库" class="headerlink" title="1、引入脚本库"></a>1、引入脚本库</h4><p><strong>在axios_pro文件夹中引入：</strong>element-ui\lib</p><p><img src="http://img1.jimu98.cn//blog/49b60e78-20d8-4928-a8b6-0b2250de4a84.png" srcset="/img/loading.gif" alt="img"></p><h4 id="2、引入css"><a href="#2、引入css" class="headerlink" title="2、引入css"></a>2、引入css</h4><p>在axios.html 的head中引入css</p><pre><code class="hljs js">&lt;!-- <span class="hljs-keyword">import</span> CSS --&gt;&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"element-ui/lib/theme-chalk/index.css"</span>&gt;</code></pre><h4 id="3、引入js"><a href="#3、引入js" class="headerlink" title="3、引入js"></a>3、引入js</h4><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"element-ui/lib/index.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h4 id="4、渲染讲师列表"><a href="#4、渲染讲师列表" class="headerlink" title="4、渲染讲师列表"></a>4、渲染讲师列表</h4><p>注意：项目中的版本是2.4，参考对应版本的文档</p><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;el-button&gt;添加&lt;&#x2F;el-button&gt;    &lt;i class&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;i&gt;    &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;搜索&lt;&#x2F;el-button&gt;    &lt;el-table              :data&#x3D;&quot;teacherList&quot;              stripe              border              style&#x3D;&quot;width: 100%&quot;&gt;        &lt;el-table-column              type&#x3D;&quot;selection&quot;              width&#x3D;&quot;55&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;name&quot;              label&#x3D;&quot;姓名&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;gmtCreate&quot;              label&#x3D;&quot;入驻日期&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              label&#x3D;&quot;级别&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;                &#123;&#123; scope.row.level &#x3D;&#x3D;&#x3D; 1?&#39;高级讲师&#39;:&#39;首席讲师&#39; &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;&lt;&#x2F;div&gt;</code></pre><h3 id="NPM包管理器"><a href="#NPM包管理器" class="headerlink" title="NPM包管理器"></a>NPM包管理器</h3><h4 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h4><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 。</p><pre><code class="hljs coffeescript"><span class="hljs-comment">#在命令提示符输入 npm -v 可查看当前npm版本</span><span class="hljs-built_in">npm</span> -v</code></pre><h4 id="1、项目初始化"><a href="#1、项目初始化" class="headerlink" title="1、项目初始化"></a><strong>1、项目初始化</strong></h4><pre><code class="hljs vala"><span class="hljs-meta">#建立一个空文件夹，在命令提示符进入该文件夹  执行命令初始化</span>npm init<span class="hljs-meta">#按照提示输入相关信息，如果是用默认值则直接回车即可。</span><span class="hljs-meta">#name: 项目名称</span><span class="hljs-meta">#version: 项目版本号</span><span class="hljs-meta">#description: 项目描述</span><span class="hljs-meta">#keywords: &#123;Array&#125;关键词，便于用户搜索到我们的项目</span><span class="hljs-meta">#最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml</span><span class="hljs-meta">#我们之后也可以根据需要进行修改。</span></code></pre><pre><code class="hljs coffeescript"><span class="hljs-comment">#如果想直接生成 package.json 文件，那么可以使用命令</span><span class="hljs-built_in">npm</span> init -y</code></pre><h4 id="2、修改npm镜像"><a href="#2、修改npm镜像" class="headerlink" title="2、修改npm镜像"></a><strong>2、修改npm镜像</strong></h4><p>NPM官方的管理的包都是从 <a href="http://npmjs.com下载的，但是这个网站在国内速度很慢。" target="_blank" rel="noopener">http://npmjs.com下载的，但是这个网站在国内速度很慢。</a></p><p>这里推荐使用淘宝 NPM 镜像 <a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> ，淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。</p><p><strong>设置镜像地址：</strong></p><pre><code class="hljs tcl"><span class="hljs-comment">#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载</span>npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">registry</span> https://<span class="hljs-keyword">registry</span>.npm.taobao.org <span class="hljs-comment">#查看npm配置信息</span>npm config <span class="hljs-keyword">list</span></code></pre><h4 id="3、npm-install命令的使用"><a href="#3、npm-install命令的使用" class="headerlink" title="3、npm install命令的使用"></a><strong>3、npm install命令的使用</strong></h4><p>基本命令</p><pre><code class="hljs vala"><span class="hljs-meta">#使用 npm install 安装依赖包的最新版，</span><span class="hljs-meta">#模块安装的位置：项目目录\node_modules</span><span class="hljs-meta">#同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 &lt;dependencies&gt;</span><span class="hljs-meta">#默认参数：--save  简写  -S  将当前依赖保存在dependencies节点下</span>npm install jquery</code></pre><p>下载特定版本的依赖</p><pre><code class="hljs angelscript">#如果安装时想指定特定的版本npm install <span class="hljs-symbol">jquery@</span><span class="hljs-number">2.1</span>.x</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>下载开发依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖</span><span class="hljs-meta">#使用 -D参数将依赖添加到devDependencies节点</span>npm install --save-dev eslint<span class="hljs-meta">#或简写</span>npm i -D eslint</code></pre><p>下载全局依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#全局安装</span><span class="hljs-meta">#Node.js全局安装的npm包和工具的位置：用户目录\AppData\Roaming\npm\node_modules</span><span class="hljs-meta">#一些命令行工具常使用全局安装的方式</span>npm install --global webpack<span class="hljs-meta">#或简写</span>npm install -g webpack</code></pre><p>根据依赖下载安装包</p><pre><code class="hljs cmake"><span class="hljs-comment">#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹</span><span class="hljs-comment">#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本</span>npm <span class="hljs-keyword">install</span> <span class="hljs-comment">#根据package.json中的配置下载依赖，初始化项目</span></code></pre><h4 id="4、其它命令"><a href="#4、其它命令" class="headerlink" title="4、其它命令"></a><strong>4、其它命令</strong></h4><pre><code class="hljs coffeescript"><span class="hljs-comment">#更新包（更新到最新版本）</span><span class="hljs-built_in">npm</span> update 包名<span class="hljs-comment">#全局更新</span><span class="hljs-built_in">npm</span> update -g 包名<span class="hljs-comment">#卸载包</span><span class="hljs-built_in">npm</span> uninstall 包名<span class="hljs-comment">#全局卸载</span><span class="hljs-built_in">npm</span> uninstall -g 包名</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】非业务功能统一处理</title>
    <link href="/posts/3440/"/>
    <url>/posts/3440/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】非业务功能统一处理"><a href="#【项目创建流程】非业务功能统一处理" class="headerlink" title="【项目创建流程】非业务功能统一处理"></a>【项目创建流程】非业务功能统一处理</h1><h2 id="统一返回数据格式"><a href="#统一返回数据格式" class="headerlink" title="统一返回数据格式"></a>统一返回数据格式</h2><p>项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p><p>例如，我们的系统要求返回的基本数据格式如下：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"code"</span>: <span class="hljs-number">20000</span>,  <span class="hljs-attr">"message"</span>: <span class="hljs-string">"成功"</span>,  <span class="hljs-attr">"data"</span>: &#123;    <span class="hljs-attr">"items"</span>: [      &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1"</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"刘德华"</span>,        <span class="hljs-attr">"intro"</span>: <span class="hljs-string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      &#125;    ]  &#125;&#125;</code></pre><h3 id="定义统一返回结果"><a href="#定义统一返回结果" class="headerlink" title="定义统一返回结果"></a>定义统一返回结果</h3><h4 id="创建返回码定义枚举类"><a href="#创建返回码定义枚举类" class="headerlink" title="创建返回码定义枚举类"></a>创建返回码定义枚举类</h4><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ResultCodeEnum &#123;    SUCCESS(<span class="hljs-keyword">true</span>, <span class="hljs-number">20000</span>,<span class="hljs-string">"成功"</span>),    UNKNOWN_REASON(<span class="hljs-keyword">false</span>, <span class="hljs-number">20001</span>, <span class="hljs-string">"未知错误"</span>),    BAD_SQL_GRAMMAR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21001</span>, <span class="hljs-string">"sql语法错误"</span>),    JSON_PARSE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21002</span>, <span class="hljs-string">"json解析异常"</span>),    PARAM_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21003</span>, <span class="hljs-string">"参数不正确"</span>),    FILE_UPLOAD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21004</span>, <span class="hljs-string">"文件上传错误"</span>),    FILE_DELETE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21005</span>, <span class="hljs-string">"文件刪除错误"</span>),    EXCEL_DATA_IMPORT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21006</span>, <span class="hljs-string">"Excel数据导入错误"</span>),    VIDEO_UPLOAD_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22001</span>, <span class="hljs-string">"视频上传至阿里云失败"</span>),    VIDEO_UPLOAD_TOMCAT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22002</span>, <span class="hljs-string">"视频上传至业务服务器失败"</span>),    VIDEO_DELETE_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22003</span>, <span class="hljs-string">"阿里云视频文件删除失败"</span>),    FETCH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22004</span>, <span class="hljs-string">"获取上传地址和凭证失败"</span>),    REFRESH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22005</span>, <span class="hljs-string">"刷新上传地址和凭证失败"</span>),    FETCH_PLAYAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22006</span>, <span class="hljs-string">"获取播放凭证失败"</span>),    URL_ENCODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23001</span>, <span class="hljs-string">"URL编码失败"</span>),    ILLEGAL_CALLBACK_REQUEST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23002</span>, <span class="hljs-string">"非法回调请求"</span>),    FETCH_ACCESSTOKEN_FAILD(<span class="hljs-keyword">false</span>, <span class="hljs-number">23003</span>, <span class="hljs-string">"获取accessToken失败"</span>),    FETCH_USERINFO_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23004</span>, <span class="hljs-string">"获取用户信息失败"</span>),    LOGIN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23005</span>, <span class="hljs-string">"登录失败"</span>),    COMMENT_EMPTY(<span class="hljs-keyword">false</span>, <span class="hljs-number">24006</span>, <span class="hljs-string">"评论内容必须填写"</span>),    PAY_RUN(<span class="hljs-keyword">false</span>, <span class="hljs-number">25000</span>, <span class="hljs-string">"支付中"</span>),    PAY_UNIFIEDORDER_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25001</span>, <span class="hljs-string">"统一下单错误"</span>),    PAY_ORDERQUERY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25002</span>, <span class="hljs-string">"查询支付结果错误"</span>),    ORDER_EXIST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25003</span>, <span class="hljs-string">"课程已购买"</span>),    GATEWAY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">26000</span>, <span class="hljs-string">"服务不能访问"</span>),    CODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28000</span>, <span class="hljs-string">"验证码错误"</span>),    LOGIN_PHONE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28009</span>, <span class="hljs-string">"手机号码不正确"</span>),    LOGIN_MOBILE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28001</span>, <span class="hljs-string">"账号不正确"</span>),    LOGIN_PASSWORD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28008</span>, <span class="hljs-string">"密码不正确"</span>),    LOGIN_DISABLED_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28002</span>, <span class="hljs-string">"该用户已被禁用"</span>),    REGISTER_MOBLE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28003</span>, <span class="hljs-string">"手机号已被注册"</span>),    LOGIN_AUTH(<span class="hljs-keyword">false</span>, <span class="hljs-number">28004</span>, <span class="hljs-string">"需要登录"</span>),    LOGIN_ACL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28005</span>, <span class="hljs-string">"没有权限"</span>),    SMS_SEND_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28006</span>, <span class="hljs-string">"短信发送失败"</span>),    SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28007</span>, <span class="hljs-string">"短信发送过于频繁"</span>);    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String message;    ResultCodeEnum(Boolean success, Integer code, String message) &#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;&#125;</code></pre><h4 id="创建结果类"><a href="#创建结果类" class="headerlink" title="创建结果类"></a>创建结果类</h4><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel</span>(value = <span class="hljs-string">"全局统一返回结果"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">R</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"是否成功"</span>)    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回码"</span>)    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回消息"</span>)    <span class="hljs-keyword">private</span> String message;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回数据"</span>)    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">R</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">ok</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());        r.setCode(ResultCodeEnum.SUCCESS.getCode());        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">error</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());        r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());        r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">setResult</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(resultCodeEnum.getSuccess());        r.setCode(resultCodeEnum.getCode());        r.setMessage(resultCodeEnum.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">success</span><span class="hljs-params">(Boolean success)</span></span>&#123;        <span class="hljs-keyword">this</span>.setSuccess(success);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">message</span><span class="hljs-params">(String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.setMessage(message);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">code</span><span class="hljs-params">(Integer code)</span></span>&#123;        <span class="hljs-keyword">this</span>.setCode(code);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(String key, Object value)</span></span>&#123;        <span class="hljs-keyword">this</span>.data.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;        <span class="hljs-keyword">this</span>.setData(map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;    List&lt;Teacher&gt; list = teacherService.list();    <span class="hljs-keyword">return</span> R.ok().data(<span class="hljs-string">"items"</span>, list).message(<span class="hljs-string">"获取讲师列表成功"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"remove/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">removeById</span><span class="hljs-params">(@PathVariable String id)</span></span>&#123;    <span class="hljs-keyword">boolean</span> result = teacherService.removeById(id);    <span class="hljs-keyword">if</span>(result)&#123;        <span class="hljs-keyword">return</span> R.ok().message(<span class="hljs-string">"删除成功"</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> R.error().message(<span class="hljs-string">"数据不存在"</span>);    &#125;&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="Controller创建分页方法"><a href="#Controller创建分页方法" class="headerlink" title="Controller创建分页方法"></a>Controller创建分页方法</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list/&#123;page&#125;/&#123;limit&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listPage</span><span class="hljs-params">(@ApiParam(value = <span class="hljs-string">"当前页码"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long page,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(value = <span class="hljs-string">"每页记录数"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long limit,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(<span class="hljs-string">"讲师列表查询对象"</span>)</span> TeacherQueryVo teacherQueryVo)</span>&#123;    IPage&lt;Teacher&gt; pageModel = teacherService.selectPage(page, limit, teacherQueryVo);    List&lt;Teacher&gt; records = pageModel.getRecords();    <span class="hljs-keyword">long</span> total = pageModel.getTotal();    <span class="hljs-keyword">return</span>  R.ok().data(<span class="hljs-string">"total"</span>, total).data(<span class="hljs-string">"rows"</span>, records);&#125;</code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><blockquote><p>在我们平时写项目的时候，一般查询数据字段可能只需要三四个，但是数据库里面有十多个，甚至多数据库，多表查询</p><p>这时候就要根据返回类型创建Vo对象</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherQueryVo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;        <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer level;    <span class="hljs-keyword">private</span> String joinDateBegin;    <span class="hljs-keyword">private</span> String joinDateEnd;&#125;</code></pre><blockquote><p>创建完实体类，就需要写条件查询了</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.service.impl;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TeacherMapper</span>, <span class="hljs-title">Teacher</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TeacherService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;Teacher&gt; <span class="hljs-title">selectPage</span><span class="hljs-params">(Long page, Long limit, TeacherQueryVo teacherQueryVo)</span> </span>&#123;                Page&lt;Teacher&gt; pageParam = <span class="hljs-keyword">new</span> Page&lt;&gt;(page, limit);                QueryWrapper&lt;Teacher&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();        queryWrapper.orderByAsc(<span class="hljs-string">"sort"</span>);        <span class="hljs-keyword">if</span> (teacherQueryVo == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);        &#125;        String name = teacherQueryVo.getName();        Integer level = teacherQueryVo.getLevel();        String begin = teacherQueryVo.getJoinDateBegin();        String end = teacherQueryVo.getJoinDateEnd();        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(name)) &#123;            <span class="hljs-comment">//左%会使索引失效</span>            queryWrapper.likeRight(<span class="hljs-string">"name"</span>, name);        &#125;        <span class="hljs-keyword">if</span> (level != <span class="hljs-keyword">null</span>) &#123;            queryWrapper.eq(<span class="hljs-string">"level"</span>, level);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(begin)) &#123;            queryWrapper.ge(<span class="hljs-string">"join_date"</span>, begin);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(end)) &#123;            queryWrapper.le(<span class="hljs-string">"join_date"</span>, end);        &#125;        <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);    &#125;&#125;</code></pre><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理</p><h3 id="创建统一异常处理器"><a href="#创建统一异常处理器" class="headerlink" title="创建统一异常处理器"></a>创建统一异常处理器</h3><blockquote><p>一般创建在service-base中handler包中，</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> R.error();    &#125;&#125;</code></pre><blockquote><p>例如上面就可以捕获所有异常</p><p>但是在实际项目中，可以通过抛出指定异常，然后捕获自定义异常来返回异常信息</p></blockquote><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h2 id="1、创建自定义异常类"><a href="#1、创建自定义异常类" class="headerlink" title="1、创建自定义异常类"></a><strong>1、创建自定义异常类</strong></h2><p>service-base模块中创建cn.jimu98.guli.service.base.exception包，</p><p>创建GuliException.java通用异常类 继承 RuntimeException，RuntimeException 对代码没有侵入性</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuliException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-comment">//状态码</span>    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接受状态码和消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(Integer code, String message)</span> </span>&#123;        <span class="hljs-keyword">super</span>(message);        <span class="hljs-keyword">this</span>.code=code;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接收枚举类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resultCodeEnum</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCodeEnum.getMessage());        <span class="hljs-keyword">this</span>.code = resultCodeEnum.getCode();    &#125;&#125;</code></pre><h2 id="2、添加异常处理方法"><a href="#2、添加异常处理方法" class="headerlink" title="2、添加异常处理方法"></a>2、添加异常处理方法</h2><p>GlobalExceptionHandler.java中添加</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(GuliException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">GuliException</span> <span class="hljs-title">e</span>)</span>&#123;    log.error(ExceptionUtils.getMessage(e));    <span class="hljs-keyword">return</span> R.error().message(e.getMessage()).code(e.getCode());&#125;</code></pre><h2 id="3、修改FileController"><a href="#3、修改FileController" class="headerlink" title="3、修改FileController"></a>3、修改FileController</h2><p>在类上添加日志注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j</code></pre><p>业务中需要的位置抛出GuliException</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">upload</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        ......    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;        log.error(ExceptionUtils.getMessage(e));        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GuliException(ResultCodeEnum.FILE_UPLOAD_ERROR);    &#125;&#125;</code></pre><h2 id="4、打印完整的异常信息"><a href="#4、打印完整的异常信息" class="headerlink" title="4、打印完整的异常信息"></a>4、打印完整的异常信息</h2><p>GuliException类中重写toString方法</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"GuliException&#123;"</span> +        <span class="hljs-string">"code="</span> + code +        <span class="hljs-string">", message="</span> + <span class="hljs-keyword">this</span>.getMessage() +        <span class="hljs-string">'&#125;'</span>;&#125;</code></pre><h2 id="三、前端错误处理"><a href="#三、前端错误处理" class="headerlink" title="三、前端错误处理"></a>三、前端错误处理</h2><h2 id="1、统一异常错误处理"><a href="#1、统一异常错误处理" class="headerlink" title="1、统一异常错误处理"></a>1、统一异常错误处理</h2><pre><code class="hljs stylus"><span class="hljs-comment">// 上传成功回调</span><span class="hljs-function"><span class="hljs-title">handleAvatarSuccess</span><span class="hljs-params">(res, file)</span></span> &#123;    console.log(res)    <span class="hljs-keyword">if</span> (res.success) &#123;        <span class="hljs-comment">// console.log(res)</span>        this<span class="hljs-selector-class">.teacher</span><span class="hljs-selector-class">.avatar</span> = res<span class="hljs-selector-class">.data</span>.url        <span class="hljs-comment">// 强制重新渲染</span>        this.<span class="hljs-variable">$forceUpdate</span>()    &#125; <span class="hljs-keyword">else</span> &#123;        this.<span class="hljs-variable">$message</span>.error(<span class="hljs-string">'上传失败 （非20000）'</span>)    &#125;&#125;,</code></pre><h2 id="2、http异常错误处理"><a href="#2、http异常错误处理" class="headerlink" title="2、http异常错误处理"></a>2、http异常错误处理</h2><p>注册事件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span> <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"handleAvatarError"</span>&gt;</span></code></pre><p>事件函数</p><pre><code class="hljs js"><span class="hljs-comment">// 错误处理</span>handleAvatarError() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>)    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'上传失败（http失败）'</span>)&#125;</code></pre><h2 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h2><h3 id="配置日志级别"><a href="#配置日志级别" class="headerlink" title="配置日志级别"></a>配置日志级别</h3><p>日志记录器（Logger）的行为是分等级的。如下表所示：</p><p>分为：FATAL、ERROR、WARN、INFO、DEBUG</p><p>默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别</p><pre><code class="hljs yaml"><span class="hljs-comment"># 设置日志级别</span><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">root:</span> <span class="hljs-string">ERROR</span></code></pre><p>这种方式能将ERROR级别以及以上级别的日志打印在控制台上</p><h3 id="Logback日志"><a href="#Logback日志" class="headerlink" title="Logback日志"></a>Logback日志</h3><p>spring boot内部使用Logback作为日志实现的框架。</p><p>Logback和log4j非常相似，如果你对log4j很熟悉，那对logback很快就会得心应手。</p><p>logback相对于log4j的一些优点：<a href="https://blog.csdn.net/caisini_vc/article/details/48551287" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/48551287</a></p><h4 id="配置logback日志"><a href="#配置logback日志" class="headerlink" title="配置logback日志"></a>配置logback日志</h4><p><strong>删除application.yml中的日志配置</strong></p><p><strong>安装idea彩色日志插件：grep console</strong></p><p>resources 中创建 logback-spring.xml （默认日志的名字，必须是这个名字）</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>  <span class="hljs-attr">scan</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">"10 seconds"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>logback<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"log.path"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"D:/project/helen/guli_log/edu"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--控制台日志格式：彩色日志--&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-comment">&lt;!-- boldMagenta:粗红--&gt;</span>    <span class="hljs-comment">&lt;!-- cyan:青色 --&gt;</span>    <span class="hljs-comment">&lt;!-- white:白色 --&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--文件日志格式--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss&#125; |%-5level |%thread |%file:%line |%logger |%msg%n"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ENCODING"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志级别--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志格式--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志字符集--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"INFO_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志过滤器：此日志文件只记录INFO级别的--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"WARN_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录WARN级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ERROR_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录ERROR级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--开发环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>        <span class="hljs-comment">&lt;!--可以灵活设置此处，从而控制日志的输出--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"WARN_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!--生产环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pro"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"ERROR"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h4 id="用日志记录器记录错误日志"><a href="#用日志记录器记录错误日志" class="headerlink" title="用日志记录器记录错误日志"></a>用日志记录器记录错误日志</h4><blockquote><p>类上添加注解@Slf4j</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>统一处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】配置Swagger</title>
    <link href="/posts/50332/"/>
    <url>/posts/50332/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】配置Swagger"><a href="#【项目创建流程】配置Swagger" class="headerlink" title="【项目创建流程】配置Swagger"></a>【项目创建流程】配置Swagger</h1><h2 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h2><p><a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>前后端分离开发模式中，api文档是最好的沟通方式。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)可测性 (直接在接口文档上进行测试，以方便理解业务)</p><ul><li>前端工程师编写接口文档（使用swagger2编辑器或其他接口生成工具）</li><li>交给后端工程师</li><li>根据swagger文档编写后端接口</li><li>最终根据生成的swagger文件进行接口联调</li></ul><h2 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>这个可以配置在common中  进行代码复用</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--swagger--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="创建Swagger2配置文件"><a href="#创建Swagger2配置文件" class="headerlink" title="创建Swagger2配置文件"></a>创建Swagger2配置文件</h3><blockquote><p>在service_base中创建Swagger2Config</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">webApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"webApi"</span>)                .apiInfo(webApiInfo())                .select()                <span class="hljs-comment">//只显示api路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/api/.*"</span>)))                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">adminApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"adminApi"</span>)                .apiInfo(adminApiInfo())                .select()                <span class="hljs-comment">//只显示admin路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/admin/.*"</span>)))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">webApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"网站前台-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了网站微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">adminApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"后台管理系统-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了后台管理系统微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p><a href="http://localhost:8101/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8101/swagger-ui.html</a>  进行测试</p></blockquote><h3 id="定义接口说明和参数说明"><a href="#定义接口说明和参数说明" class="headerlink" title="定义接口说明和参数说明"></a>定义接口说明和参数说明</h3><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>Swagger2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】普通接口开发</title>
    <link href="/posts/52884/"/>
    <url>/posts/52884/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】普通接口开发"><a href="#【项目创建流程】普通接口开发" class="headerlink" title="【项目创建流程】普通接口开发"></a>【项目创建流程】普通接口开发</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><blockquote><p>创建的时候选择utf8mb4  urf8修改了兼容四字节的字符，解决某些汉字出现乱码问题</p><p>utf8_general_ci: 校对速度快，但准确度稍差。</p><p>utf8_unicode_ci: 准确度高，但校对速度稍慢。</p><p>若数据库中有德语、法语或者俄语需求，需使用utf8_unicode_ci。其他情况用utf8_general_ci即可。</p></blockquote><h2 id="建Maven"><a href="#建Maven" class="headerlink" title="建Maven"></a>建Maven</h2><h2 id="改POM"><a href="#改POM" class="headerlink" title="改POM"></a>改POM</h2><h2 id="写YML"><a href="#写YML" class="headerlink" title="写YML"></a>写YML</h2><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8140</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-cms</span> <span class="hljs-comment"># 服务名</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>          <span class="hljs-attr">datasource:</span> <span class="hljs-comment"># mysql数据库连接</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/guli_cms?serverTimezone=GMT%2B8</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">jackson:</span> <span class="hljs-comment">#返回json的全局时间格式</span>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment">#mybatis日志</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:cn/jimu98/guli/service/cms/mapper/xml/*.xml</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h2 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h2><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ComponentScan</span>(&#123;<span class="hljs-string">"cn.jimu98.guli"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceEduApplication</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceEduApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h2><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span> <span class="hljs-comment">//解决跨域问题</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/edu/teacher"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TeacherService teacherService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> teacherService.list();    &#125;&#125;</code></pre><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><blockquote><p>项目经理不让用就自己写吧。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】MyBatisPlas流程</title>
    <link href="/posts/6764/"/>
    <url>/posts/6764/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】MyBatisPlas流程"><a href="#【项目创建流程】MyBatisPlas流程" class="headerlink" title="【项目创建流程】MyBatisPlas流程"></a>【项目创建流程】MyBatisPlas流程</h1><h2 id="MP简介"><a href="#MP简介" class="headerlink" title="MP简介"></a>MP简介</h2><p><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><ul><li><p>润物无声  </p></li><li><ul><li>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li></ul></li><li><p>效率至上</p></li><li><ul><li>只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。</li></ul></li><li><p>丰富功能</p></li><li><ul><li>热加载、代码生成、分页、性能分析等功能一应俱全。</li></ul></li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><h3 id="创建代码生成器"><a href="#创建代码生成器" class="headerlink" title="创建代码生成器"></a>创建代码生成器</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//String prefix = "dbxxx_";</span>        String moduleName = <span class="hljs-string">"statistics"</span>;        <span class="hljs-comment">// 1、创建代码生成器</span>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();        <span class="hljs-comment">// 2、全局配置</span>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">"user.dir"</span>);        gc.setOutputDir(projectPath + <span class="hljs-string">"/src/main/java"</span>);        gc.setAuthor(<span class="hljs-string">"jimu98"</span>);        gc.setOpen(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//生成后是否打开资源管理器</span><span class="hljs-comment">//        gc.setFileOverride(false); //重新生成时文件是否覆盖</span>        gc.setServiceName(<span class="hljs-string">"%sService"</span>);<span class="hljs-comment">//去掉Service接口的首字母I</span>        gc.setIdType(IdType.ASSIGN_ID); <span class="hljs-comment">//主键策略</span>        gc.setDateType(DateType.ONLY_DATE);<span class="hljs-comment">//定义生成的实体类中日期类型</span>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启Swagger2模式</span>        mpg.setGlobalConfig(gc);        <span class="hljs-comment">// 3、数据源配置</span>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();        dsc.setUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/"</span>  + <span class="hljs-string">"guli_"</span> + moduleName + <span class="hljs-string">"?serverTimezone=GMT%2B8"</span>);        dsc.setDriverName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);        dsc.setUsername(<span class="hljs-string">"root"</span>);        dsc.setPassword(<span class="hljs-string">""</span>);        dsc.setDbType(DbType.MYSQL);        mpg.setDataSource(dsc);        <span class="hljs-comment">// 4、包配置</span>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();        pc.setModuleName(moduleName); <span class="hljs-comment">//模块名</span>        pc.setParent(<span class="hljs-string">"cn.jimu98.guli.service"</span>);        pc.setController(<span class="hljs-string">"controller"</span>);        pc.setEntity(<span class="hljs-string">"entity"</span>);        pc.setService(<span class="hljs-string">"service"</span>);        pc.setMapper(<span class="hljs-string">"mapper"</span>);        mpg.setPackageInfo(pc);        <span class="hljs-comment">// 5、策略配置</span>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表映射到实体的命名策略</span>        strategy.setTablePrefix(moduleName + <span class="hljs-string">"_"</span>);<span class="hljs-comment">//设置表前缀不生成</span>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表字段映射到实体的命名策略</span>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy.setLogicDeleteFieldName(<span class="hljs-string">"is_deleted"</span>);<span class="hljs-comment">//逻辑删除字段名</span>        strategy.setEntityBooleanColumnRemoveIsPrefix(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//去掉布尔值的is_前缀</span>        <span class="hljs-comment">//自动填充</span>        TableFill gmtCreate = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_create"</span>, FieldFill.INSERT);        TableFill gmtModified = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_modified"</span>, FieldFill.INSERT_UPDATE);        ArrayList&lt;TableFill&gt; tableFills = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        tableFills.add(gmtCreate);        tableFills.add(gmtModified);        strategy.setTableFillList(tableFills);        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//restful api风格控制器</span>        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//url中驼峰转连字符</span>        mpg.setStrategy(strategy);        <span class="hljs-comment">//设置BaseEntity</span>        strategy.setSuperEntityClass(<span class="hljs-string">"cn.jimu98.guli.service.base.model.BaseEntity"</span>);        <span class="hljs-comment">// 填写BaseEntity中的公共字段</span>        strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);        <span class="hljs-comment">// 6、执行</span>        mpg.execute();    &#125;&#125;</code></pre><h3 id="优化代码生成器"><a href="#优化代码生成器" class="headerlink" title="优化代码生成器"></a>优化代码生成器</h3><blockquote><p>在真实情况下，每个表都会有三字段，ID，创建时间，更新时间</p><p>所以，这部分实体类可以抽取出来</p><p>一般我们在service_base中创建BaseEntity</p></blockquote><h4 id="首先创建一个基础实体类"><a href="#首先创建一个基础实体类" class="headerlink" title="首先创建一个基础实体类"></a>首先创建一个基础实体类</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.jimu98.service.base.model;<span class="hljs-meta">@Data</span><span class="hljs-meta">@EqualsAndHashCode</span>(callSuper = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@Accessors</span>(chain = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID=<span class="hljs-number">1L</span>;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"讲师ID"</span>)  <span class="hljs-comment">//这个是swagger的注解</span>    <span class="hljs-meta">@TableId</span>(value = <span class="hljs-string">"id"</span>, type = IdType.ASSIGN_ID)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"创建时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT)    <span class="hljs-keyword">private</span> Date gmtCreate;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"更新时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)    <span class="hljs-keyword">private</span> Date gmtModified;&#125;</code></pre><h4 id="然后修改代码生成器中内容"><a href="#然后修改代码生成器中内容" class="headerlink" title="然后修改代码生成器中内容"></a>然后修改代码生成器中内容</h4><pre><code class="hljs java"><span class="hljs-comment">//设置BaseEntity</span>strategy.setSuperEntityClass(<span class="hljs-string">"com.atguigu.guli.service.base.model.BaseEntity"</span>);<span class="hljs-comment">// 填写BaseEntity中的公共字段</span>strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><blockquote><p>@TableId(type = IdType.ASSIGN_ID)</p></blockquote><ul><li>描述：主键注解</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">主键字段名</td></tr><tr><td align="center">type</td><td align="center">Enum</td><td align="center">否</td><td align="center">IdType.NONE</td><td align="center">主键类型</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AUTO</td><td align="center">数据库ID自增</td></tr><tr><td align="center">NONE</td><td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td></tr><tr><td align="center">INPUT</td><td align="center">insert前自行set主键值</td></tr><tr><td align="center">ASSIGN_ID</td><td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td align="center">ASSIGN_UUID</td><td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td></tr><tr><td align="center">ID_WORKER</td><td align="center">分布式全局唯一ID 长整型类型(please use <code>ASSIGN_ID</code>)</td></tr><tr><td align="center">UUID</td><td align="center">32位UUID字符串(please use <code>ASSIGN_UUID</code>)</td></tr><tr><td align="center">ID_WORKER_STR</td><td align="center">分布式全局唯一ID 字符串类型(please use <code>ASSIGN_ID</code>)</td></tr></tbody></table><p>要想影响所有实体的配置，可以设置全局主键配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#全局设置主键生成策略</span><span class="hljs-string">mybatis-plus.global-config.db-config.id-type=auto</span></code></pre><blockquote><p>@TableField  </p></blockquote><ul><li>描述：字段注解(非主键)</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">数据库字段名</td></tr><tr><td align="center">el</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">映射为原生 <code>#{ ... }</code> 逻辑,相当于写在 xml 里的 <code>#{ ... }</code> 部分</td></tr><tr><td align="center">exist</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否为数据库表字段</td></tr><tr><td align="center">condition</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>where</code> 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 <code>% s=#{ %s }</code>,<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java" target="_blank" rel="noopener">参考</a></td></tr><tr><td align="center">update</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>update set</code> 部分注入, 例如：update=”%s+1”：表示更新时会set version=version+1(该属性优先级高于 <code>el</code> 属性)</td></tr><tr><td align="center">insertStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#{columnProperty}&lt;/if&gt;)</code></td></tr><tr><td align="center">updateStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：IGNORED: <code>update table_a set column=#{columnProperty}</code></td></tr><tr><td align="center">whereStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#{columnProperty}&lt;/if&gt;</code></td></tr><tr><td align="center">fill</td><td align="center">Enum</td><td align="center">否</td><td align="center">FieldFill.DEFAULT</td><td align="center">字段自动填充策略</td></tr><tr><td align="center">select</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否进行 select 查询</td></tr><tr><td align="center">keepGlobalFormat</td><td align="center">boolean</td><td align="center">否</td><td align="center">false</td><td align="center">是否保持使用全局的 format 进行处理</td></tr><tr><td align="center">jdbcType</td><td align="center">JdbcType</td><td align="center">否</td><td align="center">JdbcType.UNDEFINED</td><td align="center">JDBC类型 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">typeHandler</td><td align="center">Class&lt;? extends TypeHandler&gt;</td><td align="center">否</td><td align="center">UnknownTypeHandler.class</td><td align="center">类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">numericScale</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">指定小数点后保留的位数</td></tr></tbody></table><blockquote><p>另外这个注解的包可能不会自动引入，有个小BUG，所以需要手动引入一下,其他的就看官方文档吧</p></blockquote><h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><blockquote><p>这个主要是为create_time、update_time进行自动填充</p></blockquote><h4 id="实体类修改"><a href="#实体类修改" class="headerlink" title="实体类修改"></a>实体类修改</h4><p>在实体类（如果前面提取了公共实体类，那么这里操作公共实体类）添加注解@TableField(fill = FieldFill.INSERT)</p><p>FieldFill是一个enum 枚举类型 </p><p>所以create_time设置INSERT  ，update_time设置 INSERT_UPDATE</p><h4 id="实现元对象处理器接口"><a href="#实现元对象处理器接口" class="headerlink" title="实现元对象处理器接口"></a>实现元对象处理器接口</h4><p><strong><code>注意：不要忘记添加 @Component 注解</code></strong></p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start insert fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"createTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start update fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;&#125;</code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h4><pre><code class="hljs java"><span class="hljs-meta">@Version</span><span class="hljs-keyword">private</span> Integer version;</code></pre><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"cn.jimu98.xxx.mapper"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;    &#125;</code></pre><h4 id="注册乐观锁插件"><a href="#注册乐观锁插件" class="headerlink" title="注册乐观锁插件"></a>注册乐观锁插件</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 乐观锁插件</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();&#125;</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页插件</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();&#125;</code></pre><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><h4 id="数据库修改"><a href="#数据库修改" class="headerlink" title="数据库修改"></a>数据库修改</h4><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`deleted`</span> <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span></code></pre><h4 id="实体类修改-1"><a href="#实体类修改-1" class="headerlink" title="实体类修改"></a>实体类修改</h4><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><span class="hljs-keyword">private</span> Integer deleted;</code></pre><h4 id="配置（可选）"><a href="#配置（可选）" class="headerlink" title="配置（可选）"></a>配置（可选）</h4><pre><code class="hljs yaml"><span class="hljs-string">mybatis-plus.global-config.db-config.logic-delete-value=1</span><span class="hljs-string">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span></code></pre><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><table><thead><tr><th><strong>查询方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>setSqlSelect</strong></td><td>设置 SELECT 查询字段</td></tr><tr><td><strong>where</strong></td><td>WHERE 语句，拼接 + WHERE 条件</td></tr><tr><td><strong>and</strong></td><td>AND 语句，拼接 + AND 字段=值</td></tr><tr><td><strong>andNew</strong></td><td>AND 语句，拼接 + AND (字段=值)</td></tr><tr><td><strong>or</strong></td><td>OR 语句，拼接 + OR 字段=值</td></tr><tr><td><strong>orNew</strong></td><td>OR 语句，拼接 + OR (字段=值)</td></tr><tr><td><strong>eq</strong></td><td>等于=</td></tr><tr><td><strong>allEq</strong></td><td>基于 map 内容等于=</td></tr><tr><td><strong>ne</strong></td><td>不等于&lt;&gt;</td></tr><tr><td><strong>gt</strong></td><td>大于&gt;</td></tr><tr><td><strong>ge</strong></td><td>大于等于&gt;=</td></tr><tr><td><strong>lt</strong></td><td>小于&lt;</td></tr><tr><td><strong>le</strong></td><td>小于等于&lt;=</td></tr><tr><td><strong>like</strong></td><td>模糊查询 LIKE</td></tr><tr><td><strong>notLike</strong></td><td>模糊查询 NOT LIKE</td></tr><tr><td><strong>in</strong></td><td>IN 查询</td></tr><tr><td><strong>notIn</strong></td><td>NOT IN 查询</td></tr><tr><td><strong>isNull</strong></td><td>NULL 值查询</td></tr><tr><td><strong>isNotNull</strong></td><td>IS NOT NULL</td></tr><tr><td><strong>groupBy</strong></td><td>分组 GROUP BY</td></tr><tr><td><strong>having</strong></td><td>HAVING 关键词</td></tr><tr><td><strong>orderBy</strong></td><td>排序 ORDER BY</td></tr><tr><td><strong>orderAsc</strong></td><td>ASC 排序 ORDER BY</td></tr><tr><td><strong>orderDesc</strong></td><td>DESC 排序 ORDER BY</td></tr><tr><td><strong>exists</strong></td><td>EXISTS 条件语句</td></tr><tr><td><strong>notExists</strong></td><td>NOT EXISTS 条件语句</td></tr><tr><td><strong>between</strong></td><td>BETWEEN 条件语句</td></tr><tr><td><strong>notBetween</strong></td><td>NOT BETWEEN 条件语句</td></tr><tr><td><strong>addFilter</strong></td><td>自由拼接 SQL</td></tr><tr><td><strong>last</strong></td><td>拼接在最后，例如：last(“LIMIT 1”)</td></tr></tbody></table><p>其他的就看官网吧<a href="https://mp.baomidou.com/guide/wrapper.html#abstractwrapper" target="_blank" rel="noopener">https://mp.baomidou.com/guide/wrapper.html#abstractwrapper</a></p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
      <tag>MyBatis-Plus</tag>
      
      <tag>代码生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】项目框架构建</title>
    <link href="/posts/6900/"/>
    <url>/posts/6900/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】项目框架构建"><a href="#【项目创建流程】项目框架构建" class="headerlink" title="【项目创建流程】项目框架构建"></a>【项目创建流程】项目框架构建</h1><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><blockquote><p>在项目创建初期，应该首先规划一下工程结构</p><p>将各个模块区分开来（根据阿里规范命名）</p><p>重复的功能进行抽离</p><p>pom文件根据范围选择合适的引用地址</p></blockquote><h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><h4 id="删除一些无用的文件"><a href="#删除一些无用的文件" class="headerlink" title="删除一些无用的文件"></a>删除一些无用的文件</h4><h4 id="配置SpringBoot版本"><a href="#配置SpringBoot版本" class="headerlink" title="配置SpringBoot版本"></a>配置SpringBoot版本</h4><h4 id="配置Pom文件依赖版本号"><a href="#配置Pom文件依赖版本号" class="headerlink" title="配置Pom文件依赖版本号"></a>配置Pom文件依赖版本号</h4><p>比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis-plus.version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis-plus.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">velocity.version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">velocity.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">swagger.version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">swagger.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aliyun.oss.version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">aliyun.oss.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jodatime.version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">jodatime.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-fileupload.version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">commons-fileupload.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-io.version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">commons-io.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-lang.version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">commons-lang.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">httpclient.version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">httpclient.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre><h4 id="配置pom依赖"><a href="#配置pom依赖" class="headerlink" title="配置pom依赖"></a>配置pom依赖</h4><blockquote><p>这里不需要真正引入，在子项目中引入</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--Spring Cloud--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--mybatis-plus 持久层--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><h2 id="创建父模块"><a href="#创建父模块" class="headerlink" title="创建父模块"></a>创建父模块</h2><h3 id="创建普通Maven项目即可"><a href="#创建普通Maven项目即可" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h4 id="删除src文件夹"><a href="#删除src文件夹" class="headerlink" title="删除src文件夹"></a>删除src文件夹</h4><h4 id="配置POM"><a href="#配置POM" class="headerlink" title="配置POM"></a>配置POM</h4><blockquote><p>这里一般配置一下lombok mp，swagger之类的 以及子项目复用的依赖</p></blockquote><h2 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h2><h3 id="创建普通Maven项目即可-1"><a href="#创建普通Maven项目即可-1" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h3 id="配置Pom"><a href="#配置Pom" class="headerlink" title="配置Pom"></a>配置Pom</h3><h3 id="改YAM"><a href="#改YAM" class="headerlink" title="改YAM"></a>改YAM</h3><h3 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h3><h3 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h3><blockquote><p>看一下这个业务模块需不需要用代码生成器生成</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】数据库规范</title>
    <link href="/posts/1098/"/>
    <url>/posts/1098/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】数据库规范"><a href="#【项目创建流程】数据库规范" class="headerlink" title="【项目创建流程】数据库规范"></a>【项目创建流程】数据库规范</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h2><blockquote><p>注意，这里要遵循阿里数据库设计规约（参考《阿里巴巴Java开发手册》）</p></blockquote><p>1、库名与应用名称尽量一致</p><p>2、表名、字段名必须使用小写字母或数字，禁止出现数字开头，</p><p>3、表名不使用复数名词</p><p>4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher</p><p>5、表必备三字段：id, gmt_create, gmt_modified</p><p>6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p><p>7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 </p><p>说明：任何字段如果为非负数，必须是 unsigned。</p><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 </p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 </p><p>8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p><p>9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 </p><p>10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>11、唯一索引名为 uk_字段名(unique key)；普通索引名则为 idx_字段名(index)。</p><p>说明：uk_ 即 unique key；idx_ 即 index 的简称</p><p>12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
