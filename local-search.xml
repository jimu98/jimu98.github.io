<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【java总结】Git常用操作</title>
    <link href="/2020/07/31/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/07/31/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】Git常用操作"><a href="#【java总结】Git常用操作" class="headerlink" title="【java总结】Git常用操作"></a>【java总结】Git常用操作</h1><h2 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h2><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>Git 与 SVN 区别点：</p><ul><li><strong>1、Git 是分布式的，SVN 不是</strong>：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li><li><strong>2、Git 把内容按元数据方式存储，而 SVN 是按文件：</strong>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li><li><strong>3、Git 分支和 SVN 的分支不同：</strong>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li><li><strong>4、Git 没有一个全局的版本号，而 SVN 有：</strong>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li><li><strong>5、Git 的内容完整性要优于 SVN：</strong>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ul><p><img src="https://img2.jimu98.cn/blog/20200801000439.png" srcset="/img/loading.gif" alt="image-20200801000439354"></p><h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p>git工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们先来理解下Git 工作区、暂存区和版本库概念</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://img2.jimu98.cn/blog/20200801001527.png" srcset="/img/loading.gif" alt="image-20200801001527806"></p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><h4 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">"jimu98"</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global user.email z591593455@qq.com</span></code></pre><h4 id="设置文本编辑器"><a href="#设置文本编辑器" class="headerlink" title="设置文本编辑器"></a>设置文本编辑器</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor emacs</span></code></pre><h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --list</span><span class="hljs-meta">$</span><span class="bash"> git config user.name</span></code></pre><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h4 id="本地新建"><a href="#本地新建" class="headerlink" title="本地新建"></a>本地新建</h4><p>使用 Git 来对现有的项目进行管理，进入该项目目录然后输入：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span></code></pre><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。<br>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add *.c   <span class="hljs-comment">#添加所有以 .c 结尾的</span></span><span class="hljs-meta">$</span><span class="bash"> git add LICENSE   <span class="hljs-comment">#添加README文件</span></span><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">'初始化项目版本'</span></span></code></pre><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>克隆仓库的命令格式是 git clone <repo> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2</span></code></pre><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span></code></pre><h2 id="Git文件的声明周期"><a href="#Git文件的声明周期" class="headerlink" title="Git文件的声明周期"></a>Git文件的声明周期</h2><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。<br>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：<br><img src="http://ww1.sinaimg.cn/large/005L0VzSgy1g1xkcqhzd6j30it091mxb.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><h2 id="Git提交-跟踪"><a href="#Git提交-跟踪" class="headerlink" title="Git提交/跟踪/"></a>Git提交/跟踪/</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>各种语言的规范请参考:<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要查看哪些文件处于什么状态，可以用 git status 命令。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status <span class="hljs-comment">#-s 以精简的方式显示文件状态。</span></span></code></pre><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add README</span></code></pre><h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span></code></pre><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git diff</span></code></pre><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit</span></code></pre><p>可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"info"</span></span></code></pre><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">'added new benchmarks'</span></span></code></pre><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm PROJECTS.md</span></code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。<br>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm --cached README</span></code></pre><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git mv file_from file_to</span></code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -p -2 // 查看前两次提交的内容差异</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span>    // 查看每次提交的简略统计信息</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty</span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --since=2.weeks   // 列出所有最近两周内的提交</span></code></pre><p>一个常用的选项是 –pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同。</p><pre><code class="hljs shell">-p 按补丁格式显示每个更新之间的差异。--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史。--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。--grep 仅显示含指定关键字的提交-S 仅显示添加或移除了某个关键字的提交</code></pre><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">'initial commit'</span></span><span class="hljs-meta">$</span><span class="bash"> git add forgotten_file</span><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span></code></pre><p>–amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span></code></pre><h4 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h4><p>checkout 命令方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span></code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote</span><span class="hljs-meta">$</span><span class="bash"> git remote -v // 选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</span></code></pre><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 git remote add 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span><span class="hljs-meta">$</span><span class="bash"> git remote -v</span></code></pre><h4 id="从远程仓库抓取"><a href="#从远程仓库抓取" class="headerlink" title="从远程仓库抓取"></a>从远程仓库抓取</h4><p>从远程仓库中获得数据，可以执行：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git fetch [remote-name]</span></code></pre><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><h4 id="向远程仓库推送"><a href="#向远程仓库推送" class="headerlink" title="向远程仓库推送"></a>向远程仓库推送</h4><p>当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span></code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p><h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span></code></pre><h4 id="远程仓库重命名"><a href="#远程仓库重命名" class="headerlink" title="远程仓库重命名"></a>远程仓库重命名</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rename pb paul // pb-&gt;paul</span></code></pre><h4 id="远程仓库移除"><a href="#远程仓库移除" class="headerlink" title="远程仓库移除"></a>远程仓库移除</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote rm paul</span></code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><span class="hljs-meta">$</span><span class="bash"> git tag -l <span class="hljs-string">'v1.8.5*'</span></span></code></pre><h4 id="轻量标签与附注标签"><a href="#轻量标签与附注标签" class="headerlink" title="轻量标签与附注标签"></a>轻量标签与附注标签</h4><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。<br>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="hljs-string">'my version 1.4'</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】计算机网络-HTTP</title>
    <link href="/2020/07/29/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    <url>/2020/07/29/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】计算机网络-HTTP篇"><a href="#【java总结】计算机网络-HTTP篇" class="headerlink" title="【java总结】计算机网络-HTTP篇"></a>【java总结】计算机网络-HTTP篇</h1><blockquote><p>本内容参考了多位大佬，几十篇博客整理出来的，方便自己的复习，同时有不全面，不正确的内容欢迎补充</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>这个协议对于网络工程师来说，他只是一个协议而已，但对于我们java工程师，或者前端工程师，或者其他非网络计算机从业者都太重要了。我们java开发的很大部分都是web应用，。我们对Web的操作都是通过HTTP协议来进⾏传 输数据的，前端也是很直接的利益相关（怎么有股知乎的味道。）总而言之，Http就是Web通信的基础，这是我们必学的。我一定要总结的全面，透彻。方便自己，方便大家。</p><h3 id="Http基本概念"><a href="#Http基本概念" class="headerlink" title="Http基本概念"></a>Http基本概念</h3><p>HTTP全称是 HyperText Transfer Protocal，即：超文本传输协议。是互联网上应用最为广泛的一种<strong>网络通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。目前我们使用的是<strong>HTTP/1.1 版本</strong>。</p><p>前面不是说了网络的分层概念吗，我们的HTTP协议是在最上层，也就是应⽤层。这是最贴近我们的程序员的层次。</p><blockquote><p>我们逐步一点点来看，解决一个又一个小概念，争取建立一个完整的HTTP体系</p><p>最终解决一个大的问题：在浏览器输入 URL 后发生了什么？</p></blockquote><h3 id="URI-和-URL-有什么区别？"><a href="#URI-和-URL-有什么区别？" class="headerlink" title="URI 和 URL 有什么区别？"></a>URI 和 URL 有什么区别？</h3><p>URI：统一资源标识符（Uniform Resource Identifier），就是在某一规则下能把一个资源独一无二地标识出来。它可以理解成是一个资源的名字，比如<code>积木</code>,<code>jimu98</code>甚至<code>jimu98@foxmail.com</code>或者是<code>aaa.html</code>，只要可以唯一的标识一个名字，那么我们就把他称作uri，甚至<code>https://www.jimu98.cn/aaa.html</code>也是一个URI(这个不是应该叫URL，别着急)</p><p>URI：统一资源标识符(uniform resource identifier)，比如<code>https://www.jimu98.cn/aaa.html</code>，</p><p>其实，我们可以发现，URI强调的是给资源标记命名，URL强调的是给资源定位，但是你会发现，URL显然比URI包含信息更多，我通过URL也可以知道自己的资源名字可能是<code>aaa.html</code>，并且我还知道了他的地址.</p><p>所以大多数情况下大家觉得给一个网络资源分别命名和给出地址太麻烦，干脆就用地址既当地址用，又当标记名用</p><p>所以，URL也充当了WWW万维网里面URI的角色，但是他比URI多了一层意义，我不光知道你叫什么，我还知道你在哪里。</p><p>我们在浏览器输入的都是URL，因为我们输入的目的是为了找到某一个资源。</p><h3 id="DNS：负责解析域名"><a href="#DNS：负责解析域名" class="headerlink" title="DNS：负责解析域名"></a>DNS：负责解析域名</h3><blockquote><p>当我们需要访问一个远程资源的时候，必然要和他建立连接(建立TCP，或者UDP连接，基于IP协议)</p><p>所以我们要知道他的地址，可是随着互联网的发展，越来越多的web应用进入大家视线，比如我们访问一些常用的网站，<code>www.baidu.com</code> <code>www.jd.com</code> 这些时候，我们明明输入的不是ip。</p><p>其实让我们记IP，也是可以访问的，但是你愿意记那么长的数字吗，反正我不愿意，于是乎DNS <code>域名解析协议</code> 诞生了，他就可以把一个特殊含义的域名转换成一个IP地址。</p><p>但是你想啊，你想要用baidu这个名字，别人也想，那到底该给谁呢。于是肯定有专门的管理机构去统一规范。</p><p>但是，我们还有一个叫做本地DNS的东西，通过配置Host文件，去自定义一个域名，实现本地映射。</p></blockquote><blockquote><p>DNS工作流程：</p><p>1、在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个ip地址映射，完成域名解析。</p><p>2、如果hosts里没有这个域名的映射，则会查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析记过给客户端，完成域名解析，此解析具有权威性。</p><p>4、如果要查询域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址（baidu.com）给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 主机。</p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把请求转至上上级，以此循环。不管是本地DNS服务器用是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></blockquote><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><blockquote><p>http请求由三部分组成，分别是：请求行、请求报头、空行、请求数据</p><p>可以分别理解成我使用什么方法，我支持什么格式，我的格式说完了，我的正式数据</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729170117.png" srcset="/img/loading.gif" alt="image-20200729170117264"></p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><blockquote><p>请求行由请求方法、URL字段和HTTP协议的版本组成，格式如下</p><p>Method     Request-URI      HTTP-Version     CRLF </p><p>其中 Method 表示请求方法；GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS（可选项）</p><p>Request-URI是一个统一资源标识符；（前面也说过了）</p><p>HTTP-Version表示请求的HTTP协议 版本；（后面说版本的区别）</p><p>CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p></blockquote><h4 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h4><blockquote><p>通用报头：（现在在解释请求报文，后面还有响应报文，他们两公用的报头）</p><p>Date：表示消息产生的日期和时间。<br>Connection：允许发送指定连接的选项。例如指定连接是连续的；或者指定“close”选项，通知服务器，在响应完成后，关闭连接。<br>Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制）。</p><p>//————————————————–</p><p>请求报头：（不同的报头在不同的http版本种诞生时间不同，可以看后面版本了解）</p><p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。<br>User-Agent：发送请求的浏览器类型、操作系统等信息。<br>Accept：客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息。<br>Accept-Charset请求报头域用于指定客户端接受的字符集 。<br>Accept-Encoding：客户端可识别的数据编码。<br>Accept-Language：表示浏览器所支持的语言类型。<br>Authorization请求报头域主要用于证明客户端有权查看某个资源。<br>Connection：允许客户端和服务器指定与请求/响应连接有关的选项。例如，这时为Keep-Alive则表示 保持连接。<br>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p><p>//————————————————–</p><p>实体报头：（用来定义被传送数据的类型，既可用于请求，又可用于响应）</p><p>Content-Type：发送给接收者的实体正文的媒体类型。<br>Content-Lenght：实体正文的长度。<br>Content-Language：描述资源所用的自然语言。<br>Content-Encoding：实体报头被用作媒体类型的修饰符。它的值指示了已经被应用到实体正文的附加 内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。<br>Last-Modified：实体报头用于指示资源的最后修改日期和时间。<br>Expires：实体报头给出响应过期的日期和时间。</p></blockquote><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><blockquote><p>就是告诉服务器，我的请求头到此为止</p></blockquote><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><blockquote><p>在get中，数据就在url中体现了，所以这里的数据指的在post提交中的数据，至于PUT、DELETE这些，他们其实也可以理解成post</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729172717.png" srcset="/img/loading.gif" alt="image-20200729172717402"></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><blockquote><p>HTTP 的响应报文由状态行、响应报头、空行、响应正文 （和请求体相当类似）</p></blockquote><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><blockquote><p>就是告诉我们  请求的数据是否找到，如果没找到是因为啥，返回一些状态码（404大家都遇到过吧）</p></blockquote><pre><code class="hljs basic"><span class="hljs-number">1</span>xx：表明服务端接收了客户端请求，客户端继续发送请求；<span class="hljs-number">2</span>xx：客户端发送的请求被服务端成功接收并成功进行了处理；<span class="hljs-number">3</span>xx：服务端给客户端返回用于重定向的信息；<span class="hljs-number">4</span>xx：客户端的请求有非法内容；<span class="hljs-number">5</span>xx：服务端未能正常处理客户端的请求而出现意外错误。<span class="hljs-number">2</span>xx:<span class="hljs-symbol">200 </span>OK：表示从客户端发送给服务器的请求被正常处理并返回；<span class="hljs-symbol">204 </span>No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）<span class="hljs-symbol">206 </span>Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的<span class="hljs-keyword">GET</span>请求，响应报文中包含由Content-Range指定范围的实体内容。<span class="hljs-number">3</span>xx:<span class="hljs-symbol">301 </span>Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；<span class="hljs-symbol">302 </span>Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<span class="hljs-symbol">303 </span>See Other：表示请求的资源被分配了新的URL，应使用<span class="hljs-keyword">GET</span>方法定向获取请求的资源<span class="hljs-symbol">304 </span><span class="hljs-keyword">Not</span> Modified：表示客户端发送附带条件（是指采用<span class="hljs-keyword">GET</span>方法的请求报文中包含<span class="hljs-keyword">if</span>-Match、<span class="hljs-keyword">If</span>-Modified-Since、<span class="hljs-keyword">If</span>-None-Match、<span class="hljs-keyword">If</span>-Range、<span class="hljs-keyword">If</span>-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；<span class="hljs-symbol">307 </span>与<span class="hljs-number">302</span>相同，但不会把POST请求变成<span class="hljs-keyword">GET</span><span class="hljs-number">4</span>xx:<span class="hljs-symbol">400 </span>Bad Request:表示请求报文中存在语法错误；<span class="hljs-symbol">401 </span>Unauthorized：经许可，需要通过HTTP认证；<span class="hljs-symbol">403 </span>Forbidden：服务器拒绝该次访问（访问权限出现问题）<span class="hljs-symbol">404 </span><span class="hljs-keyword">Not</span> Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；<span class="hljs-number">5</span>xx:<span class="hljs-symbol">500 </span>Inter Server <span class="hljs-keyword">Error</span>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；<span class="hljs-symbol">503 </span>Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</code></pre><blockquote><p>突然想到某个老师教过，当你遇到404错误，你给用户返回一个503，显得你网站特别火爆（啊哈哈哈哈哈哈）</p><p>也就是说，其实看到某些状态码的时候，也不一定可信，因为后台可以改掉</p></blockquote><h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><blockquote><p>GET与POST是我们常用的两种HTTP Method（就是你在前端form表单那里写的，或者你后台用@PostMapping接收的那个）</p></blockquote><blockquote><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被收藏，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul></blockquote><blockquote><p>但是，GET和POST的底层都是TCP/IP，你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>但是不同的浏览器对数据量有所限制，业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p><p>如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p></blockquote><blockquote><p>还有一个比较重要的区别，很多面试笔记里面都没有写这一条（）</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。</p><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p><p>以上就是post和get全部区别的</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729192410.png" srcset="/img/loading.gif" alt="image-20200729192410542"></p><p>其实HTTP协议中还⽀持着其他的⽅法，⽐如：Input、Delete、OPTIONS很多这样的⽅法。</p><p>⽽由于常⽤，于是我们也可能仅仅知道GET和POST⽅法了。 </p><p>HTTP提供⽅法的⽬的就是为了告知服务器该客户端想进⾏什么操作。当HTTP是OPTIONS⽅法的时候， 服务器端就会返回它⽀持什么HTTP⽅法。 当然了，现在RESTful盛⾏，也就是充分利⽤了HTTP协议的这些⽅法</p><p>RESTful  以后再专门总结一下（不然我怎么水博客）</p><h3 id="HTTP协议版本详解"><a href="#HTTP协议版本详解" class="headerlink" title="HTTP协议版本详解"></a>HTTP协议版本详解</h3><blockquote><p>版本这里有些枯燥，都是些知识点，作为了解可以跳过</p></blockquote><p>到现在为⽌，HTTP协议已经有四个版本了： </p><ul><li><p>HTTP/0.9</p><p>HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。</p></li><li><p>HTTP1.0</p><p>引入了新的命令POST和HEAD（http数据头部）命令，可自定义类型, 常见Content-Type值：text/xml image/jpeg audio/mp3</p><p>同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。</p><p>但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。</p></li><li><p>HTTP1.1</p><p>新增方法：PUT、PATCH、OPTIONS、DELETE，引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p></li><li><p>HTTP/2</p><p>HTTP2.0是SPDY（谷歌公司研发的https的一种协议）的升级版<br>1.头信息和数据体都是二进制，称为头信息帧和数据帧<br>2.复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）<br>3.引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度<br>4.HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）</p></li><li><p>HTTP/3 </p></li></ul><h4 id="HTTP1-0和HTTP1-1区别"><a href="#HTTP1-0和HTTP1-1区别" class="headerlink" title="HTTP1.0和HTTP1.1区别"></a>HTTP1.0和HTTP1.1区别</h4><blockquote><p>HTTP1.0和HTTP1.1最主要的区别就是： HTTP1.1默认是持久化连接！</p><p>在HTTP1.0默认是短连接：简单来说就是：每次与服务器交互，都需要新开⼀个连接！</p><p>在HTTP1.1中默认就使⽤持久化连接来解决：建⽴⼀次连接，多次请求均由这个连接完成！(如果阻塞 了，还是会开新的TCP连接的)</p></blockquote><blockquote><p>HTTP 1.1增加host字段</p></blockquote><blockquote><p>HTTP 1.1中引⼊了 Chunked transfer-coding ，范围请求，实现断点续传(实际上就是利⽤ HTTP消息头使⽤分块传输编码，将实体主体分块传输)</p></blockquote><blockquote><p>HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，⽽不⽤⼀个个等待响应之 后再请求</p><p>仅仅是提出了理论，浏览器默认关闭HTTP pipelining！</p></blockquote><h4 id="HTTP2和HTTP1-1的区别"><a href="#HTTP2和HTTP1-1的区别" class="headerlink" title="HTTP2和HTTP1.1的区别"></a>HTTP2和HTTP1.1的区别</h4><h5 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h5><p>管线化(pipelining)和⾮管线化的区别：</p><p><img src="https://img2.jimu98.cn/blog/20200729163522.png" srcset="/img/loading.gif" alt="image-20200729163522493"></p><blockquote><p>HTTP Pipelining其实是把多个HTTP请求放到⼀个TCP连接中⼀⼀发送，⽽在发送过程中不需要等 待服务器对前⼀个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应！</p></blockquote><blockquote><p>在HTTP1.0中，发送⼀次请求时，需要等待服务端响应了才可以继续发送请求。 在HTTP1.1中，发送⼀次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来⼀⼀接收 </p><p>所以说，⽆论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的 名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB</p></blockquote><blockquote><p>HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：多路复⽤ (Multiplexing)</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729164525.png" srcset="/img/loading.gif" alt="image-20200729164525340"></p><h5 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h5><blockquote><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议</p></blockquote><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><blockquote><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p></blockquote><h5 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h5><blockquote><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></blockquote><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><blockquote><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p></blockquote><h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP是⽆状态的，也就是说，它是不对通信状态进⾏保存的。它并不知道之前通信的对⽅是谁。这样 设计的⽬的就是为了让HTTP简单化，能够快速处理⼤量的事务！ </p><p>但是，我们经常是需要知道访问的⼈是谁，比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。（你说保存在用户的数据库里面，那首先得登录吧，我们平时用的京东之类的购物网站可不是这样，未登录状态下就可以添加购物车）于是就有了Cookie技术了。 </p><h4 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h4><blockquote><p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）</p></blockquote><blockquote><ol><li>首先用户在客户端浏览器向服务器发起登陆请求（或者不登录，但是第一次访问同样会给你一个cookie）</li><li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li><li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li><li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li></ol></blockquote><h4 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h4><blockquote><p>刚才说的cookie一个重要概念就是保存在本地，那如果我想区分用户权限，有一个用户是普通用户，我给了他VIP1权限，并且保存在了他的CK里面，但是他自己改成了VIP15，然后我的网站判断这个人拥有全部权限。。。。。于是。。。。。。</p><p>很明显，这样是不安全的，于是，类似的又有了一个session的机制，session把会话内容保存在服务器端</p></blockquote><blockquote><ol><li>首先用户在客户端浏览器发起登陆请求</li><li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。</li><li>客户端浏览器会把这个唯一的 session 标识保存在起来（一般保存在ck里面）</li><li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li></ol></blockquote><blockquote><p>大家会不会有一个疑问，说生成了一个session，又保存到了我的ck里面，那岂不是还是不安全，但是，我们可以抓包看一下</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729195513.png" srcset="/img/loading.gif" alt="image-20200729195513482"></p><blockquote><p>我们能从这么一个字符串看出任何有效信息吗（一般来说，我们都能往服务器存数据了，应该没人往前台写隐私信息吧，emmmm<del>~</del>应该不会吧）他只是给了我们一个ID，有效信息都在服务器，他会根据我们的ID去服务器查找有效信息，然后返回对应内容。</p></blockquote><h4 id="session和cookie有什么区别"><a href="#session和cookie有什么区别" class="headerlink" title="session和cookie有什么区别"></a>session和cookie有什么区别</h4><blockquote><ol><li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li><li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li><li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li><li>而 session 机制提供的会话是保存在服务端的。</li></ol></blockquote><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><blockquote><p>本块知识对细节要求较高，还是希望大家可以了解下ssl证书，以及非对称加密之类的概念</p><p>推荐先阅读码农翻身中关于https的小故事，然后再来理解https</p></blockquote><h3 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h3><blockquote><ol><li>通信使用明文不对数据进行加密（内容容易被窃听）</li><li>不验证通信方身份（容易伪装）</li><li>无法确定报文完整性（内容易被篡改）</li></ol><p>不安全：大家还记得我在计算机网络基础篇里面说的联网过程吗</p><p>从你家的网线出发，到小区的交换机，再到城市中央的路由器，再到小伙伴的小区交换机，再到小伙伴的电脑桌面。</p><p>任意一个环节都可以接入一台电脑，然后抓包，数据是可以被抓下来的。</p><p>比如我们传输一段 password：123456，那么黑客就直接可以看到了</p><p>但是我们传输一段 password：123456，使用加密技术之后 黑客可能看到的就是 E10ADC3949BA59ABBE56E057F20F883E</p></blockquote><blockquote><p>因此我们应该使用加密技术，但是码农翻身中 张大胖和Bill 的聊天，也指出了问题，如果中间人获取了他们的公钥，然后进行中间人攻击，那又失去了他的安全性。</p><p>于是乎，他们把自己的公钥交给，权威机构生成证书，权威机构在保证自己绝对安全的情况下，才能为整个互联网的安全做背书。</p></blockquote><h3 id="ssl证书"><a href="#ssl证书" class="headerlink" title="ssl证书"></a>ssl证书</h3><blockquote><p>SSL 协议就是用来解决 HTTP 传输过程的不安全问题，到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><p>（个人认为，大家还是喜欢把他叫做SSL，不信你去百度搜索下SSL证书和TLS证书，看看哪个广告多）</p><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p></blockquote><p>SSL/TLS协议的基本过程是这样的</p><blockquote><ol><li>服务端将非对称加密的公钥发送给客户端；</li><li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li><li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li><li>二者利用对称加密的key对需要传输的消息做加解密传输。</li></ol></blockquote><p>然后我们来看HTTPS</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS=HTTP+SSL</p><p>HTTPS也就是披着SSL羊皮的HTTP</p><p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。</p><h3 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h3><blockquote><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul></blockquote><blockquote><p>个人觉得，这个HTTPS加密流程作用性价比不高</p><p>又废资源又费钱（我用的免费的。。。）</p><p>而且我访问一个网站，黑客真的会在中间截获数据吗，我觉得更应该从源头或者目的来截获吧（可能是我网络安全知识薄弱，不太懂）</p><p>而且很明显，多了9次握手，那速度势必会影响 emmmm。。。</p></blockquote><h2 id="在浏览器中输入url地址，发生了什么？"><a href="#在浏览器中输入url地址，发生了什么？" class="headerlink" title="在浏览器中输入url地址，发生了什么？"></a>在浏览器中输入url地址，发生了什么？</h2><blockquote><ul><li>1.解析url地址，</li><li>2.DNS解析</li><li>3.TCP连接</li><li>4.发送HTTP请求</li><li>5.服务器处理请求</li><li>6.服务器返回HTTP报文</li><li>7.浏览器解析渲染页面</li></ul></blockquote><p>1.解析该url地址的域名，浏览器会检查这是一个url还是查询的关键字，然后自动编码，还会做一些安全检查</p><p>2.DNA解析的过程是递归的，下面以请求 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 为例：首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><p>3.HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><p>4.发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求体。请求行格式及示例如下：</p><pre><code class="hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">Request</span>-<span class="hljs-title">URL</span> <span class="hljs-title">HTTP</span>-<span class="hljs-title">Version</span> <span class="hljs-title">CRLF</span></span><span class="hljs-function"><span class="hljs-title">GET</span> <span class="hljs-title">index</span>.<span class="hljs-title">html</span> <span class="hljs-title">HTTP</span>/1.1</span></code></pre><p>常用的方法有：GET, POST, PUT, DELETE, OPTIONS, HEAD</p><p>5.服务器处理这里可说可不说</p><p><img src="https://img2.jimu98.cn/blog/20200731164923.png" srcset="/img/loading.gif" alt="image-20200731164923701"></p><p>6.后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应体。</p><p>7.浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p><p><img src="https://img2.jimu98.cn/blog/20200731165020.png" srcset="/img/loading.gif" alt="image-20200731165020227"></p><h2 id="向淘宝请求首页，怎么提高性能"><a href="#向淘宝请求首页，怎么提高性能" class="headerlink" title="向淘宝请求首页，怎么提高性能"></a>向淘宝请求首页，怎么提高性能</h2><blockquote><p>从请求、传输、渲染3个方面提升</p></blockquote><h3 id="一、请求"><a href="#一、请求" class="headerlink" title="一、请求"></a>一、请求</h3><p>浏览器为了减少请求传输，实现了自己的缓存机制。浏览器缓存就是把一个已经请求过的Web资源拷贝一份副本存储在浏览器中，当再次请求相同的URL时，先去查看缓存，如果有本地缓存，浏览器缓存机制会根据验证机制（Etag）和过期机制(Last-Modified)进行判断是使用缓存，还是从服务器传输资源文件。具体流程如下图所示：</p><p><img src="http://college.creditease.cn/resources/upload/image/20170925/1506321631051056382.png" srcset="/img/loading.gif" alt="img"></p><p>浏览器的请求有些是并发的，有些是阻塞的，比如：图片、CSS、接口的请求是并发；JS文件是阻塞的。请求JS的时候，浏览器会中断渲染进程，等待JS文件加载解析完毕，再重新渲染。所以要把JS文件放在页面的最后。</p><p>JS也可以通过两种方式由阻塞改成并行：一种是通过创建script标签，插入DOM中；另一种是在Script标签中增加async属性。</p><p>每种浏览器对同一域名并发的数量有限制，IE6/7是2，IE9是10，其他常见的浏览器是6，所以减少资源请求数量和使用多域名配置资源文件，能大大提高网站性能。</p><p>减少资源请求数量的方法，大致有以下几种：</p><p>1、通过打包工具，合并资源，减少资源数量。就是开发版本是很多个资源文件，部署的时候，按类合并成几个文件来输出。在实现模块管理的同时，实现统一输出。</p><p>2、CSS中，使用css sprite减少图片请求数量。</p><p>3、通过延迟加载技术，在用户无感知的情况下请求资源。</p><p>4、通过服务器配置，实现一次请求，返回多个资源文件，如淘宝CDN那样。</p><p>除了减少请求数量，也可以使用CDN镜像，来减少网络节点，实现快速响应。使用了CDN的请求，会根据用户所处的地理位置，找寻最近的CDN节点，如果请求是新的，则从资源服务器拷贝到节点，然后再返回给客户端。如果请求已经存在，则直接从节点返回客户端。</p><p>通过上面我们了解的缓存机制，如果我们部署上线的时候，是需要刷新缓存的。普通缓存通过强刷就能改过来，而CDN缓存则需要通过改变URL来实现。同时我们不可能要求用户按着Ctrl来刷新，所以通过打包工具，在部署的时候，统一更改URL是最有效的方式。而不常变更的库文件，比如echart、jquery，则不建议更改。</p><h3 id="二、传输"><a href="#二、传输" class="headerlink" title="二、传输"></a>二、传输</h3><p>从服务器往客户端传输，可以开启gzip压缩来提高传输效率。</p><p>Gzip有从1-10的十个等级。越高压缩的越小，但压缩使用的服务器硬件资源就越多。根据实践，等级为5的时候最均衡，此时压缩效果是100k可以压缩成20k。</p><h3 id="三、渲染"><a href="#三、渲染" class="headerlink" title="三、渲染"></a>三、渲染</h3><p>浏览器在加载了html后，就会一边解析，一边根据解析出来的结果进行资源请求，并生成DOM树。而加载完毕的CSS，则被渲染引擎根据生成好的DOM树，来生成渲染树。等所有资源解析完毕计算好layout后，向浏览器界面绘制。随着用户操作，JS会修改DOM节点或样式，重新绘制和重新排列。重新绘制指的是绘制DOM节点对应的渲染节点，重新排列是指重新计算这些节点在浏览器界面的位置。很显然，重排是非常耗性能的。我们要做的是减少重排的次数。</p><p>生成DOM树的时候，我们可以通过减少DOM节点来优化性能。最初都是用table布局，节点深度和数量相当复杂，性能很差。同样CSS作为层叠样式表，层级也不可太深，不然遍历的成本很高。另外CSS的expression属性相当耗性能，能不用则不用。动画效果能用CSS写的就不用JS写，渲染引擎不一样，性能损耗也不一样。</p><p>上面说的是解析渲染的过程，我们再接着说说用户交互操作的过程。用户操作就会导致重绘和重排，重排一定会引起重绘，而重绘不一定会引起重排。到底怎样会引起重排呢？简单的定义，DOM结构的变化，以及DOM样式中几何属性的变化，就会导致重排。几何属性顾名思义，就是宽、高、边框、外补丁、内补丁等俗称盒模型的属性。同时还有offset之类的边距属性。</p><p>重排是最耗能的，减少重排的方法有：</p><p>1、如果需要多次改变DOM，则先在内存中改变，最后一次性的插入到DOM中。</p><p>2、同上一条，如果多次改变样式，合成一条，再插入DOM中。</p><p>3、由于position的值为absoute和fixed时候，是脱离文档流的，操作此类DOM节点，不会引起整页重排。所以动画元素设置position使其脱离文档流。</p><p>4、当DOM节点的display等于none的时候，是不会存在于渲染树的，所以如果有比较复杂的操作，先使其display等于none，等待所有操作完毕后，再将display设成block，这样就只重排两次。</p><p>5、获取会导致重排的属性值时，存入变量，再次使用时就不会再次重排。获取这些属性会导致重排：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p><p>以上就是浏览器如何把资源变成肉眼所见的页面的，除了上述根据浏览器流程而总结出来的性能优化，我们还需要看看javascript作为程序，需要的优化。先来看看javascript的垃圾回收机制。</p><p>Javascript的引擎会在固定的时间间隔，将不再使用的局部变量注销掉，释放其所占的内存。而闭包的存在，将使引用一直存在，无法被释放掉。全局变量的生命周期直至浏览器卸载页面才会结束。所以一般来讲，内存溢出就是由于全局变量的不释放和闭包引起。为了防止内存溢出，我们可以做的方法有:</p><p>1、业务代码放在匿名立即执行函数里面，执行完毕会立即释放掉。</p><p>2、少用全局变量，同时用完的变量手动注销掉。</p><p>3、使用回调来代替闭包访问内部属性</p><p>4、当不可避免使用闭包时，慎重的对待其中的细节。不用的时候注销掉。</p><p>5、通过浏览器自带的工具profiles，来检查内存活动情况。如果是波浪型的，说明正常。如果是倾斜式渐进上涨的，说明有内存不会被释放，需要检查相应的函数。</p><p>最后再说一点，函数里返回异步取的值，经常有人这么：</p><pre><code class="hljs routeros">Var getList = function()&#123; $.ajax().then(function(data)&#123;  Return data;&#125;) &#125;;Var<span class="hljs-built_in"> users </span>= getList();</code></pre><p>毫无疑问，由于函数内的返回是异步的，所以返回只能是undefined，而不是想要的data。于是为了实现返回data，就把ajax的async属性设置成了false，由异步改为同步，来获取到data。然而最大的问题来了，同步是会中断渲染进程的，也就是请求返回的等待中，整个页面是卡死的，用户操作也不会有响应。这个问题真正的解决方案是返回promise对象，而不是把异步改成同步。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【java总结】计算机网络-基础篇</title>
    <link href="/2020/07/28/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/07/28/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="【java总结】计算机网络-基础篇"><a href="#【java总结】计算机网络-基础篇" class="headerlink" title="【java总结】计算机网络-基础篇"></a>【java总结】计算机网络-基础篇</h1><blockquote><p>本内容参考了多位大佬，几十篇博客整理出来的，方便自己的复习，同时有不全面，不正确的内容欢迎补充</p><p>计算机网络-HTTP 篇 <a href="https://www.jimu98.cn/2020/07/29/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/">点这里</a></p></blockquote><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h3><p>那我们作为一个程序员，难免会去编写一些通信类应用，甚至开发桌面端应用（好像C++更多吧），就算你是一个前端，那么总是要和后台取数据吧，天天post，get，我们也总要学一些计算机网络知识。（详细学习的话强烈推荐谢希仁老师的计算机网络）</p><p>那么什么是计算机网络呢？</p><p>很多书都是这么一句话：计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。</p><p>我们生活中从电脑出发，背后连接着一根网线（如果使用的无线，那么就把他当作一根看不见的线）然后这跟网线连接到家里墙上的一个出口，然后这个出口连接到小区的汇聚交换机上面，然后中间经过其他交换机，路由器，再连接到我们这个城市的中心路由器上面。其他城市的小伙伴同样这样，然后两个城市间架起一座桥梁（我们这里暂时只把他记作光纤），那么，网络就是这样。</p><blockquote><p>从宏观上面来看，就是这么简单</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728203448.png" srcset="/img/loading.gif" alt="image-20200728203448182"></p><p>但是我们继续想，网络可能同时有大量的数据，同时在光纤上面传输，而且还同时有大量的人发送，</p><p>我们怎么才能在光纤上传递文字，图片，甚至音频，接受到你的消息以后，你怎么把他还原，看一看他到第是什么</p><p>于是乎，网络又变得复杂了起来，甚至复杂到一种很难解释的情况。</p><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>（举个例子：一个皇帝又管大家吃饭，又管外出打仗，这时候还要考虑王阿姨家的猫和另一个省的一条狗重名了，王阿姨不乐意了，可是生活就是这样，皇帝于是决定周一处理打仗的事情，周三处理王阿姨的事情，情况有所缓解，于是乎他设立了不同的官员去做不同的事情，就这样，把大事分成小事去做就解决了这个问题）</p><p>这时候，有人提出来，我们把网络分层，每一层只处理本层的事情，处理完再传递给下一层</p><p>于是ISO（国际标准化组织）提出了OSI/RM（开放系统互连参考模型）大家根据单词首字母简单记一下</p><p>这个组织把网络通信分为了七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>但是有趣的是ISO提出来以后没啥产品，于是伴随着Internet火遍大江南北，TCP/IP才成为真正使用的协议</p><p>更有趣的TCP/IP的四层把物理层和数据链路层给合并了，但是物理层这么重要的一层，直接跟物理设备打交道，这也太没面子了</p><p>而且最主要的人类思考起来不太方便，那么我们经常说的是TCP/IP的五层模型</p><p><img src="https://img2.jimu98.cn/blog/20200728212643.png" srcset="/img/loading.gif" alt="image-20200728212643527"></p><blockquote><p>这张图还是要背的，有些时候理解不了的知识，那么就去背。背会了，慢慢就理解了。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200731170532.gif" srcset="/img/loading.gif" alt="1403129_1582549890987_005L0VzSly1gc53dab9gvg30v41830yk"></p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>（举个例子，小A和小B要通讯，小A要给小B发送一幅蒙娜丽莎，但是光纤可不能直接发送画呀，只能发送0，1字符串，于是小A发送了 1100111代表蒙娜丽莎，小B收到了，非要翻译成清明上河图，你说这闹的。。。）</p><p>所以通信双方想要通信，必须建立约定，约定好1100111就是蒙娜丽莎，约定就可以称作协议，因此通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><p>换个例子</p><p>小A和小B要通讯，比作小A给小B寄快递</p><p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p><p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p><p><code>ping</code> 可以说是网络层ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-IP解释"><a href="#TCP-IP解释" class="headerlink" title="TCP/IP解释"></a>TCP/IP解释</h3><p>这个分层相当重要，前面也说过了，TCP/IP才是我们真正实现了的协议（那么我们到底说的是四层呢还是五层呢，在生活中常用五层，但是TCP/IP提出时候就是四层，但是大家不要迷惑，你就站在他们头顶，聊到四层，就往四层想，聊到五层，就往五层想，游刃有余的时候，就能感觉到，他们就是一个东西，emmm，这里我有点说不清楚。。）</p><blockquote><p>另外，TCP/IP是一个协议簇，也就是一个组合，包含了多种协议，但是TCP和IP最具代表性，所以被称为TCP/IP协议。</p></blockquote><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>它们都属于传输层协议,</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p><h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP  三次握手"></a>TCP  三次握手</h5><blockquote><p>这个好多人都吃过亏，感觉好复杂，我觉得码农翻身里面这一段解释的特别简单</p><p>第一次：A跟B说话   B收到了 B知道A发送消息没问题</p><p>第二次：B跟A说话   A收到了  A知道B发送和接收都没问题</p><p>第三次：A跟B说话   B收到了  B知道A发送和接收都没问题</p><p>于是乎，A和B可以正常通讯了</p></blockquote><p>为什么需要三次握手呢？两次不行吗？</p><blockquote><p>在谢希仁的《计算机网络》中是这样说的：”为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。”</p><p>我们先要知道TCP是基于IP协议的（下面有解释），而IP协议是有路由的，IP协议不能够保证先发送的数据先到达，这当中依赖于IP协议底层的网络质量，以及Client与Server之间的路由跳数。</p><p>比如A和B说话，A跟B说：“在吗，借我一块钱”，B回答他：“给你转到支付宝了”，但是B说的这句话走的一条很漫长的路，走了一分钟。</p><p>但是A说完了，等了好久B都不理他，他以为B就没收到他说的话，他又发了一句话：“在吗，借我一块钱”，这时候B又收到了，他不知道这是A从新发送的，以为又建立了一个新的通话连接，于是这个过程就会浪费很多的资源，而三次握手就相对保险。</p></blockquote><p>简单的理解了，那我们也要看看复杂的情况（我会尽量说的清楚）</p><p>暂时只看绿色部分的三次握手（状态大家可以百度一下TCP11种状态，我感觉直接翻译可能更乱）</p><blockquote><p>1.第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x（也就是随机值）；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</p><p>2.第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</p><p>3.第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200729161601.png" srcset="/img/loading.gif" alt="image-20200729161600822"></p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><blockquote><p>举个栗子：把客户端比作男孩，服务器比作女孩。通过他们的分手来说明“四次挥手”过程。</p><p>“第一次挥手”：男孩发现女孩变成了自己讨厌的样子，忍无可忍，于是决定分手，随即写了一封信告诉女孩。</p><p>“第二次挥手”：女孩收到信之后，知道了男孩要和自己分手，怒火中烧，心中暗骂：你算什么东西，当初你可不是这个样子的！于是立马给男孩写了一封回信：分手就分手，给我点时间，我要把你的东西整理好，全部还给你！男孩收到女孩的第一封信之后，明白了女孩知道自己要和她分手。随后等待女孩把自己的东西收拾好。</p><p>“第三次挥手”：过了几天，女孩把男孩送的东西都整理好了，于是再次写信给男孩：你的东西我整理好了，快把它们拿走，从此你我恩断义绝！</p><p>“第四次挥手”：男孩收到女孩第二封信之后，知道了女孩收拾好东西了，可以正式分手了，于是再次写信告诉女孩：我知道了，这就去拿回来！（这里有一个重要的概念 <code>TIME-WAIT</code> 阿正哥说这个可以比作冷静期 emmm~）</p><p>这里双方都有各自的坚持。女孩自发出第二封信开始，限定一天内收不到男孩回信，就会再发一封信催促男孩来取东西！</p><p>男孩自发出第二封信开始，限定两天内没有再次收到女孩的信就认为，女孩收到了自己的第二封信；若两天内再次收到女孩的来信，就认为自己的第二封信女孩没收到，需要再写一封信，再等两天…..</p><p>倘若双方信都能正常收到，最少只用四封信就能彻底分手！这就是“四次挥手”。</p></blockquote><blockquote><p>上面的解释应该很清楚解释了为什么是四次挥手</p><p><strong>这里强调一下TIME-WAIT的概念</strong></p><p>因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。</p><p><strong>什么是MSL？</strong></p><p>MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。 关于MSL的大小，RFC<br>793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，<br>以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，并且这个数值是硬编码在内核中的，<br>也就是说除非你重新编译内核，否则没法修改它：</p><p><strong>为什么客户端在TIME-WAIT阶段要等2MSL?</strong></p><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p><p><strong>如果没有time_wait会怎么样？</strong><br> 我们举一个比较简单的例子：假设服务端发送了断开请求的包，（假设没有TIME_WAIT），客户端收到后立马就回复了确认包，连接就关闭了，但是服务器这边其实还有一个数据在路上，到了之后会发现客户端已经关闭了，一脸懵逼的收到了一个RST包，然后也关闭了连接，这样就导致了数据包的丢失。</p></blockquote><h5 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h5><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><blockquote><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方。首先接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>定义流量窗口为接收缓存剩余的空间。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p></blockquote><h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h6><blockquote><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p></blockquote><p>流量控制之滑动窗口机制</p><blockquote><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200728230255.png" srcset="/img/loading.gif" alt="image-20200728230255200"></p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上，是不是很随便，大家记住他很随便就可以了</p><h4 id="TCP与UDP区别及应用"><a href="#TCP与UDP区别及应用" class="headerlink" title="TCP与UDP区别及应用"></a>TCP与UDP区别及应用</h4><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">传输效率低</td><td align="left">传输效率高</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口</td><td align="left">无</td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始、拥塞避免、快重传、快恢复</td><td align="left">无</td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场合</td><td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td><td align="left">对效率要求高，对准确性要求低</td></tr></tbody></table><p><img src="https://img2.jimu98.cn/blog/20200728221157.png" srcset="/img/loading.gif" alt="image-20200728221157748"></p><h3 id="IP解释"><a href="#IP解释" class="headerlink" title="IP解释"></a>IP解释</h3><p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”</strong>，它们携带的货物就是像HTTP，FTP这样的协议等。</p><p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p><h3 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h3><blockquote><p>首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，</p><p>如果有，就直接将数据包发送到这个MAC地址；<br>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</p><p>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。</p><p>如果不相同就忽略此数据包；<br>如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；</p><p>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></blockquote><h3 id="常见的路由选择协议，以及它们的区别"><a href="#常见的路由选择协议，以及它们的区别" class="headerlink" title="常见的路由选择协议，以及它们的区别"></a>常见的路由选择协议，以及它们的区别</h3><p><strong>RIP协议</strong>（路由信息协议）：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong>（开放最短路径优先）：底层是迪杰斯特拉算法，它选择路由的度量标准是带宽，延迟。</p>]]></content>
    
    
    <categories>
      
      <category>java总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>网络分层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO友链随机排序</title>
    <link href="/2020/07/28/other/HEXO%E5%8F%8B%E9%93%BE%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/28/other/HEXO%E5%8F%8B%E9%93%BE%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><blockquote><p>最近做博客做的很有乐趣，到处找人换友链</p><p>然后我就发现排在前面和排在后面点击效果比较好</p><p>这对排在中间的朋友们极其不公平。</p><p>我就想搞个随机友链</p></blockquote><h1 id="找出目录"><a href="#找出目录" class="headerlink" title="找出目录"></a>找出目录</h1><blockquote><p>首先我们思考一下hexo原理，他是把你的配置文件还有静态资源通过各种类似脚本的方式生成静态页面</p><p>那么就要去找到友链所对应的脚本或者资源</p></blockquote><p>首先打开主题文件夹，友链无非就那几个关键字 link，links，friend，反正看到类似的就可以</p><p>我的是在 <code>layout/links.ejs文件下面</code></p><h2 id="原来的代码"><a href="#原来的代码" class="headerlink" title="原来的代码"></a>原来的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alpha%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><p>看到这几个for循环，感觉亲切了许多是吧。</p><p>theme.links.items应该就是存放友链的数组了</p><blockquote><p>继续思考</p></blockquote><blockquote><p>hexo是生成静态页面的，我们打开看一下生成的public文件夹，很明显，每一条数据都直接固定写成了html</p><p>那说明这里只是拼接html的脚本</p><p>我有两种想法</p><p>通过js操作dom来修改html数据（太过于繁琐，放弃）</p><p>直接在生成前，把数组打乱（so easy，就他了）</p><p>大家看上面的&lt;%  %&gt;了吗  很明显，这里是动态获取数据的地方</p><p>那我们就开始写了</p><p>打乱数组：</p><p>其实我们可以使用js的sort，然后给他一个随机对比</p><p>这样</p><p>function randomsort(a, b) {<br> return Math.random()&gt;.5 ? -1 : 1;<br>}<br>theme.links.items.sort(randomsort);</p><p>//这是一种最简单的方法，但是你可想一下  前面的在前面的概率比较大，后面的在后面的概率比较大，对不对</p><p>（比如先给你加友链的小伙伴，很大的改了可以在前面对不对）</p><p>//当然，我们还是的采用更公平的随机算法：随机洗牌算法</p><p>Array.prototype.shuffle = function() {<br>var input = this;<br>    for (var i = input.length-1; i &gt;=0; i–) {<br>        var randomIndex = Math.floor(Math.random()*(i+1));<br>        var itemAtIndex = input[randomIndex];<br>        input[randomIndex] = input[i];<br>        input[i] = itemAtIndex;<br>    }<br>    return input;<br>}<br>theme.links.items.shuffle();</p></blockquote><h2 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h2><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;</code></pre><blockquote><p>好像这个主题友链没带加评论，也没有自我介绍</p><p>那让想要添加我的小伙伴操作起来多么繁琐，找到代码  加上去</p></blockquote><pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;links&quot;page.title &#x3D; theme.links.title || __(&#39;links.title&#39;)page.subtitle &#x3D; theme.links.subtitle || __(&#39;links.subtitle&#39;)page.banner_img &#x3D; theme.links.banner_imgpage.banner_img_height &#x3D; theme.links.banner_img_heightpage.banner_mask_alpha &#x3D; theme.links.banner_mask_alphafunction randomsort(a, b) &#123;    return Math.random()&gt;.5 ? -1 : 1;    &#x2F;&#x2F;用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;theme.links.items.sort(randomsort);%&gt; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;本站友情链接顺序随机&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;div class&#x3D;&quot;content-tab-content  &quot; data-tab-index&#x3D;&quot;2&quot;&gt;名称：积木&lt;br&gt;网址：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&lt;&#x2F;a&gt;&lt;br&gt;头像：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&quot;&gt;https:&#x2F;&#x2F;www.jimu98.cn&#x2F;img&#x2F;avatar.png&lt;&#x2F;a&gt;&lt;br&gt;描述：积木-互联网的一只小菜鸡。&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;row links&quot;&gt;  &lt;% for(const each of theme.links.items) &#123; %&gt;    &lt;% if (!each.title || !each.link) continue %&gt;    &lt;div class&#x3D;&quot;card col-lg-4 col-md-6 col-sm-12&quot;&gt;      &lt;a href&#x3D;&quot;&lt;%&#x3D; url_for(each.link) %&gt;&quot; class&#x3D;&quot;card-body hover-with-bg&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;        &lt;div class&#x3D;&quot;card-content&quot;&gt;          &lt;% if (each.image) &#123; %&gt;            &lt;div class&#x3D;&quot;link-avatar my-auto&quot;&gt;              &lt;img src&#x3D;&quot;&lt;%&#x3D; each.image %&gt;&quot; alt&#x3D;&quot;&lt;%&#x3D; each.title %&gt;&quot; &#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;% &#125; %&gt;          &lt;div class&#x3D;&quot;link-text&quot;&gt;            &lt;div class&#x3D;&quot;link-title&quot;&gt;&lt;%- each.title %&gt;&lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;link-intro&quot;&gt;&lt;%- each.intro %&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;  &lt;% &#125; %&gt;&lt;&#x2F;div&gt;              &lt;div class&#x3D;&quot;comments&quot; id&#x3D;&quot;comments&quot;&gt;                &lt;% var type &#x3D; &#39;_partial&#x2F;comments&#x2F;&#39; + theme.post.comments.type %&gt;                &lt;%- partial(type) %&gt;              &lt;&#x2F;div&gt;</code></pre><blockquote><p>当然这种随机，每次更新文章从新上传的时候，他会随机生成。</p><p>但是有小伙伴需要刷新一次页面生成一次，</p><p>那这种想法很明显，html代码写死了</p><p>所以你要么写js代码，每次动态修改html</p><p>要么直接把友链数据写到js里面渲染</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>随机排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】Object的概念与区别</title>
    <link href="/2020/07/27/xiangmu/Object%E5%88%92%E5%88%86/"/>
    <url>/2020/07/27/xiangmu/Object%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】Object的概念与区别"><a href="#【项目笔记】Object的概念与区别" class="headerlink" title="【项目笔记】Object的概念与区别"></a>【项目笔记】Object的概念与区别</h1><blockquote><p>首先来一张图，简单看一下</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200727194511.png" srcset="/img/loading.gif" alt="image-20200727194312707"></p><blockquote><p>网上这类帖子特别乱，比如有解释VO、DTO区别的，还有什么DO，PO，TO区别的</p><p>有好处也有坏处吧，好处在于准确对比。坏处可能会更加迷糊</p><p>于是我自己把大佬们文章整理一下，如果哪里不对，大家一定要留言告诉我</p></blockquote><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>最常用实体类，基本和数据表一一对应，一个实体一张表。</p><h3 id="POJO（Plain-Ordinary-Java-Object）："><a href="#POJO（Plain-Ordinary-Java-Object）：" class="headerlink" title="POJO（Plain Ordinary Java Object）："></a>POJO（Plain Ordinary Java Object）：</h3><p>表示一个简单的Java对象,实际就是普通JavaBeans,是为了避免和EJB混淆所创造的简称，下面要说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。</p><blockquote><p>有部分人写代码经常用pojo来代替entity，至于哪个更规范，我也不知道，只是现在经常使用entity</p></blockquote><h3 id="PO（Persistent-Object）："><a href="#PO（Persistent-Object）：" class="headerlink" title="PO（Persistent Object）："></a>PO（Persistent Object）：</h3><p>持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><blockquote><p>人话：我们正常写得entity，一个实体就是一个PO</p></blockquote><h3 id="VO（View-Object）："><a href="#VO（View-Object）：" class="headerlink" title="VO（View Object）："></a>VO（View Object）：</h3><p>视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p><blockquote><p>用来承载前端交互数据，比如前端需要的数据来自三个数据库，那么我们就可以封装出一个vo实体，包含这三个表中某些字段。然后返回给前端</p></blockquote><h3 id="DO（Domain-Object）："><a href="#DO（Domain-Object）：" class="headerlink" title="DO（Domain Object）："></a>DO（Domain Object）：</h3><p>领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><blockquote><p>我查了很多的资料，基本别的很详细解释，而这个只有这一句话，甚至很多人都说可能不存在这个概念。我的理解他可能就像java中的抽象这个概念。</p><p>比如  人  可是我们项目中哪里需要传递这么一个抽象的类呢，比如我们可以传递一个po 人的信息，或者传递一个vo，人的行为和他的好基友们。所以这个可能只是停留在概念上面</p></blockquote><h3 id="BO（business-Object）："><a href="#BO（business-Object）：" class="headerlink" title="BO（business Object）："></a>BO（business Object）：</h3><p>业务对象，封装对象、复杂对象 ，里面可能包含多个类；</p><blockquote><p>BO 通常位于业务层，要区别于直接对外提供服务的服务层：</p></blockquote><h3 id="TO（Transfer-Objerct）："><a href="#TO（Transfer-Objerct）：" class="headerlink" title="TO（Transfer Objerct）："></a>TO（Transfer Objerct）：</h3><p>数据传输对象，不同应用程序之间传输的对象</p><blockquote><p>他和DTO作用相似，用于微服务间。</p></blockquote><h3 id="DTO（Data-Transfer-Object）："><a href="#DTO（Data-Transfer-Object）：" class="headerlink" title="DTO（Data Transfer Object）："></a>DTO（Data Transfer Object）：</h3><p>数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</p><blockquote><p>这个主要作用是在微服务与微服务之间相互调用时候传输的数据对象。</p></blockquote><h3 id="DAO（Data-Access-Object）"><a href="#DAO（Data-Access-Object）" class="headerlink" title="DAO（Data Access Object）"></a>DAO（Data Access Object）</h3><p>用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。</p><blockquote><p>用来访问数据库的对象，我们经常写数据库语句进行操作数据库，实际就是编写DAO</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object</tag>
      
      <tag>POJO</tag>
      
      <tag>DTO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 二叉树的最近公共祖先</title>
    <link href="/2020/07/27/jianzhi-offer/68%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/07/27/jianzhi-offer/68%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 1.</span>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 3.</span>        <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 4.</span>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 2. if(left != null and right != null)</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的最近公共祖先</title>
    <link href="/2020/07/27/jianzhi-offer/68%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/07/27/jianzhi-offer/68%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="/img/loading.gif" alt="img"></p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】构建乘积数组</title>
    <link href="/2020/07/27/jianzhi-offer/66.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <url>/2020/07/27/jianzhi-offer/66.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p>示例:</p><p>输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]</p><p>提示：</p><p>所有元素乘积之和不会溢出 32 位整数<br>a.length &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;        <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            tmp *= a[i + <span class="hljs-number">1</span>];            b[i] *= tmp;        &#125;        <span class="hljs-keyword">return</span> b;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把字符串转换成整数</title>
    <link href="/2020/07/27/jianzhi-offer/67.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <url>/2020/07/27/jianzhi-offer/67.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] c = str.trim().toCharArray();        <span class="hljs-keyword">if</span>(c.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>) sign = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] != <span class="hljs-string">'+'</span>) i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; c.length; j++) &#123;            <span class="hljs-keyword">if</span>(c[j] &lt; <span class="hljs-string">'0'</span> || c[j] &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">'7'</span>) <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;            res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">'0'</span>);        &#125;        <span class="hljs-keyword">return</span> sign * res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】不用加减乘除做加法</title>
    <link href="/2020/07/27/jianzhi-offer/65.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <url>/2020/07/27/jianzhi-offer/65.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p>示例:</p><p>输入: a = 1, b = 1<br>输出: 2</p><p>提示：</p><p>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span>            <span class="hljs-keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span>            a ^= b; <span class="hljs-comment">// a = 非进位和</span>            b = c; <span class="hljs-comment">// b = 进位</span>        &#125;        <span class="hljs-keyword">return</span> a;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】求1+2+…+n</title>
    <link href="/2020/07/27/jianzhi-offer/64.%20%E6%B1%821+2+%E2%80%A6+n/"/>
    <url>/2020/07/27/jianzhi-offer/64.%20%E6%B1%821+2+%E2%80%A6+n/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例 1：</p><p>输入: n = 3<br>输出: 6<br>示例 2：</p><p>输入: n = 9<br>输出: 45</p><p>限制：</p><p>1 &lt;= n &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>什么都不让用，那就递归</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    n += sumNums(n - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> n;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】股票的最大利润</title>
    <link href="/2020/07/27/jianzhi-offer/63.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2020/07/27/jianzhi-offer/63.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price : prices) &#123;            cost = Math.min(cost, price);            profit = Math.max(profit, price - cost);        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】圆圈中最后剩下的数字</title>
    <link href="/2020/07/27/jianzhi-offer/62.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/27/jianzhi-offer/62.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><p>输入: n = 5, m = 3<br>输出: 3<br>示例 2：</p><p>输入: n = 10, m = 17<br>输出: 2</p><p>限制：</p><p>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】扑克牌中的顺子</title>
    <link href="/2020/07/27/jianzhi-offer/61.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <url>/2020/07/27/jianzhi-offer/61.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p>示例 1:</p><p>输入: [1,2,3,4,5]<br>输出: True</p><p>示例 2:</p><p>输入: [0,0,1,2,5]<br>输出: True</p><p>限制：</p><p>数组长度为 5 </p><p>数组的数取值为 [0, 13] .</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> joker = <span class="hljs-number">0</span>;        Arrays.sort(nums); <span class="hljs-comment">// 数组排序</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++; <span class="hljs-comment">// 统计大小王数量</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 若有重复，提前返回 false</span>        &#125;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 59 - II. 队列的最大值</title>
    <link href="/2020/07/27/jianzhi-offer/59%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2020/07/27/jianzhi-offer/59%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    Queue&lt;Integer&gt; queue;    LinkedList&lt;Integer&gt; max;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        max = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-comment">//LinkedList是双端链表</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> max.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:max.getFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue.add(value);        <span class="hljs-keyword">while</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;max.getLast()&lt;value)&#123;<span class="hljs-comment">//注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。</span>            max.removeLast();        &#125;        max.add(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(max.size()!=<span class="hljs-number">0</span>&amp;&amp;queue.peek().equals(max.getFirst()))<span class="hljs-comment">//Integer类型的值的比较不能直接使用==</span>            max.removeFirst();        <span class="hljs-keyword">return</span> queue.size()==<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:queue.poll();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment">     * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment">     * int param_1 = obj.max_value();</span><span class="hljs-comment">     * obj.push_back(value);</span><span class="hljs-comment">     * int param_3 = obj.pop_front();</span><span class="hljs-comment">     */</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】 I. 滑动窗口的最大值</title>
    <link href="/2020/07/27/jianzhi-offer/59%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2020/07/27/jianzhi-offer/59%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><blockquote><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span> - k; j &lt; nums.length; i++, j++) &#123;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>])                deque.removeFirst(); <span class="hljs-comment">// 删除 deque 中对应的 nums[i-1]</span>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])                deque.removeLast(); <span class="hljs-comment">// 保持 deque 递减</span>            deque.addLast(nums[j]);            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)                res[i] = deque.peekFirst();  <span class="hljs-comment">// 记录窗口最大值</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】左旋转字符串</title>
    <link href="/2020/07/27/jianzhi-offer/58%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/27/jianzhi-offer/58%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：</p><p>1 &lt;= k &lt; s.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】翻转单词顺序</title>
    <link href="/2020/07/25/jianzhi-offer/58%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/07/25/jianzhi-offer/58%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：</p><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span>        <span class="hljs-keyword">int</span> j = s.length() - <span class="hljs-number">1</span>, i = j;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 搜索首个空格</span>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 添加单词</span>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">' '</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span>    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        String[] strs = s.trim().split(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 删除首尾空格，分割字符串</span>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒序遍历单词列表</span>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">""</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 遇到空单词则跳过</span>            res.append(strs[i] + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 将单词拼接至 StringBuilder</span>        &#125;        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串，删除尾部空格，并返回</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的连续正数序列</title>
    <link href="/2020/07/25/jianzhi-offer/57%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/25/jianzhi-offer/57%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;= target &lt;= 10^5</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的左边界</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的右边界</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口中数字的和</span>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (i &lt;= target / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (sum &lt; target) &#123;            <span class="hljs-comment">// 右边界向右移动</span>            sum += j;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 记录结果</span>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++) &#123;                arr[k-i] = k;            &#125;            res.add(arr);            <span class="hljs-comment">// 左边界向右移动</span>            sum -= i;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】和为s的两个数字</title>
    <link href="/2020/07/25/jianzhi-offer/57.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/25/jianzhi-offer/57.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p><p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">int</span> s = nums[i] + nums[j];            <span class="hljs-keyword">if</span>(s &lt; target) i++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; target) j--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; nums[i], nums[j] &#125;;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】56 - II. 数组中数字出现的次数 II</title>
    <link href="/2020/07/25/jianzhi-offer/56%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/"/>
    <url>/2020/07/25/jianzhi-offer/56%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>示例 1：</p><p>输入：nums = [3,4,3,3]<br>输出：4<br>示例 2：</p><p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p><p>限制：</p><p>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">大佬题解</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c : nums) &#123;        b = b ^ c &amp; ~ a;        a = a ^ c &amp; ~ b;    &#125;    <span class="hljs-keyword">return</span> b;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 数组中数字出现的次数</title>
    <link href="/2020/07/25/jianzhi-offer/56%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2020/07/25/jianzhi-offer/56%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：</p><p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p><p>限制：</p><p>2 &lt;= nums.length &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            x^=s;        &#125;        x&amp;=-x;        <span class="hljs-keyword">int</span> x1=<span class="hljs-number">0</span>,x2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s:nums)&#123;            <span class="hljs-keyword">if</span>((s&amp;x) ==<span class="hljs-number">0</span>) x1^=s;            <span class="hljs-keyword">else</span> x2^=s;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x1,x2&#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】平衡二叉树</title>
    <link href="/2020/07/25/jianzhi-offer/55%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/25/jianzhi-offer/55%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>      1     / \    2   2   / \  3   3 / \4   4</code></pre><p>返回 false 。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> dg(root)!=-<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dg</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=dg(root.left);        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right=dg(root.right);        <span class="hljs-keyword">if</span>(right==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> Math.abs(left-right)&lt;<span class="hljs-number">2</span>?Math.max(left,right)+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】55 - I. 二叉树的深度</title>
    <link href="/2020/07/25/jianzhi-offer/55%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <url>/2020/07/25/jianzhi-offer/55%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><p>提示：</p><p>节点总数 &lt;= 10000</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) tmp.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) tmp.add(node.right);            &#125;            queue = tmp;            res++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/2020/07/25/jianzhi-offer/54.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/25/jianzhi-offer/54.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4<br>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p><p>限制：</p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>本文解法基于此性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p><p>根据以上性质，易得二叉搜索树的 <strong>中序遍历倒序</strong> 为 <strong>递减序列</strong> 。</p><p>因此，求 “二叉搜索树第 <em>k</em> 大的节点” 可转化为求 “此树的中序遍历倒序的第 <em>k</em> 个节点”。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res, k;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.k = k;        dfs(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(--k == <span class="hljs-number">0</span>) res = root.val;        dfs(root.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 0～n-1中缺失的数字</title>
    <link href="/2020/07/25/jianzhi-offer/53%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/25/jianzhi-offer/53%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例 1:</p><p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的第k大节点</title>
    <link href="/2020/07/25/jianzhi-offer/53%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/"/>
    <url>/2020/07/25/jianzhi-offer/53%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(nums, target) - helper(nums, target - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] &lt;= tar) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】两个链表的第一个公共节点</title>
    <link href="/2020/07/25/jianzhi-offer/52.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/25/jianzhi-offer/52.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" alt="img"></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="/img/loading.gif" alt="img"></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>方法1，使用双指针</p><p>一个从A开始   结束之后指向B</p><p>一个从B开始 结束之后指向A</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;    <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    ListNode L = headA;    ListNode R = headB;    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-comment">//当一个节点达到一个链表的尾部，则从另一个链表继续，同时count++</span>    <span class="hljs-keyword">while</span> (L != R) &#123;        L = L.next;        R = R.next;        <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span>) &#123;            L = headB;            count ++;        &#125;        <span class="hljs-keyword">if</span> (R == <span class="hljs-keyword">null</span>) &#123;            R = headA;            count++;        &#125;        <span class="hljs-keyword">if</span> (count &gt;<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> L;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2020/07/24/xiangmu/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/24/xiangmu/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】跨域问题"><a href="#【项目笔记】跨域问题" class="headerlink" title="【项目笔记】跨域问题"></a>【项目笔记】跨域问题</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是 浏览器对javascript施加的安全限制。 • 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p><p><img src="https://img2.jimu98.cn/blog/20200724001043.png" srcset="/img/loading.gif" alt="image-20200724001043268"></p><h2 id="跨域流程"><a href="#跨域流程" class="headerlink" title="跨域流程"></a>跨域流程</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">具体点这里</a></p><p>看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>巴拉巴拉，这些不是重点，如果大家想看更多，强烈建议去看阮一峰老师的博客</p><p>那么这里着重说一下，非简单请求。</p><p>非简单请求，在请求前，需要发送<code>预检请求</code></p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><h2 id="跨域解决办法"><a href="#跨域解决办法" class="headerlink" title="跨域解决办法"></a>跨域解决办法</h2><h3 id="1-使用niinx部署为同一域"><a href="#1-使用niinx部署为同一域" class="headerlink" title="1.使用niinx部署为同一域"></a>1.使用niinx部署为同一域</h3><p><img src="https://img2.jimu98.cn/blog/20200724001945.png" srcset="/img/loading.gif" alt="image-20200724001945071"></p><h3 id="2-配置当次请求允许跨域"><a href="#2-配置当次请求允许跨域" class="headerlink" title="2.配置当次请求允许跨域"></a>2.配置当次请求允许跨域</h3><pre><code class="hljs mathematica"><span class="hljs-number">1</span>、添加响应头• Access-<span class="hljs-keyword">Control</span>-Allow-Origin：支持哪些来源的请求跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Methods：支持哪些方法跨域• Access-<span class="hljs-keyword">Control</span>-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含cookie• Access-<span class="hljs-keyword">Control</span>-Expose-Headers：跨域请求暴露的字段• CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到<span class="hljs-number">6</span>个基本字段：Cache-<span class="hljs-keyword">Control</span>、Content-<span class="hljs-keyword">Language</span>、Content-Type、Expires、<span class="hljs-keyword">Last</span>-Modified、Pragma。如果想拿到其他字段，就必须在Access-<span class="hljs-keyword">Control</span>-Expose-Headers里面指定。• Access-<span class="hljs-keyword">Control</span>-<span class="hljs-keyword">Max</span>-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</code></pre><blockquote></blockquote><h3 id="3…"><a href="#3…" class="headerlink" title="3….."></a>3…..</h3><p>办法相当多，合理使用</p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>箭头函数</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三级分类：递归树形结构数据</title>
    <link href="/2020/07/23/xiangmu/%E4%B8%89%E7%BA%A7%E5%88%86%E7%B1%BB%EF%BC%9A%E9%80%92%E5%BD%92%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/07/23/xiangmu/%E4%B8%89%E7%BA%A7%E5%88%86%E7%B1%BB%EF%BC%9A%E9%80%92%E5%BD%92%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】三级分类：递归树形结构数据"><a href="#【项目笔记】三级分类：递归树形结构数据" class="headerlink" title="【项目笔记】三级分类：递归树形结构数据"></a>【项目笔记】三级分类：递归树形结构数据</h1><blockquote><p>注意要熟悉 stream 写法</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1.查出所有分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter((categoryEntity) -&gt;                                                                categoryEntity.getParentCid() == <span class="hljs-number">0</span>                                                               ).map((menu) -&gt; &#123;        menu.setChildren(getChildrens(menu, entities));        <span class="hljs-keyword">return</span> menu;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-comment">//2.组装成父子树形结构</span>    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">//递归查找所有菜单的子菜单</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; &#123;        <span class="hljs-keyword">return</span> categoryEntity.getParentCid().equals(root.getCatId());    &#125;).map(categoryEntity -&gt; &#123;        <span class="hljs-comment">//1.找到子菜单</span>        categoryEntity.setChildren(getChildrens(categoryEntity, all));        <span class="hljs-keyword">return</span> categoryEntity;    &#125;).sorted((o1, o2) -&gt; &#123;        <span class="hljs-comment">//2.菜单的排序</span>        <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());    &#125;).collect(Collectors.toList());    <span class="hljs-keyword">return</span> children;&#125;<span class="hljs-comment">//for循环拼接</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CategoryEntity&gt; <span class="hljs-title">listWithTree</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 1.查询出所有的分类</span>    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 2.组装成父子的树形结构</span>    List&lt;CategoryEntity&gt; level1Menus = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 找到所有的一级分类</span>    <span class="hljs-keyword">for</span> (CategoryEntity entity : entities) &#123;        <span class="hljs-keyword">if</span> (entity.getParentCid() == <span class="hljs-number">0</span>) &#123;            level1Menus.add(entity);        &#125;    &#125;    <span class="hljs-keyword">for</span> (CategoryEntity level1Menu : level1Menus) &#123;        level1Menu.setChildren(getChildrens(level1Menu, entities));    &#125;    <span class="hljs-comment">//排序</span>    level1Menus.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> level1Menus;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * 递归查找所有的下级分类</span><span class="hljs-comment">     * 在这一级别的分类中找下级分类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 当前级别的分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> all  全部分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下一级分类</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CategoryEntity&gt; <span class="hljs-title">getChildrens</span><span class="hljs-params">(CategoryEntity root, List&lt;CategoryEntity&gt; all)</span> </span>&#123;    List&lt;CategoryEntity&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (CategoryEntity a : all) &#123;        <span class="hljs-keyword">if</span> (a.getParentCid().equals(root.getCatId())) &#123;            a.setChildren(getChildrens(a, all));            children.add(a);        &#125;    &#125;    children.sort(<span class="hljs-keyword">new</span> Comparator&lt;CategoryEntity&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(CategoryEntity o1, CategoryEntity o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> (o1.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o1.getSort()) - (o2.getSort() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : o2.getSort());        &#125;    &#125;);    <span class="hljs-keyword">return</span> children;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>箭头函数</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】VUE复习</title>
    <link href="/2020/07/23/xiangmu/Vue%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/07/23/xiangmu/Vue%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】VUE复习"><a href="#【项目笔记】VUE复习" class="headerlink" title="【项目笔记】VUE复习"></a>【项目笔记】VUE复习</h1><h2 id="MVVM思想"><a href="#MVVM思想" class="headerlink" title="MVVM思想"></a>MVVM思想</h2><p>MVVM的全名是Model-View-ViewModel，它的基本思路就是这样：</p><p><img src="https://pic3.zhimg.com/80/1d9336019baa5cabdf0e5e30b3effffb_hd.jpg" srcset="/img/loading.gif" alt="image"></p><p>M：即Model，模型，包括数据和一些基本操作</p><p>V：即View，试图，页面渲染结果</p><p>VM：即View-Model，模型与视图间的双向操作</p><p><img src="https://pic4.zhimg.com/80/edd0080fb145315fbc96164c219fee7e_hd.jpg" srcset="/img/loading.gif" alt="image"></p><h2 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h2><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官网链接</a></p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;num&quot;&gt;    &lt;button v-on:click&#x3D;&quot;num++&quot;&gt;点赞&lt;&#x2F;button&gt;    &lt;button v-on:click&#x3D;&quot;cancle&quot;&gt;取消&lt;&#x2F;button&gt;    &lt;h1&gt; &#123;&#123;name&#125;&#125; ,非常帅，有&#123;&#123;num&#125;&#125;个人为他点赞&#123;&#123;hello()&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;1、vue声明式渲染    let vm &#x3D; new Vue(&#123;        el: &quot;#app&quot;,&#x2F;&#x2F;绑定元素        data: &#123;  &#x2F;&#x2F;封装数据            name: &quot;张三&quot;,            num: 1        &#125;,        methods:&#123;  &#x2F;&#x2F;封装方法            cancle()&#123;                this.num -- ;            &#125;,            hello()&#123;                return &quot;1&quot;            &#125;        &#125;    &#125;);    &#x2F;&#x2F;2、双向绑定,模型变化，视图变化。反之亦然。    &#x2F;&#x2F;3、事件处理    &#x2F;&#x2F;v-xx：指令    &#x2F;&#x2F;1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的    &#x2F;&#x2F;2、指令来简化对dom的一些操作。    &#x2F;&#x2F;3、声明方法来做更复杂的操作。methods里面可以封装方法。&lt;&#x2F;script&gt;</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-text-v-html"><a href="#v-text-v-html" class="headerlink" title="v-text=   v-html="></a>v-text=   v-html=</h3><pre><code class="hljs js">&lt;span v-html=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;br/</span>&gt;&lt;span v-text=<span class="hljs-string">"msg"</span>&gt;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">data:&#123;</span><span class="hljs-regexp">    msg:"&lt;h1&gt;Hello&lt;/</span>h1&gt;<span class="hljs-string">",</span><span class="hljs-string">    link:"</span>http:<span class="hljs-comment">//www.baidu.com"</span>&#125;,</code></pre><h3 id="v-bind：-给任意属性绑定值-或者前面加"><a href="#v-bind：-给任意属性绑定值-或者前面加" class="headerlink" title="v-bind： 给任意属性绑定值  或者前面加 :"></a>v-bind： 给任意属性绑定值  或者前面加 :</h3><pre><code class="hljs js">&lt;a :href=<span class="hljs-string">"link"</span>&gt;gogogo&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- class,style  &#123;class名：加上？&#125;--&gt;</span><span class="hljs-regexp">    &lt;span v-bind:class="&#123;active:isActive,'text-danger':hasError&#125;"</span><span class="hljs-regexp">    :style="&#123;color: color1,fontSize: size&#125;"&gt;你好&lt;/</span>span&gt;data:&#123;    link: <span class="hljs-string">"http://www.baidu.com"</span>,isActive:<span class="hljs-literal">true</span>,hasError:<span class="hljs-literal">true</span>,color1:<span class="hljs-string">'red'</span>,size:<span class="hljs-string">'36px'</span>&#125;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model="></a>v-model=</h3><blockquote><p>在未来开发中，使用这个较多</p></blockquote><pre><code class="hljs js">精通的语言：    &lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Java"</span>&gt; java&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"PHP"</span>&gt; PHP&lt;br/&gt;&lt;input type=<span class="hljs-string">"checkbox"</span> v-model=<span class="hljs-string">"language"</span> value=<span class="hljs-string">"Python"</span>&gt; Python&lt;br/&gt;选中了 &#123;&#123;language.join(<span class="hljs-string">","</span>)&#125;&#125;data:&#123;    language: []&#125;</code></pre><h3 id="v-on：-绑定事件-或者直接写"><a href="#v-on：-绑定事件-或者直接写" class="headerlink" title="v-on： 绑定事件 或者直接写@"></a>v-on： 绑定事件 或者直接写@</h3><pre><code class="hljs js">&lt;!--事件中直接写js片段--&gt;    &lt;button v-on:click=<span class="hljs-string">"num++"</span>&gt;点赞&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;</span><span class="hljs-regexp">        &lt;button @click="cancle"&gt;取消&lt;/</span>button&gt;&lt;!--  --&gt;        &lt;h1&gt;有&#123;&#123;num&#125;&#125;个赞&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 事件修饰符 --&gt;</span><span class="hljs-regexp">&lt;div style="border: 1px solid red;padding: 20px;" v-on:click.once="hello"&gt;</span><span class="hljs-regexp">                大div</span><span class="hljs-regexp">&lt;div style="border: 1px solid blue;padding: 20px;" @click.stop="hello"&gt;</span><span class="hljs-regexp">    小div &lt;br /</span>&gt;    &lt;a href=<span class="hljs-string">"http://www.baidu.com"</span> @click.prevent.stop=<span class="hljs-string">"hello"</span>&gt;去百度&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;!-- 按键修饰符： --&gt;</span><span class="hljs-regexp">        &lt;input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10"&gt;&lt;br /</span>&gt;            提示：&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;script src="../</span>node_modules/vue/dist/vue.js<span class="hljs-string">"&gt;&lt;/script&gt;</span><span class="hljs-string"></span><span class="hljs-string">&lt;script&gt;</span><span class="hljs-string">        new Vue(&#123;</span>        el:"#app",        data:&#123;            num: <span class="hljs-number">1</span>        &#125;,        methods:&#123;            cancle()&#123;                <span class="hljs-keyword">this</span>.num--;            &#125;,            hello()&#123;                alert(<span class="hljs-string">"点击了"</span>)            &#125;        &#125;    &#125;)&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>阻止事件</p><blockquote><p>.stop 阻止事件冒泡到父元素<br>.prevent 阻止默认事件发生<br>.capture 使用事件捕获模式<br>.self 只有元素自身触发事件才 执行。(冒泡或捕获的都不执行 )<br>.once 只执行一-次</p></blockquote><p>按键修饰符</p><blockquote><p>.ctrl  =&gt; //Ctrl键</p><p>.enter =&gt; // enter键 </p><p>.tab =&gt; // tab键 </p><p>.delete (捕获“删除”和“退格”按键) =&gt; // 删除键 </p><p>.esc =&gt; // 取消键 .space =&gt; // 空格键 </p><p>.up =&gt; // 上 </p><p>.down =&gt; // 下 </p><p>.left =&gt; // 左 </p><p>.right =&gt; // 右</p></blockquote><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for="></a>v-for=</h3><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;ul&gt;    &lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(user,index) in users"</span> :key=<span class="hljs-string">"user.name"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"user.gender == '女'"</span>&gt;        &lt;!-- <span class="hljs-number">1</span>、显示user信息：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span> --&gt;            当前索引：&#123;&#123;index&#125;&#125; ==&gt; &#123;&#123;user.name&#125;&#125;  ==&gt;   &#123;&#123;user.gender&#125;&#125; ==&gt;&#123;&#123;user.age&#125;&#125; &lt;br&gt;                &lt;!-- <span class="hljs-number">2</span>、获取数组下标：v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(item,index) in items"</span> --&gt;                &lt;!-- <span class="hljs-number">3</span>、遍历对象：                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"value in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key) in object"</span>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key,index) in object"</span>     --&gt;    对象信息：&lt;span v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(v,k,i) in user"</span>&gt;&#123;&#123;k&#125;&#125;==&#123;&#123;v&#125;&#125;==&#123;&#123;i&#125;&#125;；&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;</span><span class="hljs-regexp">    &lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;ul&gt;</span><span class="hljs-regexp">    &lt;li v-for="(num,index) in nums" :key="index"&gt;&lt;/</span>li&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp">&lt;script&gt;         </span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            users: [&#123; name: '柳岩', gender: '女', age: 21 &#125;,</span><span class="hljs-regexp">                    &#123; name: '张三', gender: '男', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '范冰冰', gender: '女', age: 24 &#125;,</span><span class="hljs-regexp">                    &#123; name: '刘亦菲', gender: '女', age: 18 &#125;,</span><span class="hljs-regexp">                    &#123; name: '古力娜扎', gender: '女', age: 25 &#125;],</span><span class="hljs-regexp">            nums: [1,2,3,4,4]</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">    &#125;)</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><blockquote><p>v-else和v-else-if</p></blockquote><pre><code class="hljs js">&lt;!--     v-<span class="hljs-keyword">if</span>，顾名思义，条件判断。当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被渲染。    v-show，当得到结果为<span class="hljs-literal">true</span>时，所在的元素才会被显示。 --&gt;&lt;button v-on:click=<span class="hljs-string">"show = !show"</span>&gt;点我呀&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;!-- 1、使用v-if显示 --&gt;</span><span class="hljs-regexp">    &lt;h1 v-if="show"&gt;if=看到我....&lt;/</span>h1&gt;&lt;!-- <span class="hljs-number">2</span>、使用v-show显示 --&gt;    &lt;h1 v-show=<span class="hljs-string">"show"</span>&gt;show=看到我&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/</span>button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-if="random&gt;=0.75"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.75</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>=<span class="hljs-string">"random&gt;=0.5"</span>&gt;    看到我啦？！ &amp;gt;= <span class="hljs-number">0.5</span>&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;h1 v-else-if="random&gt;=0.2"&gt;</span><span class="hljs-regexp">    看到我啦？！ &amp;gt;= 0.2</span><span class="hljs-regexp">&lt;/</span>h1&gt;&lt;h1 v-<span class="hljs-keyword">else</span>&gt;    看到我啦？！ &amp;lt; <span class="hljs-number">0.2</span>&lt;<span class="hljs-regexp">/h1&gt;</span></code></pre><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><blockquote><p>计算属性 是指一个可以计算的属性（这不是废话吗<del>~</del>）</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//计算属性可以写到computed里面</span>computed: &#123;    totalPrice() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xyjPrice * <span class="hljs-keyword">this</span>.xyjNum + <span class="hljs-keyword">this</span>.shzPrice * <span class="hljs-keyword">this</span>.shzNum    &#125;&#125;,<span class="hljs-comment">//监听器</span>watch: &#123;    xyjNum(newVal, oldVal) &#123;        <span class="hljs-keyword">if</span> (newVal &gt;= <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">"库存超出限制"</span>;            <span class="hljs-keyword">this</span>.xyjNum = <span class="hljs-number">3</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">""</span>;        &#125;    &#125;&#125;,</code></pre><blockquote><p>过滤器</p></blockquote><pre><code class="hljs js">&#123;&#123;user.gender | genderFilter&#125;&#125; ==&gt; &#123;&#123;user.gender | gFilter&#125;&#125;<span class="hljs-comment">//   `|`  表示管道符</span><span class="hljs-comment">//全局过滤器</span>Vue.filter(<span class="hljs-string">"gFilter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"男~~~"</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"女~~~"</span>;    &#125;&#125;)filters: &#123;    <span class="hljs-comment">//// filters 定义局部过滤器，只可以在当前vue实例中使用</span>    genderFilter(val) &#123;        <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"男"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"女"</span>;        &#125;    &#125;&#125;</code></pre><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。<br>但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</p><p>在vue里面，所有的vue实例都是组件</p></blockquote><p><img src="http://www.uml.org.cn/AJAX/images/201905069.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs js"><span class="hljs-comment">//用的时候就直接这么用</span>&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp">&lt;counter&gt;&lt;/</span>counter&gt;&lt;counter&gt;&lt;<span class="hljs-regexp">/counter&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/1、全局声明注册一个组件</span><span class="hljs-regexp">Vue.component("counter", &#123;</span><span class="hljs-regexp">    template: `&lt;button v-on:click="count++"&gt;我被点击了 &#123;&#123;count&#125;&#125; 次&lt;/</span>button&gt;<span class="hljs-string">`,</span><span class="hljs-string">    data() &#123;</span><span class="hljs-string">        return &#123;</span><span class="hljs-string">            count: 1</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;);</span><span class="hljs-string"></span><span class="hljs-string">//2、局部声明一个组件</span><span class="hljs-string">const buttonCounter = &#123;</span><span class="hljs-string">    template: `</span>&lt;button v-on:click=<span class="hljs-string">"count++"</span>&gt;我被点击了 &#123;&#123;count&#125;&#125; 次~~~&lt;<span class="hljs-regexp">/button&gt;`,</span><span class="hljs-regexp">    data() &#123;</span><span class="hljs-regexp">        return &#123;</span><span class="hljs-regexp">            count: 1</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;;</span></code></pre><h2 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">官网地址</a></p><p><img src="https://cn.vuejs.org/images/lifecycle.png" srcset="/img/loading.gif" alt="Vue 实例生命周期"></p><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;span id=<span class="hljs-string">"num"</span>&gt;&#123;&#123;num&#125;&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">&lt;button @click="num++"&gt;赞！&lt;/</span>button&gt;&lt;h2&gt;&#123;&#123;name&#125;&#125;，有&#123;&#123;num&#125;&#125;个人点赞&lt;<span class="hljs-regexp">/h2&gt;</span><span class="hljs-regexp">&lt;/</span>div&gt;&lt;script src=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">    let app = new Vue(&#123;</span><span class="hljs-regexp">        el: "#app",</span><span class="hljs-regexp">        data: &#123;</span><span class="hljs-regexp">            name: "张三",</span><span class="hljs-regexp">            num: 100</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        methods: &#123;</span><span class="hljs-regexp">            show() &#123;</span><span class="hljs-regexp">                return this.name;</span><span class="hljs-regexp">            &#125;,</span><span class="hljs-regexp">            add() &#123;</span><span class="hljs-regexp">                this.num++;</span><span class="hljs-regexp">            &#125;</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeCreate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeCreate=============");</span><span class="hljs-regexp">            console.log("数据模型未加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法未加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板未加载：" + document.getElementById("num"));</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        created: function () &#123;</span><span class="hljs-regexp">            console.log("=========created=============");</span><span class="hljs-regexp">            console.log("数据模型已加载：" + this.name, this.num);</span><span class="hljs-regexp">            console.log("方法已加载：" + this.show());</span><span class="hljs-regexp">            console.log("html模板已加载：" + document.getElementById("num"));</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeMount() &#123;</span><span class="hljs-regexp">            console.log("=========beforeMount=============");</span><span class="hljs-regexp">            console.log("html模板未渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        mounted() &#123;</span><span class="hljs-regexp">            console.log("=========mounted=============");</span><span class="hljs-regexp">            console.log("html模板已渲染：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        beforeUpdate() &#123;</span><span class="hljs-regexp">            console.log("=========beforeUpdate=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板未更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;,</span><span class="hljs-regexp">        updated() &#123;</span><span class="hljs-regexp">            console.log("=========updated=============");</span><span class="hljs-regexp">            console.log("数据模型已更新：" + this.num);</span><span class="hljs-regexp">            console.log("html模板已更新：" + document.getElementById("num").innerText);</span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;);</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h2 id="vue模块化开发"><a href="#vue模块化开发" class="headerlink" title="vue模块化开发"></a>vue模块化开发</h2><blockquote><p>1、npm install webpack -g<br>全局安装webpack<br>2、npm install -g @vue/cli-init<br>全局安装vue脚手架<br>3、初始化vue项目;<br>vue init webpack appname:  vue 脚手架使用webpack模板初始化一个 appname项目<br>4、启动vue项目;<br>项目的package.json中有scripts, 代表我们能运行的命令<br>npm start = npm run dev:  启动项目</p></blockquote><pre><code class="hljs 1c"><span class="hljs-comment">//文件目录结构</span><span class="hljs-comment">//build  跟打包相关目录</span><span class="hljs-comment">//config  配置信息，一般配置一些端口之类的，然后区分不同的环境</span><span class="hljs-comment">//node_modules   用npm安装的所有项目依赖</span><span class="hljs-comment">//src  编写代码的文件夹</span><span class="hljs-comment">//assets </span><span class="hljs-comment">//components</span><span class="hljs-comment">//router  路由配置</span><span class="hljs-comment">//main.js  主程序</span><span class="hljs-comment">//static  静态资源文件</span><span class="hljs-comment">//.babelrc  语法转义</span><span class="hljs-comment">//package.json  需要的依赖   类似于maven的pom</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>promist</tag>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/2020/07/23/jianzhi-offer/50.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/2020/07/23/jianzhi-offer/50.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例:</p><p>s = “abaccdeff”<br>返回 “b”</p><p>s = “”<br>返回 “ “</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>//方法1</p><ol><li><p>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt; 1&gt;1 ”。</p></li><li><p>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 11 的字符”，并返回。</p></li></ol><p>//方法2</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//方法1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            <span class="hljs-keyword">if</span>(dic.get(c)) <span class="hljs-keyword">return</span> c;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;<span class="hljs-comment">//方法2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : sc)            dic.put(c, !dic.containsKey(c));        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;           <span class="hljs-keyword">if</span>(d.getValue()) <span class="hljs-keyword">return</span> d.getKey();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】丑数</title>
    <link href="/2020/07/23/jianzhi-offer/49.%20%E4%B8%91%E6%95%B0/"/>
    <url>/2020/07/23/jianzhi-offer/49.%20%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>示例:</p><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>1 是丑数。<br>n 不超过1690。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题目如果循环遍历当然可以，但是更好的做法是动态规划</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最长不含重复字符的子字符串</title>
    <link href="/2020/07/23/jianzhi-offer/48.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/23/jianzhi-offer/48.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：</p><p>s.length &lt;= 40000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;            <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取索引 i</span>            dic.put(s.charAt(j), j); <span class="hljs-comment">// 更新哈希表</span>            tmp = tmp &lt; j - i ? tmp + <span class="hljs-number">1</span> : j - i; <span class="hljs-comment">// dp[j - 1] -&gt; dp[j]</span>            res = Math.max(res, tmp); <span class="hljs-comment">// max(dp[j - 1], dp[j])</span>        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】礼物的最大价值</title>
    <link href="/2020/07/23/jianzhi-offer/47.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2020/07/23/jianzhi-offer/47.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>提示：</p><p>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 初始化第一行</span>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) <span class="hljs-comment">// 初始化第一列</span>            grid[i][<span class="hljs-number">0</span>] += grid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)                 grid[i][j] += Math.max(grid[i][j - <span class="hljs-number">1</span>], grid[i - <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数字翻译成字符串</title>
    <link href="/2020/07/23/jianzhi-offer/46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/23/jianzhi-offer/46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p>提示：</p><p>0 &lt;= num &lt; 231</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        String str=String.valueOf(num);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length()];        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = (str.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>);    dp[<span class="hljs-number">1</span>] = n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;str.length();i++)&#123;            n = (str.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (str.charAt(i) - <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">9</span> &amp;&amp; n &lt; <span class="hljs-number">26</span>) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[str.length() - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目笔记】ES6复习</title>
    <link href="/2020/07/22/xiangmu/ES6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/07/22/xiangmu/ES6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目笔记】ES6复习"><a href="#【项目笔记】ES6复习" class="headerlink" title="【项目笔记】ES6复习"></a>【项目笔记】ES6复习</h1><h2 id="ES6介绍"><a href="#ES6介绍" class="headerlink" title="ES6介绍"></a>ES6介绍</h2><p>ECMAScript6.0是JavaScript语言的下一代标准。。。。。。等等介绍。。</p><h2 id="let语法"><a href="#let语法" class="headerlink" title="let语法"></a>let语法</h2><pre><code class="hljs js"><span class="hljs-comment">//var声明的变量往往会越域</span><span class="hljs-comment">//let声明的变量有严格的局部作用域</span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>    &#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">//b is not defined</span><span class="hljs-comment">//var可以声明多次</span><span class="hljs-comment">//let只能声明一次</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span><span class="hljs-keyword">let</span> n = <span class="hljs-number">4</span>  <span class="hljs-comment">//报错</span><span class="hljs-comment">//var 会变量提升</span><span class="hljs-comment">//let 不存在变量提升</span><span class="hljs-built_in">console</span>.log(x)  <span class="hljs-comment">//undefined</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><span class="hljs-built_in">console</span>.log(y)  <span class="hljs-comment">//y is not defined</span><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span><span class="hljs-comment">//因此，以后我们经常使用let生成变量</span><span class="hljs-comment">//同时我们也经常使用const声明常量  声明之后就不可以再改变</span></code></pre><h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">//原来</span><span class="hljs-keyword">let</span> a = arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">let</span> b = arr[<span class="hljs-number">1</span>]<span class="hljs-keyword">let</span> c = arr[<span class="hljs-number">2</span>]<span class="hljs-built_in">console</span>.log(a, b, c)<span class="hljs-comment">//现在</span><span class="hljs-keyword">let</span> [x, y, z] = arr<span class="hljs-built_in">console</span>.log(x, y, z)<span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-comment">//原来</span><span class="hljs-comment">// const name = person.name</span><span class="hljs-comment">// const age = person.age</span><span class="hljs-comment">// const language = person.language</span><span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>:abc, age, language &#125; = person<span class="hljs-built_in">console</span>.log(name, age, language)</code></pre><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> str=<span class="hljs-string">`&lt;div&gt;</span><span class="hljs-string">            &lt;span&gt;hello jimu98&lt;/span&gt;</span><span class="hljs-string">        &lt;/div&gt;`</span><span class="hljs-comment">//以前这些内容需要字符串拼接，现在只需要一个反引号</span></code></pre><h3 id="字符串插入变量和表达式"><a href="#字符串插入变量和表达式" class="headerlink" title="字符串插入变量和表达式"></a>字符串插入变量和表达式</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"这是一个函数"</span>&#125;<span class="hljs-keyword">let</span> info =<span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>,今年<span class="hljs-subst">$&#123;age+<span class="hljs-number">10</span>&#125;</span>了，我想说<span class="hljs-subst">$&#123;fun()&#125;</span>`</span><span class="hljs-built_in">console</span>.log(info)</code></pre><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><pre><code class="hljs js"><span class="hljs-comment">//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    b=b || <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>))<span class="hljs-comment">//现在可以写默认值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a,b=<span class="hljs-number">1</span></span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">20</span>))</code></pre><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><pre><code class="hljs js"><span class="hljs-comment">//不定参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">...values</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(values.length)&#125;fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="hljs js"><span class="hljs-comment">//以前声明一个方法</span><span class="hljs-keyword">var</span> print1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(obj)&#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(obj)print(<span class="hljs-string">"Hello"</span>)<span class="hljs-comment">//多个参数</span><span class="hljs-keyword">var</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + bprint(sum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<span class="hljs-comment">//箭头函数+解构</span><span class="hljs-keyword">var</span> hello2 = <span class="hljs-function">(<span class="hljs-params">&#123; name &#125;</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello,"</span> + name)hello2(person)</code></pre><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><h3 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">"jimu98"</span>,    age: <span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>, <span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>]&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person))<span class="hljs-comment">//["name", "age", "language"]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(person))<span class="hljs-comment">//["jimu98", 21, Array(3)]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(person)) <span class="hljs-comment">//[Array(2), Array(2), Array(2)]</span><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;<span class="hljs-built_in">Object</span>.assign(target, source1, source2)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(target))<span class="hljs-comment">//["a", "b", "c"]</span></code></pre><h3 id="声明对象的简写"><a href="#声明对象的简写" class="headerlink" title="声明对象的简写"></a>声明对象的简写</h3><pre><code class="hljs js"><span class="hljs-comment">//声明对象简写</span><span class="hljs-keyword">const</span> age = <span class="hljs-number">23</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">"jimu98"</span><span class="hljs-comment">//原来</span><span class="hljs-keyword">const</span> person1 = &#123; <span class="hljs-attr">age</span>: age, <span class="hljs-attr">name</span>: name &#125;<span class="hljs-comment">//现在</span><span class="hljs-keyword">const</span> person2=&#123;age,name&#125;<span class="hljs-built_in">console</span>.log(person2)</code></pre><h3 id="函数的简写"><a href="#函数的简写" class="headerlink" title="函数的简写"></a>函数的简写</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">"jack"</span>,    <span class="hljs-comment">//原来</span>    eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;,    eat2: <span class="hljs-function"><span class="hljs-params">food</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(person.name + <span class="hljs-string">"在吃"</span> + food),<span class="hljs-comment">//这里不能用this</span>    eat3(food)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food)    &#125;&#125;person.eat(<span class="hljs-string">"香蕉"</span>)person.eat2(<span class="hljs-string">"苹果"</span>)person.eat3(<span class="hljs-string">"梨"</span>)</code></pre><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><pre><code class="hljs js"><span class="hljs-comment">// 1、拷贝对象（深拷贝）</span><span class="hljs-keyword">let</span> p1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> someone = &#123; ...p1 &#125;<span class="hljs-built_in">console</span>.log(someone)  <span class="hljs-comment">//&#123;name: "Amy", age: 15&#125;</span><span class="hljs-comment">// 2、合并对象</span><span class="hljs-keyword">let</span> age1 = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">15</span> &#125;<span class="hljs-keyword">let</span> name1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Amy"</span> &#125;<span class="hljs-keyword">let</span> p2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"zhangsan"</span>&#125;p2 = &#123; ...age1, ...name1 &#125; <span class="hljs-comment">//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值</span><span class="hljs-built_in">console</span>.log(p2)</code></pre><p>map和reduce方法</p><p>//map()接受一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><pre><code class="hljs js"><span class="hljs-comment">//数组中新增了map和reduce方法。</span><span class="hljs-comment">//map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'20'</span>, <span class="hljs-string">'-5'</span>, <span class="hljs-string">'3'</span>];<span class="hljs-comment">//原来</span>arr = arr.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>&#125;);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//现在</span>arr = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//传入回调函数</span><span class="hljs-keyword">let</span> res = arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"上一次处理后"</span> + a)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"当前正在处理的"</span> + b)    <span class="hljs-keyword">return</span> a + b;&#125;)<span class="hljs-built_in">console</span>.log(res)</code></pre><h2 id="promist"><a href="#promist" class="headerlink" title="promist"></a>promist</h2><blockquote><p>这个是用来处理异步</p><p>在之前我们写ajax中，需要一层层嵌套，通过这个就可以使用then关键字</p><p>最后还可以抽取出来公共代码，使得代码更加优雅</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//1、查出当前用户信息</span><span class="hljs-comment">//2、按照当前用户的id查出他的课程</span><span class="hljs-comment">//3、按照当前课程id查出分数</span><span class="hljs-comment">// $.ajax(&#123;</span><span class="hljs-comment">//     url: "mock/user.json",</span><span class="hljs-comment">//     success(data) &#123;</span><span class="hljs-comment">//         console.log("查询用户：", data);</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//             success(data) &#123;</span><span class="hljs-comment">//                 console.log("查询到课程：", data);</span><span class="hljs-comment">//                 $.ajax(&#123;</span><span class="hljs-comment">//                     url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//                     success(data) &#123;</span><span class="hljs-comment">//                         console.log("查询到分数：", data);</span><span class="hljs-comment">//                     &#125;,</span><span class="hljs-comment">//                     error(error) &#123;</span><span class="hljs-comment">//                         console.log("出现异常了：" + error);</span><span class="hljs-comment">//                     &#125;</span><span class="hljs-comment">//                 &#125;);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error(error) &#123;</span><span class="hljs-comment">//                 console.log("出现异常了：" + error);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;,</span><span class="hljs-comment">//     error(error) &#123;</span><span class="hljs-comment">//         console.log("出现异常了：" + error);</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">//1、Promise可以封装异步操作</span><span class="hljs-comment">// let p = new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//     //1、异步操作</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: "mock/user.json",</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询用户成功:", data)</span><span class="hljs-comment">//             resolve(data);</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//             reject(err);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// p.then((obj) =&gt; &#123;</span><span class="hljs-comment">//     return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//         $.ajax(&#123;</span><span class="hljs-comment">//             url: `mock/user_corse_$&#123;obj.id&#125;.json`,</span><span class="hljs-comment">//             success: function (data) &#123;</span><span class="hljs-comment">//                 console.log("查询用户课程成功:", data)</span><span class="hljs-comment">//                 resolve(data);</span><span class="hljs-comment">//             &#125;,</span><span class="hljs-comment">//             error: function (err) &#123;</span><span class="hljs-comment">//                 reject(err)</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;);</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">// &#125;).then((data) =&gt; &#123;</span><span class="hljs-comment">//     console.log("上一步的结果", data)</span><span class="hljs-comment">//     $.ajax(&#123;</span><span class="hljs-comment">//         url: `mock/corse_score_$&#123;data.id&#125;.json`,</span><span class="hljs-comment">//         success: function (data) &#123;</span><span class="hljs-comment">//             console.log("查询课程得分成功:", data)</span><span class="hljs-comment">//         &#125;,</span><span class="hljs-comment">//         error: function (err) &#123;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;);</span><span class="hljs-comment">// &#125;)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, data</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        $.ajax(&#123;            url: url,            data: data,            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;                resolve(data);            &#125;,            error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;                reject(err)            &#125;        &#125;)    &#125;);&#125;<span class="hljs-keyword">get</span>("mock/user.json")    .then((data) =&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"用户查询成功~~~:"</span>, data)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(`mock/user_corse_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data) =&gt; &#123;</span><span class="hljs-string">    console.log("课程查询成功~~~:", data)</span><span class="hljs-string">    return get(`</span>mock/corse_score_$&#123;data.id&#125;.json<span class="hljs-string">`);</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .then((data)=&gt;&#123;</span><span class="hljs-string">    console.log("课程成绩查询成功~~~:", data)</span><span class="hljs-string">&#125;)</span><span class="hljs-string">    .catch((err)=&gt;&#123;</span><span class="hljs-string">    console.log("出现异常",err)</span><span class="hljs-string">&#125;);</span></code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>如果我们想在写的代码里面调用其他js，就可以采用模块化的方法</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//export  导出</span>varname =<span class="hljs-string">"jack"</span><span class="hljs-keyword">var</span> age=<span class="hljs-number">21</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>&#123;    <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-keyword">export</span> &#123;name,age,add&#125;<span class="hljs-comment">//import 导入</span><span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">"./hello.js"</span><span class="hljs-keyword">import</span> &#123;name,age,add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./user.js"</span><span class="hljs-comment">//使用</span><span class="hljs-keyword">let</span> res = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(res)</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
      <tag>ES6</tag>
      
      <tag>promist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】把数组排成最小的数</title>
    <link href="/2020/07/22/jianzhi-offer/45.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/45.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><p>提示:</p><p>0 &lt; nums.length &lt;= 100<br>说明:</p><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)             strs[i] = String.valueOf(nums[i]);        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(String s : strs)            res.append(s);        <span class="hljs-keyword">return</span> res.toString();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/2020/07/22/jianzhi-offer/44.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/22/jianzhi-offer/44.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p>示例 1：</p><p>输入：n = 3<br>输出：3<br>示例 2：</p><p>输入：n = 11<br>输出：0</p><p>限制：</p><p>0 &lt;= n &lt; 2^31</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0.9</span> *Math.pow(<span class="hljs-number">10</span>,i)*i)&#123;            n -= <span class="hljs-number">0.9</span>*Math.pow(<span class="hljs-number">10</span>,i)*i;            i++;        &#125;        <span class="hljs-keyword">int</span> s=(n-<span class="hljs-number">1</span>)/i+(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,i-<span class="hljs-number">1</span>);        String res=Integer.toString(s);        <span class="hljs-keyword">return</span> res.charAt((n-<span class="hljs-number">1</span>)%i)-<span class="hljs-string">'0'</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】1～n整数中1出现的次数</title>
    <link href="/2020/07/22/jianzhi-offer/43.%201%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/43.%201%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>示例 1：</p><p>输入：n = 12<br>输出：5<br>示例 2：</p><p>输入：n = 13<br>输出：6</p><p>限制：</p><p>1 &lt;= n &lt; 2^31</p><p>题解</p><p>根据当前位 curcur 值的不同，分为以下三种情况：</p><p>当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：high×digit</p><blockquote><p>如下图所示，以 n = 2304为例，求 digit = 10（即十位）的 11 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155713.png" srcset="/img/loading.gif" alt="image-20200723155713725"></p><p>当 cur = 1时： 此位 11 的出现次数由高位 high 和低位 low 决定，计算公式为：high×digit+low+1</p><blockquote><p>如下图所示，以 n = 2314 为例，求 digit = 10digit=10 （即十位）的 1出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155726.png" srcset="/img/loading.gif" alt="image-20200723155726661"></p><p>当 cur = 2, 3, …, 9时： 此位 1 的出现次数只由高位 high决定，计算公式为：(high+1)×digit</p><blockquote><p>如下图所示，以 n = 2324 为例，求 digit = 10（即十位）的 1 出现次数。</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155740.png" srcset="/img/loading.gif" alt="image-20200723155740761"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> digit=<span class="hljs-number">1</span>,res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> high=n/<span class="hljs-number">10</span>,low=<span class="hljs-number">0</span>,cur=n%<span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)res+=high*digit;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">1</span>) res+=high*digit+low+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> res+= (high+<span class="hljs-number">1</span>) * digit;            low+=cur*digit;            cur = high%<span class="hljs-number">10</span>;            high/=<span class="hljs-number">10</span>;            digit*=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】连续子数组的最大和</title>
    <link href="/2020/07/22/jianzhi-offer/42.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2020/07/22/jianzhi-offer/42.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>简单dp</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> [] dp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [nums.length];        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max=dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            dp[i]=Math.max(nums[i],nums[i]+dp[i-<span class="hljs-number">1</span>]);            max=Math.max(max,dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;<span class="hljs-comment">//-----------直接用原来数组-------------</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            nums[i]=Math.max(nums[i],nums[i]+nums[i-<span class="hljs-number">1</span>]);            max=Math.max(max,nums[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数据流中的中位数</title>
    <link href="/2020/07/22/jianzhi-offer/41.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2020/07/22/jianzhi-offer/41.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p><p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：</p><p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p><p>限制：</p><p>最多会对 addNum、findMedia进行 50000 次调用。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>建立一个 <strong>小顶堆</strong> <em>A</em> 和 <strong>大顶堆</strong> <em>B</em> ，各保存列表的一半元素</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    Queue&lt;Integer&gt; A,B;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y-x));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;            A.add(num);            B.add(A.poll());        &#125;<span class="hljs-keyword">else</span>&#123;            B.add(num);            A.add(B.poll());        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.size()!=B.size()?A.peek():(A.peek()+B.peek())/<span class="hljs-number">2.0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>小顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数组中出现次数超过一半的数字</title>
    <link href="/2020/07/21/jianzhi-offer/39.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/21/jianzhi-offer/39.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 50000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> x=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;                x=nums[i];                y=<span class="hljs-number">1</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(x!=nums[i])&#123;                y--;            &#125;<span class="hljs-keyword">else</span>                y++;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】最小的k个数</title>
    <link href="/2020/07/21/jianzhi-offer/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/07/21/jianzhi-offer/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p>限制：</p><p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这道题直接排序即可，但是还是多写几次快排吧，毕竟太难记了</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span>        <span class="hljs-keyword">return</span> quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] quickSearch(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span>        <span class="hljs-keyword">int</span> j = partition(nums, lo, hi);        <span class="hljs-keyword">if</span> (j == k) &#123;            <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span>        <span class="hljs-keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k): quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);    &#125;    <span class="hljs-comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;        <span class="hljs-keyword">int</span> v = nums[lo];        <span class="hljs-keyword">int</span> i = lo, j = hi + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);            <span class="hljs-keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">int</span> t = nums[j];            nums[j] = nums[i];            nums[i] = t;        &#125;        nums[lo] = nums[j];        nums[j] = v;        <span class="hljs-keyword">return</span> j;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】字符串的排列</title>
    <link href="/2020/07/21/jianzhi-offer/38.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/07/21/jianzhi-offer/38.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Set&lt;String&gt; res = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;&#125;;        <span class="hljs-keyword">boolean</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()];        dfs(s,<span class="hljs-string">""</span>,visited);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s,String letter,<span class="hljs-keyword">boolean</span>[] visited)</span></span>&#123;        <span class="hljs-keyword">if</span>(s.length()==letter.length())&#123;            res.add(letter);            <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//为了退出递归</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">char</span> c=s.charAt(i);            <span class="hljs-keyword">if</span>(visited[i])<span class="hljs-keyword">continue</span>;            visited[i]=<span class="hljs-keyword">true</span>;            dfs(s,letter+c,visited);            visited[i]=<span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】序列化二叉树</title>
    <link href="/2020/07/21/jianzhi-offer/37.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/21/jianzhi-offer/37.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]”</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"[]"</span>;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"["</span>);        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>) &#123;                res.append(node.val + <span class="hljs-string">","</span>);                queue.add(node.left);                queue.add(node.right);            &#125;            <span class="hljs-keyword">else</span> res.append(<span class="hljs-string">"null,"</span>);        &#125;        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);        res.append(<span class="hljs-string">"]"</span>);        <span class="hljs-keyword">return</span> res.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">"[]"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        String[] vals = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">","</span>);        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.left);            &#125;            i++;            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">"null"</span>)) &#123;                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));                queue.add(node.right);            &#125;            i++;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树与双向链表</title>
    <link href="/2020/07/21/jianzhi-offer/36.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/21/jianzhi-offer/36.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p> <img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" srcset="/img/loading.gif" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>直接使用中序遍历可以按顺序遍历，之后定义一个pre节点用来构造链表。</p><p>pre就是已经构造好的链表，cur是要被构造的，所以 cur.left=pre  pre=cur</p><p>但是pre的right也要指向cur</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Node pre,head;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        dfs(root);        head.left=pre;        pre.right=head;                <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span>;        dfs(cur.left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>)pre.right=cur;        <span class="hljs-keyword">else</span> head=cur;        cur.left=pre;        pre=cur;        dfs(cur.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】复杂链表的复制</title>
    <link href="/2020/07/13/jianzhi-offer/35.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2020/07/13/jianzhi-offer/35.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>示例 1：</p><p><img src="https://img2.jimu98.cn/blog/20200723155648.png" srcset="/img/loading.gif" alt="image-20200723155648550"></p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Node cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));            cur=cur.next;        &#125;        cur=head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            map.get(cur).next=map.get(cur.next);            map.get(cur).random=map.get(cur.random);            cur=cur.next;        &#125;        <span class="hljs-keyword">return</span> map.get(head);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树中和为某一值的路径</title>
    <link href="/2020/07/13/jianzhi-offer/34.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/07/13/jianzhi-offer/34.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \    / \7    2  5   1</code></pre><p>返回:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><p>提示：</p><p>节点总数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;        recur(root, sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        path.add(root.val);        tar -= root.val;        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            res.add(<span class="hljs-keyword">new</span> LinkedList(path));        recur(root.left, tar);        recur(root.right, tar);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉搜索树的后序遍历序列</title>
    <link href="/2020/07/13/jianzhi-offer/33.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/13/jianzhi-offer/33.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code> 5/ \</code></pre><p>   2   6<br>  / <br> 1   3<br>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><p>提示：</p><p>数组长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> root = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = postorder.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])            root = stack.pop();            stack.add(postorder[i]);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅲ. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) Collections.reverse(tmp);            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】Ⅱ. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】I. 从上到下打印二叉树</title>
    <link href="/2020/07/13/jianzhi-offer/32%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/13/jianzhi-offer/32%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p><p>[3,9,20,15,7]</p><p>提示：</p><p>节点总数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            TreeNode node = queue.poll();            ans.add(node.val);            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++)            res[i] = ans.get(i);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】栈的压入、弹出序列</title>
    <link href="/2020/07/12/jianzhi-offer/31.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/12/jianzhi-offer/31.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p><p>提示：</p><p>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : pushed) &#123;            stack.push(num); <span class="hljs-comment">// num 入栈</span>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; <span class="hljs-comment">// 循环判断与出栈</span>                stack.pop();                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】包含min函数的栈</title>
    <link href="/2020/07/12/jianzhi-offer/30.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2020/07/12/jianzhi-offer/30.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><p>提示：</p><p>各函数的调用总次数不超过 20000 次</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Stack&lt;Integer&gt; A, B;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        A.add(x);        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)            B.add(x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))            B.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> A.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> B.peek();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】顺时针打印矩阵</title>
    <link href="/2020/07/12/jianzhi-offer/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/07/12/jianzhi-offer/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>限制：</p><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = matrix.length - <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(r + <span class="hljs-number">1</span>) * (b + <span class="hljs-number">1</span>)];        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="hljs-comment">// left to right.</span>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="hljs-comment">// top to bottom.</span>            <span class="hljs-keyword">if</span>(l &gt; --r) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="hljs-comment">// right to left.</span>            <span class="hljs-keyword">if</span>(t &gt; --b) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="hljs-comment">// bottom to top.</span>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】对称的二叉树</title>
    <link href="/2020/07/12/jianzhi-offer/28.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/12/jianzhi-offer/28.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>  1 / \2   2 \   \ 3    3</code></pre><p>示例 1：</p><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">true</span> : recur(root.left, root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二叉树的镜像</title>
    <link href="/2020/07/12/jianzhi-offer/27.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2020/07/12/jianzhi-offer/27.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>    4   /  \  2    7 / \   / \1   3 6   9</code></pre><p>镜像输出：</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>示例 1：</p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode tmp = root.left;        root.left = mirrorTree(root.right);        root.right = mirrorTree(tmp);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】树的子结构</title>
    <link href="/2020/07/12/jianzhi-offer/26.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2020/07/12/jianzhi-offer/26.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>示例 1：</p><p>输入：A = [1,2,3], B = [3,1]<br>输出：false<br>示例 2：</p><p>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true<br>限制：</p><p>0 &lt;= 节点个数 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">return</span> (A != <span class="hljs-keyword">null</span> &amp;&amp; B != <span class="hljs-keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】合并两个排序的链表</title>
    <link href="/2020/07/12/jianzhi-offer/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/12/jianzhi-offer/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p><p>0 &lt;= 链表长度 &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>为了方便，在做链表题的时候一定要给自己加一个伪头节点</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dum = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), cur = dum;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;                cur.next = l1;                l1 = l1.next;            &#125;            <span class="hljs-keyword">else</span> &#123;                cur.next = l2;                l2 = l2.next;            &#125;            cur = cur.next;        &#125;        cur.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> dum.next;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/07/12/jianzhi-offer/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/12/jianzhi-offer/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">null</span>;ListNode cur = head;ListNode tmp = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            tmp=cur.next;            cur.next=pre;            pre=cur;            cur=tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>反转链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】链表中倒数第 k 个节点</title>
    <link href="/2020/07/12/jianzhi-offer/22.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20k%20%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/12/jianzhi-offer/22.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20k%20%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode former = head, latter = head;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)            former = former.next;        <span class="hljs-keyword">while</span>(former != <span class="hljs-keyword">null</span>) &#123;            former = former.next;            latter = latter.next;        &#125;        <span class="hljs-keyword">return</span> latter;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/07/11/jianzhi-offer/21.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/07/11/jianzhi-offer/21.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>示例：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首尾双指针<br>定义头指针 leftleft ，尾指针 rightright .<br>leftleft 一直往右移，直到它指向的值为偶数<br>rightright 一直往左移， 直到它指向的值为奇数<br>交换 nums[left]nums[left] 和 nums[right]nums[right] .<br>重复上述操作，直到 left == rightleft==right .</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>, tmp;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;            tmp = nums[i];            nums[i] = nums[j];            nums[j] = tmp;        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】表示数值的字符串</title>
    <link href="/2020/07/11/jianzhi-offer/20.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/07/11/jianzhi-offer/20.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://img2.jimu98.cn/blog/20200723155550.png" srcset="/img/loading.gif" alt="image-20200723155550061"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;        Map[] states = &#123;            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">0</span>); put(<span class="hljs-string">'s'</span>, <span class="hljs-number">1</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;, <span class="hljs-comment">// 0.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">4</span>); &#125;&#125;,                           <span class="hljs-comment">// 1.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">'.'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;, <span class="hljs-comment">// 2.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); put(<span class="hljs-string">'e'</span>, <span class="hljs-number">5</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,              <span class="hljs-comment">// 3.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">3</span>); &#125;&#125;,                                        <span class="hljs-comment">// 4.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'s'</span>, <span class="hljs-number">6</span>); put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                           <span class="hljs-comment">// 5.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); &#125;&#125;,                                        <span class="hljs-comment">// 6.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">'d'</span>, <span class="hljs-number">7</span>); put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;,                           <span class="hljs-comment">// 7.</span>            <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="hljs-string">' '</span>, <span class="hljs-number">8</span>); &#125;&#125;                                         <span class="hljs-comment">// 8.</span>        &#125;;        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> t;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) t = <span class="hljs-string">'d'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) t = <span class="hljs-string">'s'</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'.'</span> || c == <span class="hljs-string">'e'</span> || c == <span class="hljs-string">'E'</span> || c == <span class="hljs-string">' '</span>) t = c;            <span class="hljs-keyword">else</span> t = <span class="hljs-string">'?'</span>;            <span class="hljs-keyword">if</span>(!states[p].containsKey(t)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            p = (<span class="hljs-keyword">int</span>)states[p].get(t);        &#125;        <span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】删除链表的节点</title>
    <link href="/2020/07/11/jianzhi-offer/18.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/07/11/jianzhi-offer/18.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head.val==val)<span class="hljs-keyword">return</span> head.next;        ListNode p=head;        ListNode q=head;        head=head.next;        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(head.val==val)&#123;                q.next=head.next;                <span class="hljs-keyword">return</span> p;            &#125;            q=head;            head=head.next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】打印从1到最大的n位数</title>
    <link href="/2020/07/11/jianzhi-offer/17.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <url>/2020/07/11/jianzhi-offer/17.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例 1:</p><p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p>说明：</p><p>用返回一个整数列表来代替打印<br>n 为正整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;        <span class="hljs-keyword">int</span> Size=(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Size];        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>)&#123;            result[i]=i+<span class="hljs-number">1</span>;            i++;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】数值的整数次方</title>
    <link href="/2020/07/11/jianzhi-offer/16.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2020/07/11/jianzhi-offer/16.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:</p><p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p><p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> b = n;        <span class="hljs-keyword">double</span> res=<span class="hljs-number">1.0</span>;        <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;            x=<span class="hljs-number">1</span>/x;            b=-b;        &#125;        <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)res*=x;            x*=x;            b&gt;&gt;=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二进制中1的个数</title>
    <link href="/2020/07/11/jianzhi-offer/15.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/07/11/jianzhi-offer/15.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例 1：</p><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是逐位判断</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res += n &amp; <span class="hljs-number">1</span>;            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><blockquote><p>下面看其他大佬们的位运算</p></blockquote><p>n&amp;(n-1)即可将最后一位1置为0</p><p><img src="https://img2.jimu98.cn/blog/20200723155527.png" srcset="/img/loading.gif" alt="image-20200723155527400"></p><p>那么循环置为0   就可以将全部的1统计出来了</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            res++;            n &amp;= n - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】II. 剪绳子 II</title>
    <link href="/2020/07/11/jianzhi-offer/14-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/"/>
    <url>/2020/07/11/jianzhi-offer/14-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p>提示：</p><p>2 &lt;= n &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>与剪绳子相比，这个需要手写一个快速幂</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) rem = (rem * x) % p;            x = (x * x) % p;        &#125;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】剪绳子</title>
    <link href="/2020/07/11/jianzhi-offer/14-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2020/07/11/jianzhi-offer/14-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>提示：</p><p>2 &lt;= n &lt;= 58</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>先说结论，绳子尽量切割成多个3，至于为什么，我也不会</p><p>但是，比如四   1和3 明显不如 2和2</p><p>最终结论：<br>最优： 33 。把绳子尽可能切为多个长度为 33 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,2 三种情况。<br>次优： 22 。若最后一段绳子长度为 22 ；则保留，不再拆为 1+11+1 。<br>最差： 11 。若最后一段绳子长度为 11 ；则应把一份 3 + 13+1 替换为 2 + 22+2，因为 2 * 2 &gt; 3 * 1 </p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】机器人的运动范围</title>
    <link href="/2020/07/11/jianzhi-offer/13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2020/07/11/jianzhi-offer/13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><p>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：</p><p>输入：m = 3, n = 1, k = 0<br>输出：1<br>提示：</p><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>注意，这里是不能进入行坐标和列坐标的数位之和大于k的格子。  是“数位之和”</p><p>所以不可以简单的循环，因为有些区域数值可以达到，但是走不到</p></blockquote><p><img src="https://img2.jimu98.cn/blog/20200723155448.png" srcset="/img/loading.gif" alt="image-20200723155447989"></p><p>比如这张图</p><p><img src="https://img2.jimu98.cn/blog/20200723155502.png" srcset="/img/loading.gif" alt="image-20200723155502511"></p><pre><code class="hljs java"><span class="hljs-comment">//dfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> m, n, k;    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.m = m; <span class="hljs-keyword">this</span>.n = n; <span class="hljs-keyword">this</span>.k = k;        <span class="hljs-keyword">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> si, <span class="hljs-keyword">int</span> sj)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        visited[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj) + dfs(i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span>);    &#125;&#125;<span class="hljs-comment">//bfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue= <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt;();        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span>[] x = queue.poll();            <span class="hljs-keyword">int</span> i = x[<span class="hljs-number">0</span>], j = x[<span class="hljs-number">1</span>], si = x[<span class="hljs-number">2</span>], sj = x[<span class="hljs-number">3</span>];            <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">continue</span>;            visited[i][j] = <span class="hljs-keyword">true</span>;            res ++;            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj &#125;);            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span> &#125;);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】矩阵中的路径</title>
    <link href="/2020/07/11/jianzhi-offer/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/07/11/jianzhi-offer/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例 1：</p><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false<br>提示：</p><p>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> []dx=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,dy=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] words = word.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;                <span class="hljs-keyword">if</span>(dfs(board,words,i,j,<span class="hljs-number">0</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][]board,<span class="hljs-keyword">char</span> [] word,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> tmp)</span></span>&#123;        <span class="hljs-keyword">if</span>(word[tmp]!=board[i][j])<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(tmp==word.length-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;            <span class="hljs-keyword">int</span> new_x=i+dx[k],new_y=j+dy[k];            <span class="hljs-keyword">if</span>(new_x&lt;<span class="hljs-number">0</span> || new_x&gt;= board.length || new_y&lt;<span class="hljs-number">0</span> || new_y&gt;= board[<span class="hljs-number">0</span>].length)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">char</span> c=board[i][j];            board[i][j]=<span class="hljs-string">'/'</span>;            <span class="hljs-keyword">if</span>(dfs(board,word,new_x,new_y,tmp+<span class="hljs-number">1</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            board[i][j]=c;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】旋转数组的最小数字</title>
    <link href="/2020/07/10/jianzhi-offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/jianzhi-offer/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j=numbers.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;j) &#123;            <span class="hljs-keyword">int</span> mid=(i+j)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(numbers[mid]&gt;numbers[j])                i=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid]&lt;numbers[j])                j=mid;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> numbers[i];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>旋转数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】青蛙跳台问题</title>
    <link href="/2020/07/10/jianzhi-offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/10/jianzhi-offer/10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：2<br>示例 2：</p><p>输入：n = 7<br>输出：21<br>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>其实这个题目就是斐波那契数列，但是用到了记忆化</p><p>这么一说  不就有点dp的味道了吗，对，没错。其实算法间没那么清晰的界限。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】斐波那契数列一</title>
    <link href="/2020/07/10/jianzhi-offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2020/07/10/jianzhi-offer/10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：1<br>示例 2：</p><p>输入：n = 5<br>输出：5</p><p>提示：</p><p>0 &lt;= n &lt;= 100</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>, next = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(N-- &gt; <span class="hljs-number">0</span>) &#123;            next = next%<span class="hljs-number">1000000007</span> + curr;            curr = next - curr;        &#125;        <span class="hljs-keyword">return</span> curr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>斐波那契</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】用两个栈实现队列</title>
    <link href="/2020/07/10/jianzhi-offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/07/10/jianzhi-offer/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Deque&lt;Integer&gt; stack1;    Deque&lt;Integer&gt; stack2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();        stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        stack1.push(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果第二个栈为空，就把第一个全部倒进第二个</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;                stack2.push(stack1.pop());            &#125;        &#125;        <span class="hljs-comment">//判断第二个栈是否为空，空就返回-1</span>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> stack2.pop();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】重建二叉树</title>
    <link href="/2020/07/10/jianzhi-offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/10/jianzhi-offer/07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>递归解法</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map &lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.length;i++)map.put(inorder[i],i);        <span class="hljs-keyword">return</span> dfs(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> pl,<span class="hljs-keyword">int</span> pr,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> il,<span class="hljs-keyword">int</span> ir)</span></span>&#123;        <span class="hljs-keyword">if</span>(pl&gt;pr)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[pl]);        <span class="hljs-keyword">int</span> k=map.get(root.val);        TreeNode left = dfs(preorder,pl+<span class="hljs-number">1</span>,pl+k-il,inorder,il,k-<span class="hljs-number">1</span>);        TreeNode right = dfs(preorder,pl+k-il+<span class="hljs-number">1</span>,pr,inorder,k+<span class="hljs-number">1</span>,ir);        root.left=left;        root.right=right;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】从尾到头打印链表</title>
    <link href="/2020/07/10/jianzhi-offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/10/jianzhi-offer/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;        List &lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;            list.add(head.val);            head=head.next;        &#125;        <span class="hljs-keyword">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [list.size()];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;            res[i]=list.get(res.length-<span class="hljs-number">1</span>-i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】找出数组中重复的数字</title>
    <link href="/2020/07/10/jianzhi-offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/10/jianzhi-offer/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;  <span class="hljs-comment">//看题目要求，这一段可以不写</span>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span> || nums[i]&gt;n)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">while</span>(nums[i]!=i)&#123;                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<span class="hljs-keyword">return</span> nums[i];                swap(nums,i,nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp=nums[a];        nums[a]=nums[b];        nums[b]=tmp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】替换空格</title>
    <link href="/2020/07/10/jianzhi-offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2020/07/10/jianzhi-offer/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p>限制：</p><p>0 &lt;= s 的长度 &lt;= 10000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> length = s.length();        <span class="hljs-keyword">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length * <span class="hljs-number">3</span>];        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">char</span> c = s.charAt(i);            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;                array[size++] = <span class="hljs-string">'%'</span>;                array[size++] = <span class="hljs-string">'2'</span>;                array[size++] = <span class="hljs-string">'0'</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                array[size++] = c;            &#125;        &#125;        String newStr = <span class="hljs-keyword">new</span> String(array, <span class="hljs-number">0</span>, size);  <span class="hljs-comment">//记住这种转换方法</span>        <span class="hljs-keyword">return</span> newStr;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指Offer】二维数组中的查找</title>
    <link href="/2020/07/10/jianzhi-offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/07/10/jianzhi-offer/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数target。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>常规办法就是遍历寻找，或者二分，但是这个题很取巧</p><p>比如我们将要求的数和右上角进行比较</p><p>如果右上角小于target，那么这一行所有的数小于target  也就是i++</p><p>如果右上角大于target，那么这一列所有的数都大于target   也就是j–</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;-<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(matrix[i][j]==target)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)i++;            <span class="hljs-keyword">else</span> j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Gateway微服务网关</title>
    <link href="/2020/07/08/goujian/12.Gateway%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    <url>/2020/07/08/goujian/12.Gateway%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Gateway微服务网关"><a href="#【项目创建流程】Gateway微服务网关" class="headerlink" title="【项目创建流程】Gateway微服务网关"></a>【项目创建流程】Gateway微服务网关</h1><h2 id="网关基本概念"><a href="#网关基本概念" class="headerlink" title="网关基本概念"></a>网关基本概念</h2><h3 id="1、API网关介绍"><a href="#1、API网关介绍" class="headerlink" title="1、API网关介绍"></a>1、API网关介绍</h3><p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><p>（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。</p><p>（2）存在跨域请求，在一定场景下处理相对复杂。</p><p>（3）认证复杂，每个服务都需要独立认证。</p><p>（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</p><p>以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p><h3 id="2、Spring-Cloud-Gateway"><a href="#2、Spring-Cloud-Gateway" class="headerlink" title="2、Spring Cloud Gateway"></a>2、Spring Cloud Gateway</h3><p><strong>Spring cloud gateway</strong>是spring官方基于Spring 5.0和Spring Boot2.0等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。</p><h3 id="3、Spring-Cloud-Gateway-核心概念"><a href="#3、Spring-Cloud-Gateway-核心概念" class="headerlink" title="3、Spring Cloud Gateway 核心概念"></a>3、Spring Cloud Gateway 核心概念</h3><p>下面介绍一下Spring Cloud Gateway中几个重要的概念。</p><p>（1）路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter组成。如果断言路由为真，则说明请求的URL和配置匹配</p><p>（2）断言。Java8中的断言函数。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。</p><p>（3）过滤器。一个标准的Spring webFilter。Spring cloud gateway中的filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。</p><h3 id="4、执行流程"><a href="#4、执行流程" class="headerlink" title="4、执行流程"></a>4、执行流程</h3><p>如下图所示，Spring cloud Gateway发出请求。然后再由Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway web handler。Handler再通过指定的过滤器链将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154454.png" srcset="/img/loading.gif" alt="image-20200723154454083"></p><p><strong>4、特点</strong></p><p>优点：</p><ul><li>性能强劲：是第一代网关Zuul的1.6倍</li><li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li><li>设计优雅，容易扩展</li></ul><p>缺点：</p><ul><li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li><li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li><li>需要Spring Boot 2.0及以上的版本，才支持</li></ul><h2 id="搭建Gateway服务"><a href="#搭建Gateway服务" class="headerlink" title="搭建Gateway服务"></a>搭建Gateway服务</h2><h3 id="创建父模块infrastructure"><a href="#创建父模块infrastructure" class="headerlink" title="创建父模块infrastructure"></a>创建父模块infrastructure</h3><h3 id="创建子模块api-gateway"><a href="#创建子模块api-gateway" class="headerlink" title="创建子模块api_gateway"></a>创建子模块api_gateway</h3><h3 id="配置pom"><a href="#配置pom" class="headerlink" title="配置pom"></a>配置pom</h3><p>在api_gateway的pom中添加如下依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 网关 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h3 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h3><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">9110</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">infrastructure-apigateway</span> <span class="hljs-comment"># 服务名</span></code></pre><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><p>修改日志输出目录名为 apigateway</p><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><blockquote><p>gataway依赖common，课是common引入了mybatisplus操作，所有有数据库操作，因此需要排除数据库操作</p><p>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class} )</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfrastructureApiGatewayApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(InfrastructureApiGatewayApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="启动网关"><a href="#启动网关" class="headerlink" title="启动网关"></a>启动网关</h2><h3 id="配置路由和跨域"><a href="#配置路由和跨域" class="headerlink" title="配置路由和跨域"></a>配置路由和跨域</h3><h4 id="1、路由和断言"><a href="#1、路由和断言" class="headerlink" title="1、路由和断言"></a>1、路由和断言</h4><p>application.yml文件中添加路由配置</p><ul><li>-：表示数组元素，可以配置多个节点</li><li>id：配置的唯一标识，可以和微服务同名，也可以起别的名字，区别于其他 Route。</li><li>uri：路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li><li>predicates：断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li><li>Path：路径形式的断言。当匹配这个路径时，断言条件成立</li><li>/**：一个或多个层次的路径</li></ul><pre><code class="hljs dts"><span class="hljs-meta">#spring:</span><span class="hljs-symbol">  cloud:</span><span class="hljs-symbol">    gateway:</span><span class="hljs-symbol">      routes:</span>      - id: service-edu<span class="hljs-symbol">        uri:</span> http:<span class="hljs-comment">//localhost:8110</span><span class="hljs-symbol">        predicates:</span>        - Path=<span class="hljs-meta-keyword">/user/</span>**</code></pre><h5 id="内置路由断言工厂"><a href="#内置路由断言工厂" class="headerlink" title="内置路由断言工厂"></a>内置路由断言工厂</h5><p>Predicate(断言) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。</p><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><h6 id="1、基于Datetime"><a href="#1、基于Datetime" class="headerlink" title="1、基于Datetime"></a>1、基于Datetime</h6><p>此类型的断言根据时间做判断，主要有三个：</p><ul><li>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期</li><li>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期</li><li>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内</li></ul><pre><code class="hljs angelscript">- After=<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>T23:<span class="hljs-number">59</span>:<span class="hljs-number">59.789</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>[Asia/Shanghai]</code></pre><h6 id="2、基于远程地址"><a href="#2、基于远程地址" class="headerlink" title="2、基于远程地址"></a>2、基于远程地址</h6><p> RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中</p><pre><code class="hljs angelscript">- RemoteAddr=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">24</span></code></pre><h6 id="3、基于Cookie"><a href="#3、基于Cookie" class="headerlink" title="3、基于Cookie"></a>3、基于Cookie</h6><p>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Cookie</span>=chocolate, ch.</code></pre><h6 id="4、基于Header"><a href="#4、基于Header" class="headerlink" title="4、基于Header"></a>4、基于Header</h6><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Header</span>=X-Request-Id, \d+</code></pre><h6 id="5、基于Host"><a href="#5、基于Host" class="headerlink" title="5、基于Host"></a>5、基于Host</h6><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Host</span>=**.testhost.org</code></pre><h6 id="6、基于Method请求方法"><a href="#6、基于Method请求方法" class="headerlink" title="6、基于Method请求方法"></a>6、基于Method请求方法</h6><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。</p><pre><code class="hljs oxygene">- <span class="hljs-function"><span class="hljs-keyword">Method</span>=<span class="hljs-title">GET</span></span></code></pre><h6 id="7、基于Path请求路径"><a href="#7、基于Path请求路径" class="headerlink" title="7、基于Path请求路径"></a>7、基于Path请求路径</h6><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。</p><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/foo/</span>**</span></code></pre><h6 id="8、基于Query请求参数"><a href="#8、基于Query请求参数" class="headerlink" title="8、基于Query请求参数"></a>8、基于Query请求参数</h6><p>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。</p><pre><code class="hljs routeros">- <span class="hljs-attribute">Query</span>=url,baidu</code></pre><h6 id="9、基于路由权重"><a href="#9、基于路由权重" class="headerlink" title="9、基于路由权重"></a>9、基于路由权重</h6><p>WeightRoutePredicateFactory：接收一个[组名,权重]，然后对于同一个组内的路由按照权重转发</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route1</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host1</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group3,</span> <span class="hljs-number">1</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_route2</span>   <span class="hljs-attr">uri:</span> <span class="hljs-string">host2</span>   <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=</span> <span class="hljs-string">group3,</span> <span class="hljs-number">9</span></code></pre><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><h6 id="一、过滤器的基本概念"><a href="#一、过滤器的基本概念" class="headerlink" title="一、过滤器的基本概念"></a>一、过滤器的基本概念</h6><p>1、作用</p><p>过滤器就是在请求的传递过程中，对请求和响应做一些修改</p><p>2、生命周期</p><p>客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p><p>pre： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现参数校验、权限校验、流量监控、日志输出、协议转换等；</p><p>post：这种过滤器在路由到达微服务以后执行。这种过滤器可用做响应内容、响应头的修改，日志的输出，流量监控等。</p><p><img src="https:////img2.jimu98.cn/blog/20200723154536.png" srcset="/img/loading.gif" alt="image-20200723154536196"></p><p>3、分类</p><p>局部过滤器 GatewayFilter：作用在某一个路由上</p><p>全局过滤器 GlobalFilter：作用全部路由上</p><h6 id="二、局部过滤器"><a href="#二、局部过滤器" class="headerlink" title="二、局部过滤器"></a>二、局部过滤器</h6><p>1、内置局部过滤器</p><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下</p><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">service-edu</span>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-edu</span>  <span class="hljs-attr">predicates:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**,</span> <span class="hljs-string">/*/edu/**</span>  <span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=250</span> <span class="hljs-comment"># 修改返回状态码</span></code></pre><p>测试：</p><p><img src="https:////img2.jimu98.cn/blog/20200723154605.png" srcset="/img/loading.gif" alt="image-20200723154605180"></p><h6 id="三、全局过滤器"><a href="#三、全局过滤器" class="headerlink" title="三、全局过滤器"></a>三、全局过滤器</h6><p>1、内置全局过滤器</p><p><img src="https:////img2.jimu98.cn/blog/20200723154630.png" srcset="/img/loading.gif" alt="image-20200723154630370"></p><p>内置全局过滤器的使用举例：负载均衡过滤器</p><pre><code class="hljs dts"><span class="hljs-symbol">lb:</span><span class="hljs-comment">//service-edu</span></code></pre><p>2、自定义全局过滤器</p><p>定义一个Filter实现 GlobalFilter 和 Ordered接口</p><p><code>自定义转发路径</code></p><pre><code class="hljs yaml"><span class="hljs-attr">filters:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\&#123;segment&#125;</span></code></pre><p>2、测试网关路由转发</p><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><p>请求转发到：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:8110/user/info</a></p><h3 id="通过nacos注册中心"><a href="#通过nacos注册中心" class="headerlink" title="通过nacos注册中心"></a>通过nacos注册中心</h3><h4 id="1、网关中添加依赖"><a href="#1、网关中添加依赖" class="headerlink" title="1、网关中添加依赖"></a>1、网关中添加依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、主类添加注解"><a href="#2、主类添加注解" class="headerlink" title="2、主类添加注解"></a>2、主类添加注解</h4><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableDiscoveryClient</span>  <span class="hljs-comment">//SpringBoot2.0之后可以省略</span></code></pre><h4 id="3、添加nacos配置"><a href="#3、添加nacos配置" class="headerlink" title="3、添加nacos配置"></a>3、添加nacos配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><h4 id="4、添加gateway配置"><a href="#4、添加gateway配置" class="headerlink" title="4、添加gateway配置"></a>4、添加gateway配置</h4><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span><span class="hljs-comment">#    gateway:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">locator:</span>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># gateway可以发现nacos中的微服务</span></code></pre><h4 id="5、修改uri配置"><a href="#5、修改uri配置" class="headerlink" title="5、修改uri配置"></a>5、修改uri配置</h4><p>将uri的地址修改成注册中心中的微服务地址，网关姜葱nacos中按照名称获取微服务</p><p>lb：表示在集群环境下通过负载均衡的方式调用</p><pre><code class="hljs groovy"><span class="hljs-string">uri:</span> <span class="hljs-string">lb:</span><span class="hljs-comment">//service-edu  #内置负载均衡过滤器</span></code></pre><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><p>访问：<a href="http://localhost:9110/user/info" target="_blank" rel="noopener">http://localhost:9110/user/info</a></p><h4 id="7、匹配多个path"><a href="#7、匹配多个path" class="headerlink" title="7、匹配多个path"></a>7、匹配多个path</h4><pre><code class="hljs haml">-<span class="ruby"> Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span></code></pre><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><h4 id="1、前端配置"><a href="#1、前端配置" class="headerlink" title="1、前端配置"></a>1、前端配置</h4><p>修改guli-admin中 config/dev.env.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">BASE_API: '"http://127.0.0.1:<span class="hljs-number">9110</span>"',</code></pre><h4 id="2、删除后端跨域配置"><a href="#2、删除后端跨域配置" class="headerlink" title="2、删除后端跨域配置"></a>2、删除后端跨域配置</h4><p>此时可以删除微服务中的跨域注解 <em>@CrossOrigin</em></p><p><em>例如 service_edu中 LoginController的跨域注解</em></p><h4 id="3、跨域配置"><a href="#3、跨域配置" class="headerlink" title="3、跨域配置"></a>3、跨域配置</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.infrastructure.apigateway.config;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        config.addAllowedMethod(<span class="hljs-string">"*"</span>);        config.addAllowedOrigin(<span class="hljs-string">"*"</span>);        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource(<span class="hljs-keyword">new</span> PathPatternParser());        source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(source);    &#125;&#125;</code></pre><p>注意：去掉后端的所有跨域配置</p><h3 id="完整的路由配置"><a href="#完整的路由配置" class="headerlink" title="完整的路由配置"></a>完整的路由配置</h3><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><pre><code class="hljs haml">routes:-<span class="ruby"> <span class="hljs-symbol">id:</span> service-edu</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-edu</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/user/</span>**, <span class="hljs-regexp">/*/edu</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-cms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-cms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/cms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-oss</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-oss</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/oss</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-sms</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-sms</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/sms</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-trade</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-trade</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/trade</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-ucenter</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-ucenter</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/ucenter</span><span class="hljs-regexp">/**</span></span><span class="ruby">- <span class="hljs-symbol">id:</span> service-vod</span><span class="ruby">  <span class="hljs-symbol">uri:</span> <span class="hljs-symbol">lb:</span>/<span class="hljs-regexp">/service-vod</span></span><span class="ruby">  <span class="hljs-symbol">predicates:</span></span><span class="ruby">  - Path=<span class="hljs-regexp">/*/vod</span><span class="hljs-regexp">/**</span></span></code></pre><h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><p>（1）修改guli-site中 utils/request.js，BASE_API指定到网关地址</p><pre><code class="hljs 1c">baseURL: 'http://127.0.0.1:<span class="hljs-number">9110</span>',</code></pre><p>（2）所有的api模块中的baseURL可以删除</p><p>（3）guli-admin上传相关表单中action地址的修改</p><p>data中定义：</p><pre><code class="hljs css"><span class="hljs-selector-tag">BASE_API</span>: <span class="hljs-selector-tag">process</span><span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.BASE_API</span></code></pre><p>html中使用：</p><pre><code class="hljs clojure"><span class="hljs-symbol">:action=</span><span class="hljs-string">"BASE_API+'/admin/oss/file/upload?module=avatar'"</span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】集成Redis缓存</title>
    <link href="/2020/07/08/goujian/11.%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%92%8CRedis/"/>
    <url>/2020/07/08/goujian/11.%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%92%8CRedis/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】集成Redis缓存"><a href="#【项目创建流程】集成Redis缓存" class="headerlink" title="【项目创建流程】集成Redis缓存"></a>【项目创建流程】集成Redis缓存</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>由于首页数据变化不是很频繁，而且首页访问量相对较大，所以我们有必要把首页数据缓存到redis中，减少数据库压力和提高访问速度。</p><h3 id="2、RedisTemplate"><a href="#2、RedisTemplate" class="headerlink" title="2、RedisTemplate"></a>2、RedisTemplate</h3><p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是Spring Data Redis中对Jedis api的高度封装。</p><p>Spring Data Redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化功能，支持发布订阅，并对spring cache进行了实现。</p><h2 id="二、引入redis"><a href="#二、引入redis" class="headerlink" title="二、引入redis"></a>二、引入redis</h2><h3 id="1、项目中集成redis"><a href="#1、项目中集成redis" class="headerlink" title="1、项目中集成redis"></a>1、项目中集成redis</h3><p>common父模块中添加redis依赖，Spring Boot 2.0以上默认通过commons-pool2连接池连接redis</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring boot redis缓存引入 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- lecttuce 缓存连接池--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加redis连接配置"><a href="#2、添加redis连接配置" class="headerlink" title="2、添加redis连接配置"></a>2、添加redis连接配置</h3><p>service_cms 和 service_edu 的 application.yml 中添加如下配置</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.100</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span> <span class="hljs-comment">#默认为空</span>    <span class="hljs-attr">lettuce:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#最大连接数，负值表示没有限制，默认8</span>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span>    <span class="hljs-comment">#最大阻塞等待时间，负值表示没限制，默认-1</span>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>     <span class="hljs-comment">#最大空闲连接，默认8</span>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>     <span class="hljs-comment">#最小空闲连接，默认0</span></code></pre><h3 id="3、配置Redis"><a href="#3、配置Redis" class="headerlink" title="3、配置Redis"></a>3、配置Redis</h3><p>service-base添加RedisConfig</p><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.atguigu.guli.service.base.config;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 我们自定义一个 RedisTemplate，设置序列化器，这样我们可以很方便的操作实例对象。</span><span class="hljs-comment"> * 否则redis自动使用对象的jdk序列化</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    @Bean    <span class="hljs-keyword">public</span> RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;<span class="hljs-keyword">String</span>, Serializable&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-type">RedisTemplate</span>&lt;&gt;();        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">StringRedisSerializer</span>());<span class="hljs-comment">//key序列化方式</span>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-type">GenericJackson2JsonRedisSerializer</span>());<span class="hljs-comment">//value序列化</span>        redisTemplate.setConnectionFactory(connectionFactory);                <span class="hljs-keyword">return</span> redisTemplate;    &#125;&#125;</code></pre><h2 id="三、测试redisTemplate"><a href="#三、测试redisTemplate" class="headerlink" title="三、测试redisTemplate"></a>三、测试redisTemplate</h2><h3 id="1、测试redis数据存储"><a href="#1、测试redis数据存储" class="headerlink" title="1、测试redis数据存储"></a>1、测试redis数据存储</h3><p>ApiAdController中添加下面的方法进行测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@PostMapping(<span class="hljs-meta-string">"save-test"</span>)</span><span class="hljs-keyword">public</span> R saveAd(<span class="hljs-meta">@RequestBody</span> Ad ad)&#123;    <span class="hljs-comment">//redisTemplate.opsForValue().set("ad1", ad);</span>    redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(<span class="hljs-string">"index::ad"</span>, ad);    <span class="hljs-keyword">return</span> R.ok();&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"get-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R getAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    Ad ad = (Ad)redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(key);    <span class="hljs-keyword">return</span> R.ok().<span class="hljs-keyword">data</span>(<span class="hljs-string">"ad"</span>, ad);&#125;<span class="hljs-meta">@DeleteMapping(<span class="hljs-meta-string">"remove-test/&#123;key&#125;"</span>)</span><span class="hljs-keyword">public</span> R removeAd(<span class="hljs-meta">@PathVariable</span> String key)&#123;    <span class="hljs-built_in">Boolean</span> delete = redisTemplate.delete(key);    System.<span class="hljs-keyword">out</span>.println(delete);<span class="hljs-comment">//是否删除成功</span>    <span class="hljs-built_in">Boolean</span> hasKey = redisTemplate.hasKey(key);    System.<span class="hljs-keyword">out</span>.println(hasKey);<span class="hljs-comment">//key是否存在</span>    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h3 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h3><p>redisTemplate提供了以下几种存储数据的方法</p><pre><code class="hljs gcode">redisTemplate.opsForValue<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作字符串</span>redisTemplate.opsForHash<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作hash</span>redisTemplate.opsForList<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作list</span>redisTemplate.opsForSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作set</span>redisTemplate.opsForZSet<span class="hljs-comment">()</span>; <span class="hljs-comment">//操作有序set</span></code></pre><h2 id="四、使用缓存注解"><a href="#四、使用缓存注解" class="headerlink" title="四、使用缓存注解"></a>四、使用缓存注解</h2><h3 id="1、修改Redis配置类"><a href="#1、修改Redis配置类" class="headerlink" title="1、修改Redis配置类"></a>1、修改Redis配置类</h3><p>配置类上添加注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableCaching</span></code></pre><p>添加bean配置</p><pre><code class="hljs reasonml">@Beanpublic CacheManager cache<span class="hljs-constructor">Manager(LettuceConnectionFactory <span class="hljs-params">connectionFactory</span>)</span> &#123;        RedisCacheConfiguration config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheConfiguration</span>.</span></span>default<span class="hljs-constructor">CacheConfig()</span>        <span class="hljs-comment">//过期时间600秒</span>        .entry<span class="hljs-constructor">Ttl(Duration.<span class="hljs-params">ofSeconds</span>(600)</span>)         <span class="hljs-comment">// 配置序列化</span>        .serialize<span class="hljs-constructor">KeysWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> StringRedisSerializer()</span>))        .serialize<span class="hljs-constructor">ValuesWith(RedisSerializationContext.SerializationPair.<span class="hljs-params">fromSerializer</span>(<span class="hljs-params">new</span> GenericJackson2JsonRedisSerializer()</span>))        .disable<span class="hljs-constructor">CachingNullValues()</span>;    RedisCacheManager cacheManager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisCacheManager</span>.</span></span>builder(connectionFactory)        .cache<span class="hljs-constructor">Defaults(<span class="hljs-params">config</span>)</span>        .build<span class="hljs-literal">()</span>;    return cacheManager;&#125;</code></pre><h3 id="2、添加缓存注解"><a href="#2、添加缓存注解" class="headerlink" title="2、添加缓存注解"></a>2、添加缓存注解</h3><p>@Cacheable(value = “xxx”, key = “‘xxx’”)：标注在方法上，对方法返回结果进行缓存。下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><p>service_cms：AdServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectByAdTypeId'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Ad&gt; selectByAdTypeId(String adTypeId) &#123;</code></pre><p>service_edu：CourseServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotCourse'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Course&gt; selectHotCourse() &#123;</code></pre><p>service_edu：TeacherServiceImpl</p><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(value = <span class="hljs-string">"index"</span>, key = <span class="hljs-string">"'selectHotTeacher'"</span>)<span class="hljs-variable">@Override</span>public List&lt;Teacher&gt; selectHotTeacher() &#123;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
      <tag>Redis</tag>
      
      <tag>bean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】Sentinel介绍和环境搭建</title>
    <link href="/2020/07/08/goujian/10.Sentinel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/07/08/goujian/10.Sentinel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Sentinel介绍和环境搭建"><a href="#【项目创建流程】Sentinel介绍和环境搭建" class="headerlink" title="【项目创建流程】Sentinel介绍和环境搭建"></a>【项目创建流程】Sentinel介绍和环境搭建</h1><h2 id="一、Sentinel介绍"><a href="#一、Sentinel介绍" class="headerlink" title="一、Sentinel介绍"></a>一、Sentinel介绍</h2><h3 id="1、什么是Sentinel"><a href="#1、什么是Sentinel" class="headerlink" title="1、什么是Sentinel"></a>1、什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于服务容错的综合性解决方案。它以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来保护服务的稳定性。</p><h3 id="2、Sentinel-的特征"><a href="#2、Sentinel-的特征" class="headerlink" title="2、Sentinel 的特征"></a>2、Sentinel 的特征</h3><ul><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li>完备的实时监控：Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 SpringCloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。</li><li>完善的扩展点：Sentinel 提供简单易用、完善的扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="3、Sentinel-的组成"><a href="#3、Sentinel-的组成" class="headerlink" title="3、Sentinel 的组成"></a>3、Sentinel 的组成</h3><p>核心库（Java 客户端）：不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo /Spring Cloud 等框架也有较好的支持。</p><p>控制台（Dashboard）：基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="二、Sentinel控制台"><a href="#二、Sentinel控制台" class="headerlink" title="二、Sentinel控制台"></a>二、Sentinel控制台</h2><p>Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。</p><h3 id="1、下载和安装"><a href="#1、下载和安装" class="headerlink" title="1、下载和安装"></a>1、下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></p><p>下载版本：sentinel-dashboard-1.7.0.jar</p><h3 id="2、启动控制台"><a href="#2、启动控制台" class="headerlink" title="2、启动控制台"></a>2、启动控制台</h3><p>控制台本身是一个SpringBoot项目，直接使用jar命令启动项目</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">sentinel-dashboard-1</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.jar</span></code></pre><pre><code class="hljs reasonml">java -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dserver</span>.</span></span>port=<span class="hljs-number">8888</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dcsp</span>.</span></span>sentinel.dashboard.server=localhost:<span class="hljs-number">8080</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dproject</span>.</span></span>name=sentinel-dashboard -jar sentinel-dashboard-<span class="hljs-number">1.7</span>.<span class="hljs-number">0.</span>jar</code></pre><p>访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>用户名密码：sentinel/sentinel</p><h2 id="三、微服务集成Sentinel客户端"><a href="#三、微服务集成Sentinel客户端" class="headerlink" title="三、微服务集成Sentinel客户端"></a>三、微服务集成Sentinel客户端</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Sentinel的pom依赖（实际是在服务消费者端需要依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加测试方法"><a href="#2、添加测试方法" class="headerlink" title="2、添加测试方法"></a>2、添加测试方法</h3><p>TeacherController中添加如下方法用于测试</p><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message1"</span>)</span><span class="hljs-keyword">public</span> String message1() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message1"</span>;&#125;<span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/message2"</span>)</span><span class="hljs-keyword">public</span> String message2() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"message2"</span>;&#125;</code></pre><h2 id="四、微服务连接控制台"><a href="#四、微服务连接控制台" class="headerlink" title="四、微服务连接控制台"></a>四、微服务连接控制台</h2><h3 id="1、微服务配置"><a href="#1、微服务配置" class="headerlink" title="1、微服务配置"></a>1、微服务配置</h3><p>service_edu微服务yml中添加以下配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span><span class="hljs-comment">#  cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span> <span class="hljs-comment">#跟控制台交流的端口，随意指定一个未使用的端口即可</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment"># 指定控制台服务的地址</span></code></pre><h3 id="2、swagger中测试"><a href="#2、swagger中测试" class="headerlink" title="2、swagger中测试"></a>2、swagger中测试</h3><p>测试message1和message2的访问</p><h3 id="3、查看sentinel控制台"><a href="#3、查看sentinel控制台" class="headerlink" title="3、查看sentinel控制台"></a>3、查看sentinel控制台</h3><p><img src="https://img2.jimu98.cn/blog/20200723155019.png" srcset="/img/loading.gif" alt="image-20200723155018963"></p><h3 id="4、控制台运行原理"><a href="#4、控制台运行原理" class="headerlink" title="4、控制台运行原理"></a>4、控制台运行原理</h3><p>Sentinel的控制台是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上，即在微服务中指定控制台的地址（localhost:8080）</p><p>并且还要开启一个跟控制台传递数据的端口（8081），控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。</p><h2 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h2><h3 id="1、引入sentinel的依赖"><a href="#1、引入sentinel的依赖" class="headerlink" title="1、引入sentinel的依赖"></a>1、引入sentinel的依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务容错--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、开启Sentinel支持"><a href="#2、开启Sentinel支持" class="headerlink" title="2、开启Sentinel支持"></a>2、开启Sentinel支持</h3><p>在service_edu的yml配置文件中开启Feign对Sentinel的支持</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h3 id="3、创建容错类"><a href="#3、创建容错类" class="headerlink" title="3、创建容错类"></a>3、创建容错类</h3><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign.fallback;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OssFileServiceFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">R <span class="hljs-title">removeFile</span><span class="hljs-params">(String url)</span> </span>&#123;        log.info(<span class="hljs-string">"熔断保护"</span>);        <span class="hljs-function"><span class="hljs-keyword">return</span> R.<span class="hljs-title">error</span><span class="hljs-params">()</span></span>;    &#125;&#125;</code></pre><h3 id="4、指定容错类"><a href="#4、指定容错类" class="headerlink" title="4、指定容错类"></a>4、指定容错类</h3><p>为OpenFeign远程调用接口添加fallback属性值没指定容错类</p><pre><code class="hljs less"><span class="hljs-variable">@Service</span><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">"service-oss"</span>, fallback = OssFileServiceFallBack.class)public interface OssFileService &#123;</code></pre><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>停止service_oss微服务，测试删除讲师的功能</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Sentinel</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】注册中心和服务调用和配置中心</title>
    <link href="/2020/07/08/goujian/9.Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2020/07/08/goujian/9.Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】Nacos注册中心和服务调用和配置中心"><a href="#【项目创建流程】Nacos注册中心和服务调用和配置中心" class="headerlink" title="【项目创建流程】Nacos注册中心和服务调用和配置中心"></a>【项目创建流程】Nacos注册中心和服务调用和配置中心</h1><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><h3 id="1、常见注册中心"><a href="#1、常见注册中心" class="headerlink" title="1、常见注册中心"></a>1、常见注册中心</h3><ul><li><p>Eureka：Eureka是Spring Cloud Netflix中的重要组件，主要作用就是做服务注册和发现。2.0遇到性能瓶颈，停止维护，现在已经闭源。</p></li><li><p>Consul：Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。</p></li><li><p>Zookeeper：zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目。</p></li><li><p>Nacos（Spring Cloud Alibaba）</p></li><li><ul><li>Alibaba针对Spring Cloud体系的注册中心</li><li>相对于 Spring Cloud Eureka 来说，Nacos 更强大</li><li>Nacos = Spring Cloud Eureka + Spring Cloud Config + Spring Cloud Bus</li></ul></li></ul><h3 id="2、为什么叫Nacos"><a href="#2、为什么叫Nacos" class="headerlink" title="2、为什么叫Nacos"></a>2、为什么叫Nacos</h3><ul><li><p>前四个字母分别为 Naming 和 Configuration 的前两个字母，最后的s为Service</p></li><li><ul><li>Dynamic Naming and Configuration Service</li></ul></li><li><p>Nacos就是：注册中心 + 配置中心的组合</p></li><li><ul><li>Spring Cloud Alibaba Nacos = SpringCloudEureka + SpringCloudConfig +SpringCloudBus</li></ul></li></ul><h3 id="3、Nacos下载和安装"><a href="#3、Nacos下载和安装" class="headerlink" title="3、Nacos下载和安装"></a>3、Nacos下载和安装</h3><p>下载地址：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>下载版本：nacos-server-1.1.4.zip 或 nacos-server-1.1.4.tar.gz，解压任意目录即可</p><h3 id="4、启动Nacos"><a href="#4、启动Nacos" class="headerlink" title="4、启动Nacos"></a>4、启动Nacos</h3><p>- Windows</p><p>启动：双击bin/startup.cmd运行文件</p><p>访问：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><p>- Linux/Unix/Mac</p><p>启动命令(standalone代表着单机模式运行，非集群模式)</p><p>启动命令：sh startup.sh -m standalone</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><p>service模块中配置Nacos客户端的pom依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、添加服务配置信息"><a href="#2、添加服务配置信息" class="headerlink" title="2、添加服务配置信息"></a>2、添加服务配置信息</h3><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span></code></pre><p>接下来要起一个名字，这样才能知道这个服务在配置中心叫什么</p><pre><code class="hljs yaml"><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">gulimall-coupon</span></code></pre><h3 id="3、添加Nacos客户端注解"><a href="#3、添加Nacos客户端注解" class="headerlink" title="3、添加Nacos客户端注解"></a>3、添加Nacos客户端注解</h3><p>在客户端微服务启动类中添加注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span>   <span class="hljs-comment">//开启服务注册发现，这个注解可加可不加</span></code></pre><h3 id="4、启动客户端微服务"><a href="#4、启动客户端微服务" class="headerlink" title="4、启动客户端微服务"></a>4、启动客户端微服务</h3><p>启动注册中心，启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><p><img src="https://img2.jimu98.cn/blog/20200723155043.png" srcset="/img/loading.gif" alt="image-20200723155043496"></p><h2 id="基于OpenFeign的服务调用"><a href="#基于OpenFeign的服务调用" class="headerlink" title="基于OpenFeign的服务调用"></a>基于OpenFeign的服务调用</h2><h3 id="一、OpenFeign是什么"><a href="#一、OpenFeign是什么" class="headerlink" title="一、OpenFeign是什么"></a>一、OpenFeign是什么</h3><p>说起这个，还得先知道Feign是什么，Feign是一个声明式的Http客户端，它的目的就是让远程调用更加简单，Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数，格式，地址等信息</p><p>OpenFeign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。</p><p>Nacos很好的兼容了OpenFeign， OpenFeign默认集成了 Ribbon， 所以在Nacos下使用OpenFeign默认就实现了负载均衡的效果。</p><h3 id="二、OpenFeign的引入"><a href="#二、OpenFeign的引入" class="headerlink" title="二、OpenFeign的引入"></a>二、OpenFeign的引入</h3><h4 id="1、引入依赖-1"><a href="#1、引入依赖-1" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>service模块中配置OpenFeign的pom依赖（实际是在服务消费者端需要OpenFeign的依赖）</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务调用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2、启动类添加注解"><a href="#2、启动类添加注解" class="headerlink" title="2、启动类添加注解"></a>2、启动类添加注解</h4><p>在消费者service_edu的启动类添加如下注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span>或者<span class="hljs-meta">@EnableFeignClients</span>(basePackages = <span class="hljs-string">"cn.jimu98.gulimall.member.feign"</span>)</code></pre><h3 id="三、OpenFeign的使用"><a href="#三、OpenFeign的使用" class="headerlink" title="三、OpenFeign的使用"></a>三、OpenFeign的使用</h3><h4 id="1、oss微服务中创建测试api"><a href="#1、oss微服务中创建测试api" class="headerlink" title="1、oss微服务中创建测试api"></a>1、oss微服务中创建测试api</h4><p>服务的生产者的FileController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test() &#123;    <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h4 id="2、edu微服务中创建远程调用接口"><a href="#2、edu微服务中创建远程调用接口" class="headerlink" title="2、edu微服务中创建远程调用接口"></a>2、edu微服务中创建远程调用接口</h4><p>服务消费者中创建feign包，创建如下接口：</p><p>该接口首先写上注解</p><p>@FeignClient(“service-oss”)  表示调用哪个微服务</p><p>然后里面写上具体的方法（该方法去直接复制生产者Controller复制即可，但是要注意全地址，包括类注解地址）</p><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.feign;<span class="hljs-meta">@Service</span><span class="hljs-meta">@FeignClient(<span class="hljs-meta-string">"service-oss"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OssFileService</span> </span>&#123;    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/admin/oss/file/test"</span>)</span>    R test();&#125;</code></pre><h4 id="3、调用远程方法"><a href="#3、调用远程方法" class="headerlink" title="3、调用远程方法"></a>3、调用远程方法</h4><p>服务消费者中的TeacherController中添加如下方法：</p><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span>private OssFileService ossFileService;<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">"测试服务调用"</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test"</span>)public R test()&#123;    <span class="hljs-selector-tag">ossFileService</span><span class="hljs-selector-class">.test</span>();    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.ok</span>();&#125;</code></pre><h3 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h3><h4 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h4><table><thead><tr><th>策略名</th><th>策略描述</th></tr></thead><tbody><tr><td>BestAvailableRule</td><td>选择一个最小的并发请求的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）</td></tr><tr><td>WeightedResponseTimeRule</td><td>根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</td></tr><tr><td>RetryRule</td><td>对选定的负载均衡策略机上重试机制。</td></tr><tr><td>RoundRobinRule</td><td>轮询选择server</td></tr><tr><td>RandomRule</td><td>随机选择一个server</td></tr><tr><td>ZoneAvoidanceRule</td><td>综合判断server所在区域的性能和server的可用性选择server</td></tr></tbody></table><p>配置负载均衡策略的方式：</p><pre><code class="hljs yaml"><span class="hljs-attr">service-product:</span> <span class="hljs-comment"># 调用的提供者的名称 </span>  <span class="hljs-attr">ribbon:</span>     <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span></code></pre><h3 id="五、OpenFeign的超时控制"><a href="#五、OpenFeign的超时控制" class="headerlink" title="五、OpenFeign的超时控制"></a>五、OpenFeign的超时控制</h3><h4 id="1、模拟长流程业务"><a href="#1、模拟长流程业务" class="headerlink" title="1、模拟长流程业务"></a>1、模拟长流程业务</h4><p>修改oss服务FileController的test方法，添加sleep 3秒：</p><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"测试"</span>)<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    log.info(<span class="hljs-string">"oss test被调用"</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> R.ok();&#125;</code></pre><h4 id="2、远程调用测试"><a href="#2、远程调用测试" class="headerlink" title="2、远程调用测试"></a>2、远程调用测试</h4><p>上面的程序在测试时会出现远程调用超时错误。如下：因为OpenFeign默认等待1秒钟，否则超时报错</p><p>重试规则：每隔一秒发起重试</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 同一实例最大重试次数，不包括首次调用，默认0</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 重试其他实例的最大重试次数，不包括首次所选的server，默认1</span></code></pre><h4 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h4><p>application.yml文件中配置ribbon的超时时间（因为OpenFeing的底层即是对ribbon的封装）</p><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span></code></pre><h3 id="六、OpenFeign日志"><a href="#六、OpenFeign日志" class="headerlink" title="六、OpenFeign日志"></a>六、OpenFeign日志</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>OpenFeign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解OpenFeign中Http请求的细节。即对OpenFeign远程接口调用的情况进行监控和日志输出。</p><h4 id="2、日志级别"><a href="#2、日志级别" class="headerlink" title="2、日志级别"></a>2、日志级别</h4><ul><li>NONE：默认级别，不显示日志</li><li>BASIC：仅记录请求方法、URL、响应状态及执行时间</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应头信息</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应正文及元数据信息</li></ul><h4 id="3、配置日志bean"><a href="#3、配置日志bean" class="headerlink" title="3、配置日志bean"></a>3、配置日志bean</h4><p>在service_edu中创建配置文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.config</span>;<span class="hljs-keyword">@Configuration</span>public class OpenFeignConfig &#123;    <span class="hljs-keyword">@Bean</span>    Logger.Level feignLoggerLevel()&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Logger</span><span class="hljs-selector-class">.Level</span><span class="hljs-selector-class">.FULL</span>;    &#125;&#125;</code></pre><h4 id="4、开启日志"><a href="#4、开启日志" class="headerlink" title="4、开启日志"></a>4、开启日志</h4><p>在service_edu中，application.yml中指定监控的接口，以及日志级别</p><pre><code class="hljs css"><span class="hljs-selector-tag">logging</span>:  <span class="hljs-selector-tag">level</span>:    <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.guli</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.edu</span><span class="hljs-selector-class">.feign</span><span class="hljs-selector-class">.OssFileService</span>: <span class="hljs-selector-tag">debug</span> #以什么级别监控哪个接口</code></pre><h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><h3 id="首先导入依赖"><a href="#首先导入依赖" class="headerlink" title="首先导入依赖"></a>首先导入依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置中心来做配置管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="新建bootstrap-yml-配置文件中配置Nacos-Config元数据"><a href="#新建bootstrap-yml-配置文件中配置Nacos-Config元数据" class="headerlink" title="新建bootstrap.yml 配置文件中配置Nacos Config元数据"></a>新建bootstrap.yml 配置文件中配置Nacos Config元数据</h3><blockquote><p>你既然要获取配置，那说明你上来根本没有配置，所以你得创建一个优先级更高的配置</p><p>来指定配置中心的地址</p><p>然后动态获取配置文件</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-sms</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">config:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos中心地址</span>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式，如果是properties文件则不用配置此项</span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.name1&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;user.age&#125;"</span>)<span class="hljs-keyword">private</span> String age;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"name"</span>, name+<span class="hljs-string">" ..."</span>).put(<span class="hljs-string">"age"</span>, age);&#125;</code></pre><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>public（保留空间）默认新增的所有配置都在public空间</p><p>开发，测试，生产：可能有不同的配置，这时候就可以创建不同的命名空间</p><blockquote><p>你可以创建不同的命名空间，然后创建配置的时候选择不同的命名空间</p><p>然后修改bootstrap文件，spring.cloud.nacos.config.namespace=xxxx;(id编号)</p></blockquote><h3 id="配置集"><a href="#配置集" class="headerlink" title="配置集"></a>配置集</h3><p>所有配置的集合</p><p>配置集ID：类似文件名</p><p>​    Data ID：</p><blockquote><p>使用spring.cloud.nacos.config.group=1111  //切换不同的组</p></blockquote><p>加载多个配置集</p><blockquote><p>spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml</p><p>spring.cloud.nacos.config.ext-config[0].group=dev</p><p>spring.cloud.nacos.config.ext-config[0].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml</p><p>spring.cloud.nacos.config.ext-config[1].group=dev</p><p>spring.cloud.nacos.config.ext-config[1].refresh=true  //配置是否自动刷新</p><p>spring.cloud.nacos.config.ext-config[2].data-id=other.yml</p><p>spring.cloud.nacos.config.ext-config[2].group=dev</p><p>spring.cloud.nacos.config.ext-config[2].refresh=true  //配置是否自动刷新</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Nacos</tag>
      
      <tag>服务注册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端项目开发流程</title>
    <link href="/2020/07/08/goujian/8.%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/07/08/goujian/8.%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端项目开发流程"><a href="#【项目创建流程】前端项目开发流程" class="headerlink" title="【项目创建流程】前端项目开发流程"></a>【项目创建流程】前端项目开发流程</h1><h2 id="定义路由模块"><a href="#定义路由模块" class="headerlink" title="定义路由模块"></a>定义路由模块</h2><pre><code class="hljs js"><span class="hljs-comment">// 课程管理</span>  &#123;    path: <span class="hljs-string">'/course'</span>,    component: Layout,    redirect: <span class="hljs-string">'/course/list'</span>,    name: <span class="hljs-string">'Course'</span>,    meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程管理'</span> &#125;,    children: [      &#123;        path: <span class="hljs-string">'list'</span>,        name: <span class="hljs-string">'CourseList'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/list'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'课程列表'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info'</span>,        name: <span class="hljs-string">'CourseInfo'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'发布课程'</span> &#125;      &#125;,      &#123;        path: <span class="hljs-string">'info/:id'</span>,        name: <span class="hljs-string">'CourseInfoEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑课程'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;,      &#123;        path: <span class="hljs-string">'chapter/:id'</span>,        name: <span class="hljs-string">'CourseChapterEdit'</span>,        component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/course/form'</span>),        meta: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'编辑大纲'</span> &#125;,        hidden: <span class="hljs-literal">true</span>      &#125;    ]  &#125;,</code></pre><h2 id="定义api模块"><a href="#定义api模块" class="headerlink" title="定义api模块"></a>定义api模块</h2><pre><code class="hljs js"><span class="hljs-comment">// @ 符号在build/webpack.base.conf.js 中配置 表示 'src' 路径</span><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  list() &#123;    <span class="hljs-keyword">return</span> request(&#123;      url: <span class="hljs-string">'/admin/edu/teacher/list'</span>,      method: <span class="hljs-string">'get'</span>    &#125;)  &#125;&#125;</code></pre><h2 id="定义页面组件脚本"><a href="#定义页面组件脚本" class="headerlink" title="定义页面组件脚本"></a>定义页面组件脚本</h2><pre><code class="hljs vu">&lt;script&gt;import teacherApi from &#39;@&#x2F;api&#x2F;teacher&#39;export default &#123;  &#x2F;&#x2F; 定义数据模型  data() &#123;    return &#123;      list: [] &#x2F;&#x2F; 讲师列表    &#125;  &#125;,  &#x2F;&#x2F; 页面渲染成功后获取数据  created() &#123;    this.fetchData()  &#125;,  &#x2F;&#x2F; 定义方法  methods: &#123;    fetchData() &#123;      &#x2F;&#x2F; 调用api      teacherApi.list().then(response &#x3D;&gt; &#123;        this.list &#x3D; response.data.items      &#125;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h2 id="定义页面组件模板"><a href="#定义页面组件模板" class="headerlink" title="定义页面组件模板"></a>定义页面组件模板</h2><pre><code class="hljs vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    讲师列表  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】前端业务总结</title>
    <link href="/2020/07/08/goujian/7.%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1/"/>
    <url>/2020/07/08/goujian/7.%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】前端业务总结"><a href="#【项目创建流程】前端业务总结" class="headerlink" title="【项目创建流程】前端业务总结"></a>【项目创建流程】前端业务总结</h1><h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>为方便后续开发，建议安装如下插件</p><p><img src="https://img2.jimu98.cn/blog/20200723155141.png" srcset="/img/loading.gif" alt="image-20200723155141680"></p><p><img src="https://img2.jimu98.cn/blog/20200723155224.png" srcset="/img/loading.gif" alt="image-20200723155224355"></p><p><img src="https://img2.jimu98.cn/blog/20200723155212.png" srcset="/img/loading.gif" alt="image-20200723155212540"></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h4><p>浏览器的内核包括两部分核心：</p><ul><li><p>DOM渲染引擎</p></li><li><p>JavaScript解析引擎</p></li><li><ul><li>Chrome浏览器内置V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</li></ul></li></ul><h4 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h4><p>脱离浏览器环境也可以运行JavaScript，只要有JavaScript引擎就可以。</p><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境：即Node.js内置了Chrome的V8 引擎，可以在Node.js环境中直接运行JavaScript程序。</p><ul><li><p>在Node.js中写JavaScript和在Chrome浏览器中写JavaScript<strong>基本</strong>没有什么不一样。哪里不一样呢？</p></li><li><ul><li>Node.js没有浏览器API，即document，window的等。</li><li>加了许多Node.js 专属API，例如文件系统，进程，http功能。</li></ul></li></ul><h4 id="Node-js有什么用"><a href="#Node-js有什么用" class="headerlink" title="Node.js有什么用"></a>Node.js有什么用</h4><ul><li><p>如果你想开发类似JavaWeb的简单的后端程序，那么学习Node.js是一个非常好的选择。</p></li><li><p>如果你想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p></li><li><ul><li>通常他会被用来作一个BFF层，即 Backend For Frontend（服务于前端的后端），通俗的说是一个专门用于为前端业务提供数据的后端程序</li></ul></li></ul><h4 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h4><h5 id="BFF-解决什么问题"><a href="#BFF-解决什么问题" class="headerlink" title="BFF 解决什么问题"></a>BFF 解决什么问题</h5><p>一个前端页面向 Service A、Service B 以及 Service C发送请求，不同的微服务返回的值用于渲染页面中不同的组件。此时，每次访问该页面都需要发送 3 个请求。我们需要一个服务来聚合Service A、Service B 以及 Service C响应的数据，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF0_2.png" srcset="/img/loading.gif" alt="img"></p><p>手机、平板端、PC机等用户终端都需要向每个Service，例如Service A发送请求。对于同一个功能，不同的终端需要的数据格式和内容会有不同。此时 Service A 的一个接口，不能同时满足三个客户端的不同需求。我们可以在Service A中开发三个接口，也可以增加一个数据裁剪服务，将数据按照不同终端的不同要求进行裁剪，这个服务层叫做BFF。</p><p><img src="http://img1.jimu98.cn//blog/BFF1_2.png" srcset="/img/loading.gif" alt="img"></p><p>BFF层的作用是让前端有能力自由组装后台数据，减少大量的业务沟通成本，加快业务的迭代速度。无论是数据聚合还是数据剪裁，这类程序的特点是不需要太强大的服务器运算能力，但是对程序的灵活性有较高的要求，这两个特点都正好和Node.js的优势相吻合。</p><h5 id="什么是BFF"><a href="#什么是BFF" class="headerlink" title="什么是BFF"></a>什么是BFF</h5><p>用户体验适配器</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击安装 node-v10.14.2-x64.msi</p><blockquote><p>查看版本 node -v</p></blockquote><h3 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h3><p>在为 AngularJS 工作之后，Vue 的作者尤雨溪开发出了这一框架。他声称自己的思路是提取 Angular 中为自己所喜欢的部分，构建出一款相当轻量的框架。Vue 最早发布于 2014 年 2 月。作者在 Hacker News、Echo JS 与 Reddit 的 javascript 版块发布了最早的版本。一天之内，Vue 就登上了这三个网站的首页。Vue 是 Github 上最受欢迎的开源项目之一。同时，在 JavaScript 框架/函数库中，Vue 所获得的星标数已超过 React，并高于 Backbone.js、Angular 2、jQuery 等项目。</p><p>Vue.js 是一款流行的 JavaScript 前端框架，目的是简化 Web 开发。Vue 所关注的核心是 MVC 模式中的视图层，同时，它也能方便地获取数据更新，实现视图与模型的交互。</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是独立于vue的一个项目，可以用于浏览器和node.js中发送ajax请求</p><h3 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h3><h4 id="1、引入脚本库"><a href="#1、引入脚本库" class="headerlink" title="1、引入脚本库"></a>1、引入脚本库</h4><p><strong>在axios_pro文件夹中引入：</strong>element-ui\lib</p><p><img src="http://img1.jimu98.cn//blog/49b60e78-20d8-4928-a8b6-0b2250de4a84.png" srcset="/img/loading.gif" alt="img"></p><h4 id="2、引入css"><a href="#2、引入css" class="headerlink" title="2、引入css"></a>2、引入css</h4><p>在axios.html 的head中引入css</p><pre><code class="hljs js">&lt;!-- <span class="hljs-keyword">import</span> CSS --&gt;&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"element-ui/lib/theme-chalk/index.css"</span>&gt;</code></pre><h4 id="3、引入js"><a href="#3、引入js" class="headerlink" title="3、引入js"></a>3、引入js</h4><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"element-ui/lib/index.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h4 id="4、渲染讲师列表"><a href="#4、渲染讲师列表" class="headerlink" title="4、渲染讲师列表"></a>4、渲染讲师列表</h4><p>注意：项目中的版本是2.4，参考对应版本的文档</p><pre><code class="hljs vue">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;el-button&gt;添加&lt;&#x2F;el-button&gt;    &lt;i class&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;i&gt;    &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;搜索&lt;&#x2F;el-button&gt;    &lt;el-table              :data&#x3D;&quot;teacherList&quot;              stripe              border              style&#x3D;&quot;width: 100%&quot;&gt;        &lt;el-table-column              type&#x3D;&quot;selection&quot;              width&#x3D;&quot;55&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;name&quot;              label&#x3D;&quot;姓名&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              prop&#x3D;&quot;gmtCreate&quot;              label&#x3D;&quot;入驻日期&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column              label&#x3D;&quot;级别&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;                &#123;&#123; scope.row.level &#x3D;&#x3D;&#x3D; 1?&#39;高级讲师&#39;:&#39;首席讲师&#39; &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;&lt;&#x2F;div&gt;</code></pre><h3 id="NPM包管理器"><a href="#NPM包管理器" class="headerlink" title="NPM包管理器"></a>NPM包管理器</h3><h4 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h4><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 。</p><pre><code class="hljs coffeescript"><span class="hljs-comment">#在命令提示符输入 npm -v 可查看当前npm版本</span><span class="hljs-built_in">npm</span> -v</code></pre><h4 id="1、项目初始化"><a href="#1、项目初始化" class="headerlink" title="1、项目初始化"></a><strong>1、项目初始化</strong></h4><pre><code class="hljs vala"><span class="hljs-meta">#建立一个空文件夹，在命令提示符进入该文件夹  执行命令初始化</span>npm init<span class="hljs-meta">#按照提示输入相关信息，如果是用默认值则直接回车即可。</span><span class="hljs-meta">#name: 项目名称</span><span class="hljs-meta">#version: 项目版本号</span><span class="hljs-meta">#description: 项目描述</span><span class="hljs-meta">#keywords: &#123;Array&#125;关键词，便于用户搜索到我们的项目</span><span class="hljs-meta">#最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml</span><span class="hljs-meta">#我们之后也可以根据需要进行修改。</span></code></pre><pre><code class="hljs coffeescript"><span class="hljs-comment">#如果想直接生成 package.json 文件，那么可以使用命令</span><span class="hljs-built_in">npm</span> init -y</code></pre><h4 id="2、修改npm镜像"><a href="#2、修改npm镜像" class="headerlink" title="2、修改npm镜像"></a><strong>2、修改npm镜像</strong></h4><p>NPM官方的管理的包都是从 <a href="http://npmjs.com下载的，但是这个网站在国内速度很慢。" target="_blank" rel="noopener">http://npmjs.com下载的，但是这个网站在国内速度很慢。</a></p><p>这里推荐使用淘宝 NPM 镜像 <a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> ，淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。</p><p><strong>设置镜像地址：</strong></p><pre><code class="hljs tcl"><span class="hljs-comment">#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载</span>npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">registry</span> https://<span class="hljs-keyword">registry</span>.npm.taobao.org <span class="hljs-comment">#查看npm配置信息</span>npm config <span class="hljs-keyword">list</span></code></pre><h4 id="3、npm-install命令的使用"><a href="#3、npm-install命令的使用" class="headerlink" title="3、npm install命令的使用"></a><strong>3、npm install命令的使用</strong></h4><p>基本命令</p><pre><code class="hljs vala"><span class="hljs-meta">#使用 npm install 安装依赖包的最新版，</span><span class="hljs-meta">#模块安装的位置：项目目录\node_modules</span><span class="hljs-meta">#同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 &lt;dependencies&gt;</span><span class="hljs-meta">#默认参数：--save  简写  -S  将当前依赖保存在dependencies节点下</span>npm install jquery</code></pre><p>下载特定版本的依赖</p><pre><code class="hljs angelscript">#如果安装时想指定特定的版本npm install <span class="hljs-symbol">jquery@</span><span class="hljs-number">2.1</span>.x</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>下载开发依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖</span><span class="hljs-meta">#使用 -D参数将依赖添加到devDependencies节点</span>npm install --save-dev eslint<span class="hljs-meta">#或简写</span>npm i -D eslint</code></pre><p>下载全局依赖</p><pre><code class="hljs vala"><span class="hljs-meta">#全局安装</span><span class="hljs-meta">#Node.js全局安装的npm包和工具的位置：用户目录\AppData\Roaming\npm\node_modules</span><span class="hljs-meta">#一些命令行工具常使用全局安装的方式</span>npm install --global webpack<span class="hljs-meta">#或简写</span>npm install -g webpack</code></pre><p>根据依赖下载安装包</p><pre><code class="hljs cmake"><span class="hljs-comment">#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹</span><span class="hljs-comment">#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本</span>npm <span class="hljs-keyword">install</span> <span class="hljs-comment">#根据package.json中的配置下载依赖，初始化项目</span></code></pre><h4 id="4、其它命令"><a href="#4、其它命令" class="headerlink" title="4、其它命令"></a><strong>4、其它命令</strong></h4><pre><code class="hljs coffeescript"><span class="hljs-comment">#更新包（更新到最新版本）</span><span class="hljs-built_in">npm</span> update 包名<span class="hljs-comment">#全局更新</span><span class="hljs-built_in">npm</span> update -g 包名<span class="hljs-comment">#卸载包</span><span class="hljs-built_in">npm</span> uninstall 包名<span class="hljs-comment">#全局卸载</span><span class="hljs-built_in">npm</span> uninstall -g 包名</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】非业务功能统一处理</title>
    <link href="/2020/07/08/goujian/6.%E9%9D%9E%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/"/>
    <url>/2020/07/08/goujian/6.%E9%9D%9E%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】非业务功能统一处理"><a href="#【项目创建流程】非业务功能统一处理" class="headerlink" title="【项目创建流程】非业务功能统一处理"></a>【项目创建流程】非业务功能统一处理</h1><h2 id="统一返回数据格式"><a href="#统一返回数据格式" class="headerlink" title="统一返回数据格式"></a>统一返回数据格式</h2><p>项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p><p>例如，我们的系统要求返回的基本数据格式如下：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"code"</span>: <span class="hljs-number">20000</span>,  <span class="hljs-attr">"message"</span>: <span class="hljs-string">"成功"</span>,  <span class="hljs-attr">"data"</span>: &#123;    <span class="hljs-attr">"items"</span>: [      &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1"</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"刘德华"</span>,        <span class="hljs-attr">"intro"</span>: <span class="hljs-string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      &#125;    ]  &#125;&#125;</code></pre><h3 id="定义统一返回结果"><a href="#定义统一返回结果" class="headerlink" title="定义统一返回结果"></a>定义统一返回结果</h3><h4 id="创建返回码定义枚举类"><a href="#创建返回码定义枚举类" class="headerlink" title="创建返回码定义枚举类"></a>创建返回码定义枚举类</h4><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ResultCodeEnum &#123;    SUCCESS(<span class="hljs-keyword">true</span>, <span class="hljs-number">20000</span>,<span class="hljs-string">"成功"</span>),    UNKNOWN_REASON(<span class="hljs-keyword">false</span>, <span class="hljs-number">20001</span>, <span class="hljs-string">"未知错误"</span>),    BAD_SQL_GRAMMAR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21001</span>, <span class="hljs-string">"sql语法错误"</span>),    JSON_PARSE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21002</span>, <span class="hljs-string">"json解析异常"</span>),    PARAM_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21003</span>, <span class="hljs-string">"参数不正确"</span>),    FILE_UPLOAD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21004</span>, <span class="hljs-string">"文件上传错误"</span>),    FILE_DELETE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21005</span>, <span class="hljs-string">"文件刪除错误"</span>),    EXCEL_DATA_IMPORT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">21006</span>, <span class="hljs-string">"Excel数据导入错误"</span>),    VIDEO_UPLOAD_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22001</span>, <span class="hljs-string">"视频上传至阿里云失败"</span>),    VIDEO_UPLOAD_TOMCAT_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22002</span>, <span class="hljs-string">"视频上传至业务服务器失败"</span>),    VIDEO_DELETE_ALIYUN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22003</span>, <span class="hljs-string">"阿里云视频文件删除失败"</span>),    FETCH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22004</span>, <span class="hljs-string">"获取上传地址和凭证失败"</span>),    REFRESH_VIDEO_UPLOADAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22005</span>, <span class="hljs-string">"刷新上传地址和凭证失败"</span>),    FETCH_PLAYAUTH_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">22006</span>, <span class="hljs-string">"获取播放凭证失败"</span>),    URL_ENCODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23001</span>, <span class="hljs-string">"URL编码失败"</span>),    ILLEGAL_CALLBACK_REQUEST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23002</span>, <span class="hljs-string">"非法回调请求"</span>),    FETCH_ACCESSTOKEN_FAILD(<span class="hljs-keyword">false</span>, <span class="hljs-number">23003</span>, <span class="hljs-string">"获取accessToken失败"</span>),    FETCH_USERINFO_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23004</span>, <span class="hljs-string">"获取用户信息失败"</span>),    LOGIN_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">23005</span>, <span class="hljs-string">"登录失败"</span>),    COMMENT_EMPTY(<span class="hljs-keyword">false</span>, <span class="hljs-number">24006</span>, <span class="hljs-string">"评论内容必须填写"</span>),    PAY_RUN(<span class="hljs-keyword">false</span>, <span class="hljs-number">25000</span>, <span class="hljs-string">"支付中"</span>),    PAY_UNIFIEDORDER_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25001</span>, <span class="hljs-string">"统一下单错误"</span>),    PAY_ORDERQUERY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25002</span>, <span class="hljs-string">"查询支付结果错误"</span>),    ORDER_EXIST_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">25003</span>, <span class="hljs-string">"课程已购买"</span>),    GATEWAY_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">26000</span>, <span class="hljs-string">"服务不能访问"</span>),    CODE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28000</span>, <span class="hljs-string">"验证码错误"</span>),    LOGIN_PHONE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28009</span>, <span class="hljs-string">"手机号码不正确"</span>),    LOGIN_MOBILE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28001</span>, <span class="hljs-string">"账号不正确"</span>),    LOGIN_PASSWORD_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28008</span>, <span class="hljs-string">"密码不正确"</span>),    LOGIN_DISABLED_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28002</span>, <span class="hljs-string">"该用户已被禁用"</span>),    REGISTER_MOBLE_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28003</span>, <span class="hljs-string">"手机号已被注册"</span>),    LOGIN_AUTH(<span class="hljs-keyword">false</span>, <span class="hljs-number">28004</span>, <span class="hljs-string">"需要登录"</span>),    LOGIN_ACL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28005</span>, <span class="hljs-string">"没有权限"</span>),    SMS_SEND_ERROR(<span class="hljs-keyword">false</span>, <span class="hljs-number">28006</span>, <span class="hljs-string">"短信发送失败"</span>),    SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL(<span class="hljs-keyword">false</span>, <span class="hljs-number">28007</span>, <span class="hljs-string">"短信发送过于频繁"</span>);    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String message;    ResultCodeEnum(Boolean success, Integer code, String message) &#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;&#125;</code></pre><h4 id="创建结果类"><a href="#创建结果类" class="headerlink" title="创建结果类"></a>创建结果类</h4><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel</span>(value = <span class="hljs-string">"全局统一返回结果"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">R</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"是否成功"</span>)    <span class="hljs-keyword">private</span> Boolean success;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回码"</span>)    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回消息"</span>)    <span class="hljs-keyword">private</span> String message;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"返回数据"</span>)    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">R</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">ok</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());        r.setCode(ResultCodeEnum.SUCCESS.getCode());        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">error</span><span class="hljs-params">()</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());        r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());        r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title">setResult</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span></span>&#123;        R r = <span class="hljs-keyword">new</span> R();        r.setSuccess(resultCodeEnum.getSuccess());        r.setCode(resultCodeEnum.getCode());        r.setMessage(resultCodeEnum.getMessage());        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">success</span><span class="hljs-params">(Boolean success)</span></span>&#123;        <span class="hljs-keyword">this</span>.setSuccess(success);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">message</span><span class="hljs-params">(String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.setMessage(message);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">code</span><span class="hljs-params">(Integer code)</span></span>&#123;        <span class="hljs-keyword">this</span>.setCode(code);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(String key, Object value)</span></span>&#123;        <span class="hljs-keyword">this</span>.data.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">data</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;        <span class="hljs-keyword">this</span>.setData(map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;    List&lt;Teacher&gt; list = teacherService.list();    <span class="hljs-keyword">return</span> R.ok().data(<span class="hljs-string">"items"</span>, list).message(<span class="hljs-string">"获取讲师列表成功"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"remove/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">removeById</span><span class="hljs-params">(@PathVariable String id)</span></span>&#123;    <span class="hljs-keyword">boolean</span> result = teacherService.removeById(id);    <span class="hljs-keyword">if</span>(result)&#123;        <span class="hljs-keyword">return</span> R.ok().message(<span class="hljs-string">"删除成功"</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> R.error().message(<span class="hljs-string">"数据不存在"</span>);    &#125;&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="Controller创建分页方法"><a href="#Controller创建分页方法" class="headerlink" title="Controller创建分页方法"></a>Controller创建分页方法</h3><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list/&#123;page&#125;/&#123;limit&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">listPage</span><span class="hljs-params">(@ApiParam(value = <span class="hljs-string">"当前页码"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long page,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(value = <span class="hljs-string">"每页记录数"</span>, required = <span class="hljs-keyword">true</span>)</span> @PathVariable Long limit,</span><span class="hljs-function">                  @<span class="hljs-title">ApiParam</span><span class="hljs-params">(<span class="hljs-string">"讲师列表查询对象"</span>)</span> TeacherQueryVo teacherQueryVo)</span>&#123;    IPage&lt;Teacher&gt; pageModel = teacherService.selectPage(page, limit, teacherQueryVo);    List&lt;Teacher&gt; records = pageModel.getRecords();    <span class="hljs-keyword">long</span> total = pageModel.getTotal();    <span class="hljs-keyword">return</span>  R.ok().data(<span class="hljs-string">"total"</span>, total).data(<span class="hljs-string">"rows"</span>, records);&#125;</code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><blockquote><p>在我们平时写项目的时候，一般查询数据字段可能只需要三四个，但是数据库里面有十多个，甚至多数据库，多表查询</p><p>这时候就要根据返回类型创建Vo对象</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherQueryVo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;        <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer level;    <span class="hljs-keyword">private</span> String joinDateBegin;    <span class="hljs-keyword">private</span> String joinDateEnd;&#125;</code></pre><blockquote><p>创建完实体类，就需要写条件查询了</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.guli.service.edu.service.impl;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">TeacherMapper</span>, <span class="hljs-title">Teacher</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">TeacherService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;Teacher&gt; <span class="hljs-title">selectPage</span><span class="hljs-params">(Long page, Long limit, TeacherQueryVo teacherQueryVo)</span> </span>&#123;                Page&lt;Teacher&gt; pageParam = <span class="hljs-keyword">new</span> Page&lt;&gt;(page, limit);                QueryWrapper&lt;Teacher&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();        queryWrapper.orderByAsc(<span class="hljs-string">"sort"</span>);        <span class="hljs-keyword">if</span> (teacherQueryVo == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);        &#125;        String name = teacherQueryVo.getName();        Integer level = teacherQueryVo.getLevel();        String begin = teacherQueryVo.getJoinDateBegin();        String end = teacherQueryVo.getJoinDateEnd();        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(name)) &#123;            <span class="hljs-comment">//左%会使索引失效</span>            queryWrapper.likeRight(<span class="hljs-string">"name"</span>, name);        &#125;        <span class="hljs-keyword">if</span> (level != <span class="hljs-keyword">null</span>) &#123;            queryWrapper.eq(<span class="hljs-string">"level"</span>, level);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(begin)) &#123;            queryWrapper.ge(<span class="hljs-string">"join_date"</span>, begin);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(end)) &#123;            queryWrapper.le(<span class="hljs-string">"join_date"</span>, end);        &#125;        <span class="hljs-keyword">return</span> baseMapper.selectPage(pageParam, queryWrapper);    &#125;&#125;</code></pre><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理</p><h3 id="创建统一异常处理器"><a href="#创建统一异常处理器" class="headerlink" title="创建统一异常处理器"></a>创建统一异常处理器</h3><blockquote><p>一般创建在service-base中handler包中，</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> R.error();    &#125;&#125;</code></pre><blockquote><p>例如上面就可以捕获所有异常</p><p>但是在实际项目中，可以通过抛出指定异常，然后捕获自定义异常来返回异常信息</p></blockquote><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h2 id="1、创建自定义异常类"><a href="#1、创建自定义异常类" class="headerlink" title="1、创建自定义异常类"></a><strong>1、创建自定义异常类</strong></h2><p>service-base模块中创建cn.jimu98.guli.service.base.exception包，</p><p>创建GuliException.java通用异常类 继承 RuntimeException，RuntimeException 对代码没有侵入性</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuliException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-comment">//状态码</span>    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接受状态码和消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(Integer code, String message)</span> </span>&#123;        <span class="hljs-keyword">super</span>(message);        <span class="hljs-keyword">this</span>.code=code;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接收枚举类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resultCodeEnum</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuliException</span><span class="hljs-params">(ResultCodeEnum resultCodeEnum)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCodeEnum.getMessage());        <span class="hljs-keyword">this</span>.code = resultCodeEnum.getCode();    &#125;&#125;</code></pre><h2 id="2、添加异常处理方法"><a href="#2、添加异常处理方法" class="headerlink" title="2、添加异常处理方法"></a>2、添加异常处理方法</h2><p>GlobalExceptionHandler.java中添加</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(GuliException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">R</span> <span class="hljs-title">error</span>(<span class="hljs-title">GuliException</span> <span class="hljs-title">e</span>)</span>&#123;    log.error(ExceptionUtils.getMessage(e));    <span class="hljs-keyword">return</span> R.error().message(e.getMessage()).code(e.getCode());&#125;</code></pre><h2 id="3、修改FileController"><a href="#3、修改FileController" class="headerlink" title="3、修改FileController"></a>3、修改FileController</h2><p>在类上添加日志注解</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j</code></pre><p>业务中需要的位置抛出GuliException</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">upload</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        ......    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;        log.error(ExceptionUtils.getMessage(e));        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GuliException(ResultCodeEnum.FILE_UPLOAD_ERROR);    &#125;&#125;</code></pre><h2 id="4、打印完整的异常信息"><a href="#4、打印完整的异常信息" class="headerlink" title="4、打印完整的异常信息"></a>4、打印完整的异常信息</h2><p>GuliException类中重写toString方法</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"GuliException&#123;"</span> +        <span class="hljs-string">"code="</span> + code +        <span class="hljs-string">", message="</span> + <span class="hljs-keyword">this</span>.getMessage() +        <span class="hljs-string">'&#125;'</span>;&#125;</code></pre><h2 id="三、前端错误处理"><a href="#三、前端错误处理" class="headerlink" title="三、前端错误处理"></a>三、前端错误处理</h2><h2 id="1、统一异常错误处理"><a href="#1、统一异常错误处理" class="headerlink" title="1、统一异常错误处理"></a>1、统一异常错误处理</h2><pre><code class="hljs stylus"><span class="hljs-comment">// 上传成功回调</span><span class="hljs-function"><span class="hljs-title">handleAvatarSuccess</span><span class="hljs-params">(res, file)</span></span> &#123;    console.log(res)    <span class="hljs-keyword">if</span> (res.success) &#123;        <span class="hljs-comment">// console.log(res)</span>        this<span class="hljs-selector-class">.teacher</span><span class="hljs-selector-class">.avatar</span> = res<span class="hljs-selector-class">.data</span>.url        <span class="hljs-comment">// 强制重新渲染</span>        this.<span class="hljs-variable">$forceUpdate</span>()    &#125; <span class="hljs-keyword">else</span> &#123;        this.<span class="hljs-variable">$message</span>.error(<span class="hljs-string">'上传失败 （非20000）'</span>)    &#125;&#125;,</code></pre><h2 id="2、http异常错误处理"><a href="#2、http异常错误处理" class="headerlink" title="2、http异常错误处理"></a>2、http异常错误处理</h2><p>注册事件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span> <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"handleAvatarError"</span>&gt;</span></code></pre><p>事件函数</p><pre><code class="hljs js"><span class="hljs-comment">// 错误处理</span>handleAvatarError() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>)    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'上传失败（http失败）'</span>)&#125;</code></pre><h2 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h2><h3 id="配置日志级别"><a href="#配置日志级别" class="headerlink" title="配置日志级别"></a>配置日志级别</h3><p>日志记录器（Logger）的行为是分等级的。如下表所示：</p><p>分为：FATAL、ERROR、WARN、INFO、DEBUG</p><p>默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别</p><pre><code class="hljs yaml"><span class="hljs-comment"># 设置日志级别</span><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">root:</span> <span class="hljs-string">ERROR</span></code></pre><p>这种方式能将ERROR级别以及以上级别的日志打印在控制台上</p><h3 id="Logback日志"><a href="#Logback日志" class="headerlink" title="Logback日志"></a>Logback日志</h3><p>spring boot内部使用Logback作为日志实现的框架。</p><p>Logback和log4j非常相似，如果你对log4j很熟悉，那对logback很快就会得心应手。</p><p>logback相对于log4j的一些优点：<a href="https://blog.csdn.net/caisini_vc/article/details/48551287" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/48551287</a></p><h4 id="配置logback日志"><a href="#配置logback日志" class="headerlink" title="配置logback日志"></a>配置logback日志</h4><p><strong>删除application.yml中的日志配置</strong></p><p><strong>安装idea彩色日志插件：grep console</strong></p><p>resources 中创建 logback-spring.xml （默认日志的名字，必须是这个名字）</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>  <span class="hljs-attr">scan</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">"10 seconds"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>logback<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"log.path"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"D:/project/helen/guli_log/edu"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--控制台日志格式：彩色日志--&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-comment">&lt;!-- boldMagenta:粗红--&gt;</span>    <span class="hljs-comment">&lt;!-- cyan:青色 --&gt;</span>    <span class="hljs-comment">&lt;!-- white:白色 --&gt;</span>    <span class="hljs-comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--文件日志格式--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_LOG_PATTERN"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss&#125; |%-5level |%thread |%file:%line |%logger |%msg%n"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ENCODING"</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志级别--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志格式--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志字符集--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"INFO_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志过滤器：此日志文件只记录INFO级别的--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"WARN_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录WARN级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ERROR_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志过滤器：此日志文件只记录ERROR级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--开发环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>        <span class="hljs-comment">&lt;!--可以灵活设置此处，从而控制日志的输出--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"WARN_FILE"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!--生产环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pro"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"ERROR"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h4 id="用日志记录器记录错误日志"><a href="#用日志记录器记录错误日志" class="headerlink" title="用日志记录器记录错误日志"></a>用日志记录器记录错误日志</h4><blockquote><p>类上添加注解@Slf4j</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>统一处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】配置Swagger</title>
    <link href="/2020/07/08/goujian/5.%E9%85%8D%E7%BD%AESwagger/"/>
    <url>/2020/07/08/goujian/5.%E9%85%8D%E7%BD%AESwagger/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】配置Swagger"><a href="#【项目创建流程】配置Swagger" class="headerlink" title="【项目创建流程】配置Swagger"></a>【项目创建流程】配置Swagger</h1><h2 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h2><p><a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>前后端分离开发模式中，api文档是最好的沟通方式。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)可测性 (直接在接口文档上进行测试，以方便理解业务)</p><ul><li>前端工程师编写接口文档（使用swagger2编辑器或其他接口生成工具）</li><li>交给后端工程师</li><li>根据swagger文档编写后端接口</li><li>最终根据生成的swagger文件进行接口联调</li></ul><h2 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>这个可以配置在common中  进行代码复用</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--swagger--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="创建Swagger2配置文件"><a href="#创建Swagger2配置文件" class="headerlink" title="创建Swagger2配置文件"></a>创建Swagger2配置文件</h3><blockquote><p>在service_base中创建Swagger2Config</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">webApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"webApi"</span>)                .apiInfo(webApiInfo())                .select()                <span class="hljs-comment">//只显示api路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/api/.*"</span>)))                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">adminApiConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .groupName(<span class="hljs-string">"adminApi"</span>)                .apiInfo(adminApiInfo())                .select()                <span class="hljs-comment">//只显示admin路径下的页面</span>                .paths(Predicates.and(PathSelectors.regex(<span class="hljs-string">"/admin/.*"</span>)))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">webApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"网站前台-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了网站微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">adminApiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"后台管理系统-API文档"</span>)                .description(<span class="hljs-string">"本文档描述了后台管理系统微服务接口定义"</span>)                .version(<span class="hljs-string">"1.0"</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Jimu98"</span>, <span class="hljs-string">"http://www.jimu98.cn"</span>, <span class="hljs-string">"z591593455@qq.com"</span>))                .build();    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p><a href="http://localhost:8101/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8101/swagger-ui.html</a>  进行测试</p></blockquote><h3 id="定义接口说明和参数说明"><a href="#定义接口说明和参数说明" class="headerlink" title="定义接口说明和参数说明"></a>定义接口说明和参数说明</h3><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
      <tag>Swagger2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】普通接口开发</title>
    <link href="/2020/07/08/goujian/4.%E6%99%AE%E9%80%9A%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"/>
    <url>/2020/07/08/goujian/4.%E6%99%AE%E9%80%9A%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】普通接口开发"><a href="#【项目创建流程】普通接口开发" class="headerlink" title="【项目创建流程】普通接口开发"></a>【项目创建流程】普通接口开发</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><blockquote><p>创建的时候选择utf8mb4  urf8修改了兼容四字节的字符，解决某些汉字出现乱码问题</p><p>utf8_general_ci: 校对速度快，但准确度稍差。</p><p>utf8_unicode_ci: 准确度高，但校对速度稍慢。</p><p>若数据库中有德语、法语或者俄语需求，需使用utf8_unicode_ci。其他情况用utf8_general_ci即可。</p></blockquote><h2 id="建Maven"><a href="#建Maven" class="headerlink" title="建Maven"></a>建Maven</h2><h2 id="改POM"><a href="#改POM" class="headerlink" title="改POM"></a>改POM</h2><h2 id="写YML"><a href="#写YML" class="headerlink" title="写YML"></a>写YML</h2><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8140</span> <span class="hljs-comment"># 服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 环境设置</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-cms</span> <span class="hljs-comment"># 服务名</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos服务地址</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>          <span class="hljs-attr">datasource:</span> <span class="hljs-comment"># mysql数据库连接</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/guli_cms?serverTimezone=GMT%2B8</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><span class="hljs-comment">#spring:</span>  <span class="hljs-attr">jackson:</span> <span class="hljs-comment">#返回json的全局时间格式</span>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment">#mybatis日志</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:cn/jimu98/guli/service/cms/mapper/xml/*.xml</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#连接建立的超时时长，默认1秒</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">10000</span> <span class="hljs-comment">#处理请求的超时时间，默认为1秒</span><span class="hljs-attr">feign:</span>  <span class="hljs-attr">sentinel:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><h2 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h2><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ComponentScan</span>(&#123;<span class="hljs-string">"cn.jimu98.guli"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceEduApplication</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceEduApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h2><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span> <span class="hljs-comment">//解决跨域问题</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin/edu/teacher"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TeacherService teacherService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> teacherService.list();    &#125;&#125;</code></pre><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><blockquote><p>项目经理不让用就自己写吧。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Controller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】MyBatisPlas流程</title>
    <link href="/2020/07/08/goujian/3.MyBatisPlas%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/07/08/goujian/3.MyBatisPlas%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】MyBatisPlas流程"><a href="#【项目创建流程】MyBatisPlas流程" class="headerlink" title="【项目创建流程】MyBatisPlas流程"></a>【项目创建流程】MyBatisPlas流程</h1><h2 id="MP简介"><a href="#MP简介" class="headerlink" title="MP简介"></a>MP简介</h2><p><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><ul><li><p>润物无声  </p></li><li><ul><li>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li></ul></li><li><p>效率至上</p></li><li><ul><li>只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。</li></ul></li><li><p>丰富功能</p></li><li><ul><li>热加载、代码生成、分页、性能分析等功能一应俱全。</li></ul></li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><h3 id="创建代码生成器"><a href="#创建代码生成器" class="headerlink" title="创建代码生成器"></a>创建代码生成器</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//String prefix = "dbxxx_";</span>        String moduleName = <span class="hljs-string">"statistics"</span>;        <span class="hljs-comment">// 1、创建代码生成器</span>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();        <span class="hljs-comment">// 2、全局配置</span>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">"user.dir"</span>);        gc.setOutputDir(projectPath + <span class="hljs-string">"/src/main/java"</span>);        gc.setAuthor(<span class="hljs-string">"jimu98"</span>);        gc.setOpen(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//生成后是否打开资源管理器</span><span class="hljs-comment">//        gc.setFileOverride(false); //重新生成时文件是否覆盖</span>        gc.setServiceName(<span class="hljs-string">"%sService"</span>);<span class="hljs-comment">//去掉Service接口的首字母I</span>        gc.setIdType(IdType.ASSIGN_ID); <span class="hljs-comment">//主键策略</span>        gc.setDateType(DateType.ONLY_DATE);<span class="hljs-comment">//定义生成的实体类中日期类型</span>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启Swagger2模式</span>        mpg.setGlobalConfig(gc);        <span class="hljs-comment">// 3、数据源配置</span>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();        dsc.setUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/"</span>  + <span class="hljs-string">"guli_"</span> + moduleName + <span class="hljs-string">"?serverTimezone=GMT%2B8"</span>);        dsc.setDriverName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);        dsc.setUsername(<span class="hljs-string">"root"</span>);        dsc.setPassword(<span class="hljs-string">""</span>);        dsc.setDbType(DbType.MYSQL);        mpg.setDataSource(dsc);        <span class="hljs-comment">// 4、包配置</span>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();        pc.setModuleName(moduleName); <span class="hljs-comment">//模块名</span>        pc.setParent(<span class="hljs-string">"cn.jimu98.guli.service"</span>);        pc.setController(<span class="hljs-string">"controller"</span>);        pc.setEntity(<span class="hljs-string">"entity"</span>);        pc.setService(<span class="hljs-string">"service"</span>);        pc.setMapper(<span class="hljs-string">"mapper"</span>);        mpg.setPackageInfo(pc);        <span class="hljs-comment">// 5、策略配置</span>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表映射到实体的命名策略</span>        strategy.setTablePrefix(moduleName + <span class="hljs-string">"_"</span>);<span class="hljs-comment">//设置表前缀不生成</span>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="hljs-comment">//数据库表字段映射到实体的命名策略</span>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy.setLogicDeleteFieldName(<span class="hljs-string">"is_deleted"</span>);<span class="hljs-comment">//逻辑删除字段名</span>        strategy.setEntityBooleanColumnRemoveIsPrefix(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//去掉布尔值的is_前缀</span>        <span class="hljs-comment">//自动填充</span>        TableFill gmtCreate = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_create"</span>, FieldFill.INSERT);        TableFill gmtModified = <span class="hljs-keyword">new</span> TableFill(<span class="hljs-string">"gmt_modified"</span>, FieldFill.INSERT_UPDATE);        ArrayList&lt;TableFill&gt; tableFills = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        tableFills.add(gmtCreate);        tableFills.add(gmtModified);        strategy.setTableFillList(tableFills);        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//restful api风格控制器</span>        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//url中驼峰转连字符</span>        mpg.setStrategy(strategy);        <span class="hljs-comment">//设置BaseEntity</span>        strategy.setSuperEntityClass(<span class="hljs-string">"cn.jimu98.guli.service.base.model.BaseEntity"</span>);        <span class="hljs-comment">// 填写BaseEntity中的公共字段</span>        strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);        <span class="hljs-comment">// 6、执行</span>        mpg.execute();    &#125;&#125;</code></pre><h3 id="优化代码生成器"><a href="#优化代码生成器" class="headerlink" title="优化代码生成器"></a>优化代码生成器</h3><blockquote><p>在真实情况下，每个表都会有三字段，ID，创建时间，更新时间</p><p>所以，这部分实体类可以抽取出来</p><p>一般我们在service_base中创建BaseEntity</p></blockquote><h4 id="首先创建一个基础实体类"><a href="#首先创建一个基础实体类" class="headerlink" title="首先创建一个基础实体类"></a>首先创建一个基础实体类</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.jimu98.service.base.model;<span class="hljs-meta">@Data</span><span class="hljs-meta">@EqualsAndHashCode</span>(callSuper = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@Accessors</span>(chain = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID=<span class="hljs-number">1L</span>;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"讲师ID"</span>)  <span class="hljs-comment">//这个是swagger的注解</span>    <span class="hljs-meta">@TableId</span>(value = <span class="hljs-string">"id"</span>, type = IdType.ASSIGN_ID)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"创建时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT)    <span class="hljs-keyword">private</span> Date gmtCreate;    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"更新时间"</span>)    <span class="hljs-meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)    <span class="hljs-keyword">private</span> Date gmtModified;&#125;</code></pre><h4 id="然后修改代码生成器中内容"><a href="#然后修改代码生成器中内容" class="headerlink" title="然后修改代码生成器中内容"></a>然后修改代码生成器中内容</h4><pre><code class="hljs java"><span class="hljs-comment">//设置BaseEntity</span>strategy.setSuperEntityClass(<span class="hljs-string">"com.atguigu.guli.service.base.model.BaseEntity"</span>);<span class="hljs-comment">// 填写BaseEntity中的公共字段</span>strategy.setSuperEntityColumns(<span class="hljs-string">"id"</span>, <span class="hljs-string">"gmt_create"</span>, <span class="hljs-string">"gmt_modified"</span>);</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><blockquote><p>@TableId(type = IdType.ASSIGN_ID)</p></blockquote><ul><li>描述：主键注解</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">主键字段名</td></tr><tr><td align="center">type</td><td align="center">Enum</td><td align="center">否</td><td align="center">IdType.NONE</td><td align="center">主键类型</td></tr></tbody></table><ul><li>type</li></ul><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AUTO</td><td align="center">数据库ID自增</td></tr><tr><td align="center">NONE</td><td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td></tr><tr><td align="center">INPUT</td><td align="center">insert前自行set主键值</td></tr><tr><td align="center">ASSIGN_ID</td><td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td align="center">ASSIGN_UUID</td><td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td></tr><tr><td align="center">ID_WORKER</td><td align="center">分布式全局唯一ID 长整型类型(please use <code>ASSIGN_ID</code>)</td></tr><tr><td align="center">UUID</td><td align="center">32位UUID字符串(please use <code>ASSIGN_UUID</code>)</td></tr><tr><td align="center">ID_WORKER_STR</td><td align="center">分布式全局唯一ID 字符串类型(please use <code>ASSIGN_ID</code>)</td></tr></tbody></table><p>要想影响所有实体的配置，可以设置全局主键配置</p><pre><code class="hljs yaml"><span class="hljs-comment">#全局设置主键生成策略</span><span class="hljs-string">mybatis-plus.global-config.db-config.id-type=auto</span></code></pre><blockquote><p>@TableField  </p></blockquote><ul><li>描述：字段注解(非主键)</li></ul><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">数据库字段名</td></tr><tr><td align="center">el</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">映射为原生 <code>#{ ... }</code> 逻辑,相当于写在 xml 里的 <code>#{ ... }</code> 部分</td></tr><tr><td align="center">exist</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否为数据库表字段</td></tr><tr><td align="center">condition</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>where</code> 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 <code>% s=#{ %s }</code>,<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java" target="_blank" rel="noopener">参考</a></td></tr><tr><td align="center">update</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">字段 <code>update set</code> 部分注入, 例如：update=”%s+1”：表示更新时会set version=version+1(该属性优先级高于 <code>el</code> 属性)</td></tr><tr><td align="center">insertStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#{columnProperty}&lt;/if&gt;)</code></td></tr><tr><td align="center">updateStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：IGNORED: <code>update table_a set column=#{columnProperty}</code></td></tr><tr><td align="center">whereStrategy</td><td align="center">Enum</td><td align="center">N</td><td align="center">DEFAULT</td><td align="center">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#{columnProperty}&lt;/if&gt;</code></td></tr><tr><td align="center">fill</td><td align="center">Enum</td><td align="center">否</td><td align="center">FieldFill.DEFAULT</td><td align="center">字段自动填充策略</td></tr><tr><td align="center">select</td><td align="center">boolean</td><td align="center">否</td><td align="center">true</td><td align="center">是否进行 select 查询</td></tr><tr><td align="center">keepGlobalFormat</td><td align="center">boolean</td><td align="center">否</td><td align="center">false</td><td align="center">是否保持使用全局的 format 进行处理</td></tr><tr><td align="center">jdbcType</td><td align="center">JdbcType</td><td align="center">否</td><td align="center">JdbcType.UNDEFINED</td><td align="center">JDBC类型 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">typeHandler</td><td align="center">Class&lt;? extends TypeHandler&gt;</td><td align="center">否</td><td align="center">UnknownTypeHandler.class</td><td align="center">类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">numericScale</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">指定小数点后保留的位数</td></tr></tbody></table><blockquote><p>另外这个注解的包可能不会自动引入，有个小BUG，所以需要手动引入一下,其他的就看官方文档吧</p></blockquote><h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><blockquote><p>这个主要是为create_time、update_time进行自动填充</p></blockquote><h4 id="实体类修改"><a href="#实体类修改" class="headerlink" title="实体类修改"></a>实体类修改</h4><p>在实体类（如果前面提取了公共实体类，那么这里操作公共实体类）添加注解@TableField(fill = FieldFill.INSERT)</p><p>FieldFill是一个enum 枚举类型 </p><p>所以create_time设置INSERT  ，update_time设置 INSERT_UPDATE</p><h4 id="实现元对象处理器接口"><a href="#实现元对象处理器接口" class="headerlink" title="实现元对象处理器接口"></a>实现元对象处理器接口</h4><p><strong><code>注意：不要忘记添加 @Component 注解</code></strong></p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start insert fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"createTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;        log.info(<span class="hljs-string">"start update fill ...."</span>);        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">"updateTime"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);    &#125;&#125;</code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h4><pre><code class="hljs java"><span class="hljs-meta">@Version</span><span class="hljs-keyword">private</span> Integer version;</code></pre><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"cn.jimu98.xxx.mapper"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;    &#125;</code></pre><h4 id="注册乐观锁插件"><a href="#注册乐观锁插件" class="headerlink" title="注册乐观锁插件"></a>注册乐观锁插件</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 乐观锁插件</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();&#125;</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页插件</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();&#125;</code></pre><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><h4 id="数据库修改"><a href="#数据库修改" class="headerlink" title="数据库修改"></a>数据库修改</h4><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`deleted`</span> <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span></code></pre><h4 id="实体类修改-1"><a href="#实体类修改-1" class="headerlink" title="实体类修改"></a>实体类修改</h4><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><span class="hljs-keyword">private</span> Integer deleted;</code></pre><h4 id="配置（可选）"><a href="#配置（可选）" class="headerlink" title="配置（可选）"></a>配置（可选）</h4><pre><code class="hljs yaml"><span class="hljs-string">mybatis-plus.global-config.db-config.logic-delete-value=1</span><span class="hljs-string">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span></code></pre><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><table><thead><tr><th><strong>查询方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>setSqlSelect</strong></td><td>设置 SELECT 查询字段</td></tr><tr><td><strong>where</strong></td><td>WHERE 语句，拼接 + WHERE 条件</td></tr><tr><td><strong>and</strong></td><td>AND 语句，拼接 + AND 字段=值</td></tr><tr><td><strong>andNew</strong></td><td>AND 语句，拼接 + AND (字段=值)</td></tr><tr><td><strong>or</strong></td><td>OR 语句，拼接 + OR 字段=值</td></tr><tr><td><strong>orNew</strong></td><td>OR 语句，拼接 + OR (字段=值)</td></tr><tr><td><strong>eq</strong></td><td>等于=</td></tr><tr><td><strong>allEq</strong></td><td>基于 map 内容等于=</td></tr><tr><td><strong>ne</strong></td><td>不等于&lt;&gt;</td></tr><tr><td><strong>gt</strong></td><td>大于&gt;</td></tr><tr><td><strong>ge</strong></td><td>大于等于&gt;=</td></tr><tr><td><strong>lt</strong></td><td>小于&lt;</td></tr><tr><td><strong>le</strong></td><td>小于等于&lt;=</td></tr><tr><td><strong>like</strong></td><td>模糊查询 LIKE</td></tr><tr><td><strong>notLike</strong></td><td>模糊查询 NOT LIKE</td></tr><tr><td><strong>in</strong></td><td>IN 查询</td></tr><tr><td><strong>notIn</strong></td><td>NOT IN 查询</td></tr><tr><td><strong>isNull</strong></td><td>NULL 值查询</td></tr><tr><td><strong>isNotNull</strong></td><td>IS NOT NULL</td></tr><tr><td><strong>groupBy</strong></td><td>分组 GROUP BY</td></tr><tr><td><strong>having</strong></td><td>HAVING 关键词</td></tr><tr><td><strong>orderBy</strong></td><td>排序 ORDER BY</td></tr><tr><td><strong>orderAsc</strong></td><td>ASC 排序 ORDER BY</td></tr><tr><td><strong>orderDesc</strong></td><td>DESC 排序 ORDER BY</td></tr><tr><td><strong>exists</strong></td><td>EXISTS 条件语句</td></tr><tr><td><strong>notExists</strong></td><td>NOT EXISTS 条件语句</td></tr><tr><td><strong>between</strong></td><td>BETWEEN 条件语句</td></tr><tr><td><strong>notBetween</strong></td><td>NOT BETWEEN 条件语句</td></tr><tr><td><strong>addFilter</strong></td><td>自由拼接 SQL</td></tr><tr><td><strong>last</strong></td><td>拼接在最后，例如：last(“LIMIT 1”)</td></tr></tbody></table><p>其他的就看官网吧<a href="https://mp.baomidou.com/guide/wrapper.html#abstractwrapper" target="_blank" rel="noopener">https://mp.baomidou.com/guide/wrapper.html#abstractwrapper</a></p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
      <tag>MyBatis-Plus</tag>
      
      <tag>代码生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】项目框架构建</title>
    <link href="/2020/07/08/goujian/2.%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/07/08/goujian/2.%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】项目框架构建"><a href="#【项目创建流程】项目框架构建" class="headerlink" title="【项目创建流程】项目框架构建"></a>【项目创建流程】项目框架构建</h1><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><blockquote><p>在项目创建初期，应该首先规划一下工程结构</p><p>将各个模块区分开来（根据阿里规范命名）</p><p>重复的功能进行抽离</p><p>pom文件根据范围选择合适的引用地址</p></blockquote><h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><h4 id="删除一些无用的文件"><a href="#删除一些无用的文件" class="headerlink" title="删除一些无用的文件"></a>删除一些无用的文件</h4><h4 id="配置SpringBoot版本"><a href="#配置SpringBoot版本" class="headerlink" title="配置SpringBoot版本"></a>配置SpringBoot版本</h4><h4 id="配置Pom文件依赖版本号"><a href="#配置Pom文件依赖版本号" class="headerlink" title="配置Pom文件依赖版本号"></a>配置Pom文件依赖版本号</h4><p>比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis-plus.version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis-plus.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">velocity.version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">velocity.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">swagger.version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">swagger.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aliyun.oss.version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">aliyun.oss.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jodatime.version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">jodatime.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-fileupload.version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">commons-fileupload.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-io.version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">commons-io.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">commons-lang.version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">commons-lang.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">httpclient.version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">httpclient.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre><h4 id="配置pom依赖"><a href="#配置pom依赖" class="headerlink" title="配置pom依赖"></a>配置pom依赖</h4><blockquote><p>这里不需要真正引入，在子项目中引入</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--Spring Cloud--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--mybatis-plus 持久层--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><h2 id="创建父模块"><a href="#创建父模块" class="headerlink" title="创建父模块"></a>创建父模块</h2><h3 id="创建普通Maven项目即可"><a href="#创建普通Maven项目即可" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h4 id="删除src文件夹"><a href="#删除src文件夹" class="headerlink" title="删除src文件夹"></a>删除src文件夹</h4><h4 id="配置POM"><a href="#配置POM" class="headerlink" title="配置POM"></a>配置POM</h4><blockquote><p>这里一般配置一下lombok mp，swagger之类的 以及子项目复用的依赖</p></blockquote><h2 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h2><h3 id="创建普通Maven项目即可-1"><a href="#创建普通Maven项目即可-1" class="headerlink" title="创建普通Maven项目即可"></a>创建普通Maven项目即可</h3><h3 id="配置Pom"><a href="#配置Pom" class="headerlink" title="配置Pom"></a>配置Pom</h3><h3 id="改YAM"><a href="#改YAM" class="headerlink" title="改YAM"></a>改YAM</h3><h3 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h3><h3 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h3><blockquote><p>看一下这个业务模块需不需要用代码生成器生成</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目创建流程】数据库规范</title>
    <link href="/2020/07/08/goujian/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    <url>/2020/07/08/goujian/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="【项目创建流程】数据库规范"><a href="#【项目创建流程】数据库规范" class="headerlink" title="【项目创建流程】数据库规范"></a>【项目创建流程】数据库规范</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h2><blockquote><p>注意，这里要遵循阿里数据库设计规约（参考《阿里巴巴Java开发手册》）</p></blockquote><p>1、库名与应用名称尽量一致</p><p>2、表名、字段名必须使用小写字母或数字，禁止出现数字开头，</p><p>3、表名不使用复数名词</p><p>4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher</p><p>5、表必备三字段：id, gmt_create, gmt_modified</p><p>6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p><p>7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 </p><p>说明：任何字段如果为非负数，必须是 unsigned。</p><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 </p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 </p><p>8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p><p>9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 </p><p>10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>11、唯一索引名为 uk_字段名(unique key)；普通索引名则为 idx_字段名(index)。</p><p>说明：uk_ 即 unique key；idx_ 即 index 的简称</p><p>12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p>]]></content>
    
    
    <categories>
      
      <category>项目构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
